pointer computer programming from wikipedia free encyclopedia jump navigation search i do consider assignment statements pointer variables be among computer science's most valuable treasures donald knuth structured programming with go statements pointer 'a' pointing memory address associated with variable 'b' note that this particular diagram computing architecture uses same address space data primitive for both pointers non-pointers this need not be case computer science pointer programming language object whose value refers points another value stored elsewhere computer memory using its memory address pointer references location memory obtaining value stored at that location known dereferencing pointer analogy page number book's index could be considered pointer corresponding page dereferencing such pointer would be done by flipping page with given page number pointers data significantly improve performance for repetitive operations such traversing strings lookup tables control tables tree structures particular often much cheaper time space copy dereference pointers than copy access data which pointers point pointers are also used hold addresses entry points for called subroutines procedural programming for run-time linking dynamic link libraries dlls object-oriented programming pointers functions are used for binding methods often using what are called virtual method tables pointer simple more concrete implementation more abstract reference data type several languages support some type pointer although some have more restrictions on their use than others while pointer has been used refer references general more properly applies data structures whose interface explicitly allows pointer be manipulated arithmetically via pointer arithmetic memory address opposed magic cookie capability where this not possible because pointers allow both protected unprotected access memory addresses there are risks associated with using them particularly latter case primitive pointers are often stored format similar integer however attempting dereference look up pointer whose value was never valid memory address would cause program crash alleviate this potential problem matter type safety pointers are considered separate type parameterized by type data they point even if underlying representation integer other measures may also be taken such validation & bounds checking verify contents pointer variable contain value that both valid memory address within numerical range that processor capable addressing contents history formal description use data structures use control tables architectural roots uses o c pointers o c arrays o c linked list o pass-by-address using pointers o dynamic memory allocation o memory-mapped hardware typed pointers casting making pointers safer null pointer autorelative pointer based pointer multiple indirection function pointer dangling pointer back pointer pointer declaration syntax overview wild branch simulation using array index support various programming languages o ada o basic o c c++ o c o cobol o pl/i o d o eiffel o fortran o go o java o modula-2 o oberon o pascal o perl see also references external links history harold lawson credited with invention pointer lawson was presented computer pioneer award by ieee “or inventing pointer variable introducing this concept into pl/i thus providing for first time capability flexibly treat linked lists general-purpose high level language” according oxford english dictionary word pointer first appeared print stack pointer technical memorandum by system development corporation formal description computer science pointer kind reference data primitive just primitive any datum that can be read from written computer memory using one memory access for instance both byte word are primitives data aggregate just aggregate group primitives that are logically contiguous memory that are viewed collectively one datum for instance aggregate could be logically contiguous bytes values which represent coordinates point space when aggregate entirely composed same type primitive aggregate may be called array sense multi-byte word primitive array bytes some programs use words this way context these definitions byte smallest primitive each memory address specifies different byte memory address initial byte datum considered memory address base memory address entire datum memory pointer just pointer primitive value which intended be used memory address said that pointer points memory address also said that pointer points datum when pointer's value datum's memory address more generally pointer kind reference said that pointer references datum stored somewhere memory obtain that datum dereference pointer feature that separates pointers from other kinds reference that pointer's value meant be interpreted memory address which rather low-level concept references serve level indirection pointer's value determines which memory address that which datum be used calculation because indirection fundamental aspect algorithms pointers are often expressed fundamental data type programming languages statically strongly typed programming languages type pointer determines type datum which pointer points use data structures when setting up data structures like lists queues trees necessary have pointers help manage how structure implemented controlled typical examples pointers are start pointers end pointers stack pointers these pointers can either be absolute actual physical address virtual address virtual memory relative offset from absolute start address base that typically uses fewer bits than full address but will usually require one additional arithmetic operation resolve relative addresses are form manual memory segmentation share many its advantages disadvantages two-byte offset containing 16-bit unsigned integer can be used provide relative addressing for up kilobytes data structure this can easily be extended 128k 256k 512k if address pointed forced be aligned on half-word word double-word boundary but requiring additional shift left bitwise operation—by bits—in order adjust offset by factor before its addition base address generally though such schemes are lot trouble for convenience programmer absolute addresses underlying that flat address space preferred one byte offset such hexadecimal ascii value character eg x'29' can be used point alternative integer value index array eg x'01' this way characters can be very efficiently translated from 'raw data' usable sequential index then absolute address without lookup table use control tables control tables that are used control program flow usually make extensive use pointers pointers usually embedded table entry may for instance be used hold entry points subroutines be executed based on certain conditions defined same table entry pointers can however be simply indexes other separate but associated tables comprising array actual addresses addresses themselves depending upon programming language constructs available they can also be used point earlier table entries loop processing forward skip some table entries switch early exit from loop for this latter purpose pointer may simply be table entry number itself can be transformed into actual address by simple arithmetic architectural roots pointers are very thin abstraction on top addressing capabilities provided by most modern architectures simplest scheme address numeric index assigned each unit memory system where unit typically either byte word – depending on whether architecture byte-addressable word-addressable – effectively transforming all memory into very large array system would then also provide operation retrieve value stored memory unit at given address usually utilizing machine's general purpose registers usual case pointer large enough hold more addresses than there are units memory system this introduces possibility that program may attempt access address which corresponds no unit memory either because not enough memory installed ie beyond range available memory architecture does not support such addresses first case may certain platforms such intel x86 architecture be called segmentation fault segfault second case possible current implementation amd64 where pointers are bit long addresses only extend bits there pointers must conform certain rules canonical addresses so if non-canonical pointer de referenced processor raises general protection fault on other hand some systems have more units memory than there are addresses this case more complex scheme such memory segmentation paging employed use different parts memory at different times last incarnations x86 architecture support up bits physical memory addresses which were mapped 32-bit linear address space through pae paging mechanism thus only 1/16 possible total memory may be accessed at time another example same computer family was 16-bit protected mode processor which though supporting only mb physical memory could access up gb virtual memory but combination 16-bit address segment registers made accessing more than kb one data structure cumbersome order provide consistent interface some architectures provide memory-mapped i/o which allows some addresses refer units memory while others refer device registers other devices computer there are analogous concepts such file offsets array indices remote object references that serve some same purposes addresses for other types objects uses pointers are directly supported without restrictions languages such pl/i c c++ pascal implicitly most assembly languages they are primarily used for constructing references which turn are fundamental constructing nearly all data structures well passing data between different parts program functional programming languages that rely heavily on lists pointers references are managed abstractly by language using internal constructs like cons when dealing with arrays critical lookup operation typically involves stage called address calculation which involves constructing pointer desired data element array other data structures such linked lists pointers are used references explicitly tie one piece structure another pointers are used pass parameters by reference this useful if programmer wants function's modifications parameter be visible function's caller this also useful for returning multiple values from function pointers can also be used allocate deallocate dynamic variables arrays memory since variable will often become redundant after has served its purpose waste memory keep therefore good practice deallocate using original pointer reference when no longer needed failure do so may result memory leak where available free memory gradually severe cases rapidly diminishes because accumulation numerous redundant memory blocks c pointers basic syntax define pointer int ptr this declares ptr identifier object following type pointer that points object type int this usually stated more succinctly ptr pointer int because c language does not specify implicit initialization for objects automatic storage duration care should often be taken ensure that address which ptr points valid this why sometimes suggested that pointer be explicitly initialized null pointer value which traditionally specified c with standardized macro null int ptr = null dereferencing null pointer c produces undefined behavior which could be catastrophic however most implementations simply halt execution program question usually with segmentation fault however initializing pointers unnecessarily could hinder program analysis thereby hiding bugs any case once pointer has been declared next logical step for point at something int = int ptr = null ptr = &a this assigns value address ptr for example if stored at memory location 0x8130 then value ptr will be 0x8130 after assignment dereference pointer asterisk used again ptr = this means take contents ptr which 0x8130 locate that address memory set its value if later accessed again its new value will be this example may be clearer if memory examined directly assume that located at address 0x8130 memory ptr at 0x8134 also assume this 32-bit machine such that int 32-bits wide following what would be memory after following code snippet executed int = int ptr = null address contents 0x8130 0x00000005 0x8134 0x00000000 null pointer shown here 0x00000000 by assigning address ptr ptr = &a yields following memory values address contents 0x8130 0x00000005 0x8134 0x00008130 then by dereferencing ptr by coding ptr = computer will take contents ptr which 0x8130 'locate' that address assign that location yielding following memory address contents 0x8130 0x00000008 0x8134 0x00008130 clearly accessing will yield value because previous instruction modified contents by way pointer ptr c arrays c array indexing formally defined terms pointer arithmetic that language specification requires that array be equivalent array + i thus c arrays can be thought pointers consecutive areas memory with no gaps syntax for accessing arrays identical for that which can be used dereference pointers for example array array can be declared used following manner int array / declares contiguous integers / int ptr = array / arrays can be used pointers / ptr = / pointers can be indexed with array syntax / array + = / arrays can be dereferenced with pointer syntax / + array = / pointer addition commutative / = / subscript operator commutative / this allocates block five integers names block array which acts pointer block another common use pointers point dynamically allocated memory from malloc which returns consecutive block memory no less than requested size that can be used array while most operators on arrays pointers are equivalent important note that sizeof operator will differ this example sizeofarray will evaluate 5sizeofint size array while sizeofptr will evaluate sizeofint size pointer itself default values array can be declared like int array = {2 5} if you assume that array located memory starting at address 0x1000 on 32-bit little-endian machine then memory will contain following values are hexadecimal like addresses 100c represented here are five integers these five integers occupy bits bytes each with least-significant byte stored first this little-endian cpu architecture are stored consecutively starting at address 0x1000 syntax for c with pointers array means 0x1000 array + means 0x1004 note that really means add one times size int bytes not literally plus one array means dereference contents array considering contents memory address 0x1000 look up value at that location 0x0002 array means element number i 0-based array which translated into array + i last example how access contents array breaking down array + i memory location i + 1th element array array + i takes that memory address dereferences access value c linked list below example definition linked list c / empty linked list represented by null some other sentinel value / define emptylist null struct link { void data / data this link / struct link next / next link emptylist if there none / } note that this pointer-recursive definition essentially same reference-recursive definition from haskell programming language data link = nil | cons link nil empty list cons link cons cell type with another link also type definition with references however type-checked does not use potentially confusing signal values for this reason data structures c are usually dealt with via wrapper functions which are carefully checked for correctness pass-by-address using pointers pointers can be used pass variables by their address allowing their value be changed for example consider following c code / copy int n can be changed within function without affecting calling code / void passbyvalueint n { n = } / pointer m passed instead no copy m itself created / void passbyaddressint m { m = } int mainvoid { int x = / pass copy x's value argument / passbyvaluex // value was changed inside function but x still from here on / pass x's address argument / passbyaddress&x // x was actually changed by function now equal here return } dynamic memory allocation some programs required memory depends on what user may enter such cases programmer needs allocate memory dynamically this done by allocating memory at heap rather than on stack where variables usually are stored variables can also be stored cpu registers but that's another matter dynamic memory allocation can only be made through pointers names like with common variables can't be given pointers are used store manage addresses dynamically allocated blocks memory such blocks are used store data objects arrays objects most structured object-oriented languages provide area memory called heap free store from which objects are dynamically allocated example c code below illustrates how structure objects are dynamically allocated referenced standard c library provides function malloc for allocating memory blocks from heap takes size object allocate parameter returns pointer newly allocated block memory suitable for storing object returns null pointer if allocation failed / parts inventory item / struct item { int id / part number / char name / part name / float cost / cost / } / allocate initialize new item object / struct item makeitemconst char name { struct item item / allocate block memory for new item object / item = struct item mallocsizeofstruct item if item == null return null / initialize members new item / memsetitem sizeofstruct item item->id = item->name = null item->cost = / save copy name new item / item->name = char mallocstrlenname + if item->name == null { freeitem return null } strcpyitem->name name / return newly created item object / return item } code below illustrates how memory objects are dynamically deallocated ie returned heap free store standard c library provides function free for deallocating previously allocated memory block returning back heap / deallocate item object / void destroyitemstruct item item { / check for null object pointer / if item == null return / deallocate name string saved within item / if item->name = null { freeitem->name item->name = null } / deallocate item object itself / freeitem } memory-mapped hardware on some computing architectures pointers can be used directly manipulate memory memory-mapped devices assigning addresses pointers invaluable tool when programming microcontrollers below simple example declaring pointer type int initialising hexadecimal address this example constant 0x7fff int hardwareaddress = int 0x7fff mid 80s using bios access video capabilities pcs was slow applications that were display-intensive typically used access cga video memory directly by casting hexadecimal constant 0xb8000 pointer array unsigned 16-bit int values each value consisted ascii code low byte colour high byte thus put letter 'a' at row column bright white on blue one would write code like following define vid unsigned short 0xb8000 void foovoid { vid = 0x1f00 | 'a' } typed pointers casting many languages pointers have additional restriction that object they point has specific type for example pointer may be declared point integer language will then attempt prevent programmer from pointing objects which are not integers such floating-point numbers eliminating some errors for example c int money char bags money would be integer pointer bags would be char pointer following would yield compiler warning assignment from incompatible pointer type under gcc bags = money because money bags were declared with different types suppress compiler warning must be made explicit that you do indeed wish make assignment by typecasting bags = char money which says cast integer pointer money char pointer assign bags draft c standard requires that casting pointer derived from one type one another type should maintain alignment correctness for both types pointers par char externalbuffer = abcdef int internaldata internaldata = int externalbuffer // undefined behaviour if resulting pointer // not correctly aligned languages that allow pointer arithmetic arithmetic on pointers takes into account size type for example adding integer number pointer produces another pointer that points address that higher by that number times size type this allows us easily compute address elements array given type was shown c arrays example above when pointer one type cast another type different size programmer should expect that pointer arithmetic will be calculated differently c for example if money array starts at 0x2000 sizeofint bytes whereas sizeofchar byte then money + will point 0x2004 but bags + will point 0x2001 other risks casting include loss data when wide data written narrow locations eg bags = unexpected results when bit-shifting values comparison problems especially with signed vs unsigned values although impossible general determine at compile-time which casts are safe some languages store run-time type information which can be used confirm that these dangerous casts are valid at runtime other languages merely accept conservative approximation safe casts none at all making pointers safer pointer allows program attempt access object that may not be defined pointers can be origin variety programming errors however usefulness pointers so great that can be difficult perform programming tasks without them consequently many languages have created constructs designed provide some useful features pointers without some their pitfalls also sometimes referred pointer hazards this context pointers that directly address memory used this article are referred raw pointers by contrast with smart pointers other variants one major problem with pointers that long they can be directly manipulated number they can be made point unused addresses data which being used for other purposes many languages including most functional programming languages recent imperative languages like java replace pointers with more opaque type reference typically referred simply reference which can only be used refer objects not manipulated numbers preventing this type error array indexing handled special case pointer which does not have any address assigned called wild pointer any attempt use such uninitialized pointers can cause unexpected behavior either because initial value not valid address because using may damage other parts program result often segmentation fault storage violation wild branch if used function pointer branch address systems with explicit memory allocation possible create dangling pointer by deallocating memory region points into this type pointer dangerous subtle because deallocated memory region may contain same data did before was deallocated but may be then reallocated overwritten by unrelated code unknown earlier code languages with garbage collection prevent this type error because deallocation performed automatically when there are no more references scope some languages like c++ support smart pointers which use simple form reference counting help track allocation dynamic memory addition acting reference absence reference cycles where object refers itself indirectly through sequence smart pointers these eliminate possibility dangling pointers memory leaks delphi strings support reference counting natively rust programming language introduces borrow checker pointer lifetimes optimisation based around optional types for null pointers eliminate pointer bugs without resorting garbage collector null pointer main article null pointer null pointer has value reserved for indicating that pointer does not refer valid object null pointers are routinely used represent conditions such end list unknown length failure perform some action this use null pointers can be compared nullable types nothing value option type autorelative pointer autorelative pointer pointer whose value interpreted offset from address pointer itself thus if data structure has autorelative pointer member that points some portion data structure itself then data structure may be relocated memory without having update value auto relative pointer cited patent also uses term self-relative pointer mean same thing however meaning that term has been used other ways mean offset from address structure rather than from address pointer itself mean pointer containing its own address which can be useful for reconstructing any arbitrary region memory collection data structures that point each other based pointer based pointer pointer whose value offset from value another pointer this can be used store load blocks data assigning address beginning block base pointer multiple indirection some languages pointer can reference another pointer requiring multiple dereference operations get original value while each level indirection may add performance cost sometimes necessary order provide correct behavior for complex data structures for example c typical define linked list terms element that contains pointer next element list struct element { struct element next int value } struct element head = null this implementation uses pointer first element list surrogate for entire list if new value added beginning list head has be changed point new element since c arguments are always passed by value using double indirection allows insertion be implemented correctly has desirable side-effect eliminating special case code deal with insertions at front list // given sorted list at head insert element item at first // location where all earlier elements have lesser equal value void insertstruct element head struct element item { struct element p // p points pointer element for p = head p = null p = &p->next { if item->value value break } item->next = p p = item } // caller does this insert&head item this case if value item less than that head caller's head properly updated address new item basic example argv argument main function c c++ which given prototype char argv—this because variable argv itself pointer array strings array arrays so argv pointer 0th string by convention name program argv 0th character 0th string function pointer some languages pointer can reference executable code ie can point function method procedure function pointer will store address function be invoked while this facility can be used call functions dynamically often favorite technique virus other malicious software writers int sumint n1 int n2 { // function with two integer parameters returning integer value return n1 + n2 } int mainvoid { int b x y int fpint int // function pointer which can point function like sum fp = &sum // fp now points function sum x = fpa b // calls function sum with arguments b y = suma b // calls function sum with arguments b } dangling pointer main article dangling pointer dangling pointer pointer that does not point valid object consequently may make program crash behave oddly pascal c programming languages pointers that are not specifically initialized may point unpredictable addresses memory following example code shows dangling pointer int funcvoid { char p1 = mallocsizeofchar / undefined value some place on heap / char p2 / dangling uninitialized pointer / p1 = 'a' / this ok assuming malloc has not returned null / p2 = 'b' / this invokes undefined behavior / } here p2 may point anywhere memory so performing assignment p2 = 'b' can corrupt unknown area memory trigger segmentation fault back pointer doubly linked lists tree structures back pointer held on element 'points back' item referring current element these are useful for navigation manipulation at expense greater memory use pointer declaration syntax overview these pointer declarations cover most variants pointer declarations course possible have triple pointers but main principles behind triple pointer already exists double pointer char cff / array arrays chars / char cfp / array pointers chars / char cpp / pointer pointer char double pointer / char cpf / pointer arrays chars / char cpf / function which returns pointer chars / char cfp / pointer function which returns char / char cfpf / function which returns pointer array chars / char cpff / array pointers functions which return char / have higher priority than wild branch where pointer used address entry point program start function which doesn't return anything also either uninitialized corrupted if call jump nevertheless made this address wild branch said have occurred consequences are usually unpredictable error may present itself several different ways depending upon whether not pointer valid address whether not there coincidentally valid instruction opcode at that address detection wild branch can present one most difficult frustrating debugging exercises since much evidence may already have been destroyed beforehand by execution one more inappropriate instructions at branch location if available instruction set simulator can usually not only detect wild branch before takes effect but also provide complete partial trace its history simulation using array index possible simulate pointer behavior using index normally one-dimensional array primarily for languages which do not support pointers explicitly but do support arrays array can be thought processed if were entire memory range within scope particular array any index can be thought equivalent general purpose register assembly language that points individual bytes but whose actual value relative start array not its absolute address memory assuming array say contiguous megabyte character data structure individual bytes string contiguous bytes within array can be directly addressed manipulated using name array with bit unsigned integer simulated pointer this quite similar c arrays example shown above pointer arithmetic can be simulated by adding subtracting from index with minimal additional overhead compared genuine pointer arithmetic even theoretically possible using above technique together with suitable instruction set simulator simulate any machine code intermediate byte code any processor/language another language that does not support pointers at all for example java / javascript achieve this binary code can initially be loaded into contiguous bytes array for simulator read interpret action entirely within memory contained same array if necessary completely avoid buffer overflow problems bounds checking can usually be actioned for compiler if not hand coded simulator support various programming languages ada ada strongly typed language where all pointers are typed only safe type conversions are permitted all pointers are by default initialized null any attempt access data through null pointer causes exception be raised pointers ada are called access types ada did not permit arithmetic on access types although many compiler vendors provided for non-standard feature but ada supports “safe” arithmetic on access types via package systemstorageelements basic several old versions basic for windows platform had support for strptr return address string for varptr return address variable visual basic also had support for objptr return address object interface for addressof operator return address function types all these are integers but their values are equivalent those held by pointer types newer dialects basic such freebasic blitzmax have exhaustive pointer implementations however freebasic arithmetic on any pointers equivalent c's void are treated though any pointer was byte width any pointers cannot be dereferenced c also casting between any any other type's pointers will not generate any warnings dim integer f = dim any ptr g = @f dim integer ptr i = g asserti = assert g + = @f + c c++ c c++ pointers are variables that store addresses can be null each pointer has type points but one can freely cast between pointer types but not between function pointer non-function pointer type special pointer type called “void pointer” allows pointing any non-function variable type but limited by fact that cannot be dereferenced directly shall be cast address itself can often be directly manipulated by casting pointer from integral type sufficient size though results are implementation-defined may indeed cause undefined behavior while earlier c standards did not have integral type that was guaranteed be large enough c99 specifies uintptrt typedef name defined but implementation need not provide c++ fully supports c pointers c typecasting also supports new group typecasting operators help catch some unintended dangerous casts at compile-time since c++11 c++ standard library also provides smart pointers uniqueptr sharedptr weakptr which can be used some situations safe alternative primitive c pointers c++ also supports another form reference quite different from pointer called simply reference reference type pointer arithmetic that ability modify pointer's target address with arithmetic operations well magnitude comparisons restricted by language standard remain within bounds single array object just after will otherwise invoke undefined behavior adding subtracting from pointer moves by multiple size datatype points for example adding pointer 4-byte integer values will increment pointer by this has effect incrementing pointer point at next element contiguous array integers—which often intended result pointer arithmetic cannot be performed on void pointers because void type has no size thus pointed address can not be added although gcc other compilers will perform byte arithmetic on void non-standard extension treating if were char pointer arithmetic provides programmer with single way dealing with different types adding subtracting number elements required instead actual offset bytes though char pointer char being defined always having size one byte allows element offset pointer arithmetic practice be equal byte offset particular c definition explicitly declares that syntax which n-th element array equivalent + n which content element pointed by + n this implies that n equivalent one can write eg equally well access fourth element array while powerful pointer arithmetic can be source computer bugs tends confuse novice programmers forcing them into different contexts expression can be ordinary arithmetic one pointer arithmetic one sometimes easy mistake one for other response this many modern high-level computer languages for example java do not permit direct access memory using addresses also safe c dialect cyclone addresses many issues with pointers see c programming language for more discussion void pointer void supported ansi c c++ generic pointer type pointer void can store address any non-function data type c implicitly converted any other pointer type on assignment but must be explicitly cast if dereferenced inline k&r c used char for “type-agnostic pointer” purpose before ansi c int x = void p1 = &x int p2 = p1 // void implicitly converted int valid c but not c++ int = p2 int b = intp1 // when dereferencing inline there no implicit conversion c++ does not allow implicit conversion void other pointer types even assignments this was design decision avoid careless even unintended casts though most compilers only output warnings not errors when encountering other ill casts int x = void p1 = &x int p2 = p1 // this fails c++ there no implicit conversion from void int p3 = intp1 // c-style cast int p4 = staticcastp1 // c++ cast c++ there no void& reference void complement void pointer void because references behave like aliases variables they point there can never be variable whose type void c c programming language pointers are supported only under certain conditions any block code including pointers must be marked with unsafe keyword such blocks usually require higher security permissions than pointerless code be allowed run syntax essentially same c++ address pointed can be either managed unmanaged memory however pointers managed memory any pointer managed object must be declared using fixed keyword which prevents garbage collector from moving pointed object part memory management while pointer scope thus keeping pointer address valid exception this from using intptr structure which safe managed equivalent int does not require unsafe code this type often returned when using methods from systemruntimeinteropservices for example // get bytes memory from process's unmanaged memory intptr pointer = systemruntimeinteropservicesmarshalallochglobal16 // do something with allocated memory // free allocated memory systemruntimeinteropservicesmarshalfreehglobalpointer net framework includes many classes methods system systemruntimeinteropservices namespaces such marshal class which convert net types for example systemstring from many unmanaged types pointers for example lpwstr void allow communication with unmanaged code cobol cobol programming language supports pointers variables primitive group record data objects declared within linkage section program are inherently pointer-based where only memory allocated within program space for address data item typically single memory word program source code these data items are used just like any other working-storage variable but their contents are implicitly accessed indirectly through their linkage pointers memory space for each pointed-to data object typically allocated dynamically using external call statements via embedded extended language constructs such exec cics exec sql statements extended versions cobol also provide pointer variables declared with usage pointer clauses values such pointer variables are established modified using set set address statements some extended versions cobol also provide procedure-pointer variables which are capable storing addresses executable code pl/i pl/i language provides full support for pointers all data types including pointers structures recursion multitasking string handling extensive built-in functions pl/i was quite leap forward compared programming languages its time d d programming language derivative c c++ which fully supports c pointers c typecasting eiffel eiffel object-oriented language employs value reference semantics without need for pointer arithmetics nevertheless pointer classes are provided they offer pointer arithmetics typecasting explicit memory management interfacing with non-eiffel software other features fortran fortran-90 introduced strongly typed pointer capability fortran pointers contain more than just simple memory address they also encapsulate lower upper bounds array dimensions strides for example support arbitrary array sections other metadata association operator => used associate pointer variable which has target attribute fortran-90 allocate statement may also be used associate pointer block memory for example following code might be used define create linked list structure type reallistt real sampledata100 type reallistt pointer next => null end type type reallistt target myreallist type reallistt pointer reallisttemp reallisttemp => myreallist do read 1iostat=ioerr reallisttemp%sampledata if ioerr /= exit allocate reallisttemp%next reallisttemp => reallisttemp%next end do fortran-2003 adds support for procedure pointers also part c interoperability feature fortran-2003 supports intrinsic functions for converting c-style pointers into fortran pointers back go go has pointers its declaration syntax equivalent that c but written other way around ending with type unlike c go has garbage collection disallows pointer arithmetic reference types like c++ do not exist some built-in types like maps channels are boxed ie internally they are pointers mutable structures are initialized using make function different than reference types approach unified syntax between pointers non-pointers arrow -> operator has been dropped—it possible use dot operator directly on pointer data type access field method dereferenced value if dot operator were used on underlying data type this however only works with level indirection java unlike c c++ pascal there no explicit representation pointers java instead more complex data structures like objects arrays are implemented using references language does not provide any explicit pointer manipulation operators still possible for code attempt dereference null reference null pointer however which results run-time exception being thrown space occupied by unreferenced memory objects recovered automatically by garbage collection at run-time modula-2 pointers are implemented very much pascal are var parameters procedure calls modula-2 even more strongly typed than pascal with fewer ways escape type system some variants modula-2 such modula-3 include garbage collection for instance when comes computing time one must carry remainder past oberon much with modula-2 pointers are available there are still fewer ways evade type system so oberon its variants are still safer with respect pointers than modula-2 its variants with modula-3 garbage collection part language specification pascal unlike many languages that feature pointers standard iso pascal only allows pointers reference dynamically created variables that are anonymous does not allow them reference standard static local variables does not have pointer arithmetic pointers also must have associated type pointer one type not compatible with pointer another type eg pointer char not compatible with pointer integer this helps eliminate type security issues inherent with other pointer implementations particularly those used for pl/i c also removes some risks caused by dangling pointers but ability dynamically let go referenced space by using dispose standard procedure which has same effect free library function found c means that risk dangling pointers has not been entirely eliminated however some commercial open source pascal derivatives compiler implementations —like free pascal turbo pascal object pascal embarcadero delphi— pointer allowed reference standard static local variables can be cast from one pointer type another moreover pointer arithmetic unrestricted adding subtracting from pointer moves by that number bytes either direction but using inc dec standard procedures with moves pointer by size data type declared point untyped pointer also provided under name pointer which compatible with other pointer types perl perl programming language supports pointers although rarely used form pack unpack functions these are intended only for simple interactions with compiled os libraries all other cases perl uses references which are typed do not allow any form pointer arithmetic they are used construct complex data structures see also address constant bounded pointer buffer overflow function pointer hazard pointer opaque pointer pointer swizzling reference computer science static program analysis storage violation tagged pointer variable computer science references donald knuth structured programming with go statements pdf computing surveys 261–301 doi101145/356635356640 archived from original pdf on august milestones computer science information technology ieee computer society awards list iso/iec clause paragraph iso/iec clause paragraph iso/iec clause paragraph null which expands implementation-defined null pointer constant iso/iec clause paragraph footnote if invalid value has been assigned pointer behavior unary operator undefined among invalid values for dereferencing pointer by unary operator are null pointer b plauger p j brodie jim ansi iso standard c programmer's reference redmond wa microsoft press pp isbn 1-55615-359-7 array type does not contain additional holes because all other types pack tightly when composed into arrays wg14 n1124 c – approved standards iso/iec – programming languages – c us patent steiner robert c broomfield co pointers that are relative their own present locations issued assigned avaya technology corp basking ridge nj us patent nagy michael tampa fl system method for database save restore using self-pointers issued assigned ibm armonk ny based pointers ulf bilting jan skansholm vägen till c road c third edition page isbn 91-44-01468-6 nick parlante stanford computer science education library pp 9–10 iso pascal standard unofficial copy section pointer-types subsequent j welsh w j sneeringer c r hoare ambiguities insecurities pascal software practice experience pp 685–696 free pascal language reference guide section pointers // making references perl references nested data structures external links wikimedia commons has media related pointers computing wikiversity has learning materials about pointers wikibook c programming has page on topic pointers tool convert pointer declarations plain english thecgurucom beginner level guide describing pointers plain english pointers memory introduction pointers – stanford computer science education library terse list minimum length source codes that dereference null pointer several different programming languages c book – containing pointer examples ansi c joint technical committee iso/iec jtc subcommittee sc working group wg international standard iso/iec pdf committee draft cs1 maint multiple names authors list link v t e data types uninterpreted bit byte trit tryte word bit array numeric arbitrary-precision bignum complex decimal fixed point floating point o double precision o extended precision o half precision o long double o minifloat o octuple precision o quadruple precision o single precision integer o signedness interval rational text character string o null-terminated pointer address o physical o virtual reference composite algebraic data type o generalized array associative array class dependent equality inductive list object o metaobject option type product record set union o tagged other boolean bottom type collection enumerated type exception function type opaque data type recursive data type semaphore stream top type type class unit type void related topics abstract data type data structure generic kind o metaclass parametric polymorphism primitive data type protocol o interface subtyping type constructor type conversion type system see also platform-dependent independent units information authority control gnd 4285887-2 retrieved from https//enwikipediaorg/w/indexphptitle=pointercomputerprogramming&oldid=750596735 categories data types primitive types american inventions hidden categories pages using isbn magic links all articles with unsourced statements articles with unsourced statements from may articles with unsourced statements from july articles with unsourced statements from september articles with unsourced statements from february commons category with local link same on wikidata cs1 maint multiple names authors list wikipedia articles with gnd identifiers articles with example c code navigation menu personal tools not logged talk contributions create account log namespaces article talk variants views read edit view history more search navigation main page contents featured content current events random article donate wikipedia wikipedia store interaction help about wikipedia community portal recent changes contact page tools what links here related changes upload file special pages permanent link page information wikidata item cite this page print/export create book download pdf printable version other projects wikimedia commons languages العربية български català čeština deutsch eesti ελληνικά español فارسی français 한국어 हिन्दी íslenska italiano עברית қазақша кыргызча magyar മലയാളം bahasa melayu nederlands 日本語 polski português русский simple english slovenčina српски / srpski suomi svenska தமிழ் türkçe українська 中文 edit links this page was last modified on november at text available under creative commons attribution-sharealike license additional terms may apply by using this site you agree terms use privacy policy wikipedia® registered trademark wikimedia foundation inc non-profit organization privacy policy about wikipedia disclaimers contact wikipedia developers cookie statement mobile view 