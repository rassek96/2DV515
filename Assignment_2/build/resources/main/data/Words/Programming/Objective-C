objective-c from wikipedia free encyclopedia jump navigation search objective-c paradigm reflective class-based object-oriented designed by tom love brad cox first appeared years ago stable release typing discipline static dynamic weak os cross-platform filename extensions h m mm c website developerapplecom/library/mac/navigation major implementations clang gcc influenced by c smalltalk influenced groovy java nu objective-j tom swift objective-c programming at wikibooks objective-c general-purpose object-oriented programming language that adds smalltalk-style messaging c programming language was main programming language used by apple for os x ios operating systems their respective application programming interfaces apis cocoa cocoa touch prior introduction swift programming language objective-c was originally developed early 1980s was selected main language used by next for its nextstep operating system from which os x ios are derived portable objective-c programs that do not use cocoa cocoa touch libraries those using parts that may be ported reimplemented for other systems can also be compiled for any system supported by gnu compiler collection gcc clang objective-c source code 'implementation' program files usually have m filename extensions while objective-c 'header/interface' files have h extensions same c header files objective-c++ files are denoted with mm file extension contents history o popularization through next o apple development swift syntax o messages o interfaces implementations + interface + implementation + instantiation o protocols o dynamic typing o forwarding + example + notes o categories + example usage categories + notes o posing o import other features language variants o objective-c++ o objective-c + garbage collection + properties + non-fragile instance variables + fast enumeration + class extensions + implications for cocoa development o blocks o modern objective-c + automatic reference counting + literals + subscripting o modern objective-c syntax o portable object compiler o geos objective-c o clang library use analysis language o memory management o philosophical differences between objective-c c++ see also references further reading external links history objective-c was created primarily by brad cox tom love early 1980s at their company stepstone both had been introduced smalltalk while at itt corporation's programming technology center earliest work on objective-c traces back around that time cox was intrigued by problems true reusability software design programming he realized that language like smalltalk would be invaluable building development environments for system developers at itt however he tom love also recognized that backward compatibility with c was critically important itt's telecom engineering milieu cox began writing pre-processor for c add some abilities smalltalk he soon had working implementation object-oriented extension c language which he called oopc for object-oriented pre-compiler love was hired by schlumberger research had opportunity acquire first commercial copy smalltalk-80 which further influenced development their brainchild order demonstrate that real progress could be made cox showed that making interchangeable software components really needed only few practical changes existing tools specifically they needed support objects flexible manner come supplied with usable set libraries allow for code any resources needed by code be bundled into one cross-platform format love cox eventually formed new venture productivity products international ppi commercialize their product which coupled objective-c compiler with class libraries cox published main description objective-c its original form book object-oriented programming evolutionary approach although he was careful point out that there more problem reusability than just language objective-c often found itself compared feature for feature with other languages popularization through next next licensed objective-c from stepstone new name ppi owner objective-c trademark extended gcc compiler support objective-c next developed appkit foundation kit libraries on which nextstep user interface interface builder were based while next workstations failed make great impact marketplace tools were widely lauded industry this led next drop hardware production focus on software tools selling nextstep openstep platform for custom programming order circumvent terms gpl next had originally intended ship objective-c frontend separately allowing user link with gcc produce compiler executable after being initially accepted by richard m stallman this plan was rejected after stallman consulted with gnu's lawyers next agreed make objective-c part gcc work extend gcc was led by steve naroff who joined next from stepstone compiler changes were made available per gpl license terms but runtime libraries were not rendering open source contribution unusable general public this led other parties developing such runtime libraries under open source license later steve naroff was also principal contributor work at apple build objective-c frontend clang gnu project started work on its free software implementation cocoa named gnustep based on openstep standard dennis glatting wrote first gnu objective-c runtime gnu objective-c runtime which has been use since one developed by kresten krab thorup when he was university student denmark thorup also worked at next from apple development swift after acquiring next apple computer used openstep its new operating system os x this included objective-c next's objective-c based developer tool project builder its interface design tool interface builder both now merged into one xcode application most apple's current cocoa api based on openstep interface objects most significant objective-c environment being used for active development at wwdc apple introduced new language swift which was characterized objective-c without c syntax objective-c thin layer atop c strict superset c meaning that possible compile any c program with objective-c compiler freely include c language code within objective-c class objective-c derives its object syntax from smalltalk all syntax for non-object-oriented operations including primitive variables pre-processing expressions function declarations function calls are identical those c while syntax for object-oriented features implementation smalltalk-style messaging messages objective-c model object-oriented programming based on message passing object instances objective-c one does not call method one sends message this unlike simula-style programming model used by c++ difference between these two concepts how code referenced by method message name executed simula-style language method name most cases bound section code target class by compiler smalltalk objective-c target message resolved at runtime with receiving object itself interpreting message method identified by selector sel — nul-terminated string representing its name — resolved c method pointer implementing imp consequence this that message-passing system has no type checking object which message directed — receiver — not guaranteed respond message if does not raises exception sending message method object pointed by pointer obj would require following code c++ obj->methodargument objective-c this written follows both styles programming have their strengths weaknesses object-oriented programming simula c++ style allows multiple inheritance faster execution by using compile-time binding whenever possible but does not support dynamic binding by default also forces all methods have corresponding implementation unless they are abstract smalltalk-style programming used objective-c allows messages go unimplemented with method resolved its implementation at runtime for example message may be sent collection objects which only some will be expected respond without fear producing runtime errors message passing also does not require that object be defined at compile time implementation still required for method be called derived object see dynamic typing section below for more advantages dynamic late binding interfaces implementations objective-c requires that interface implementation class be separately declared code blocks by convention developers place interface header file implementation code file header files normally suffixed h are similar c header files while implementation method files normally suffixed m can be very similar c code files interface other programming languages this called class declaration interface class usually defined header file common convention name header file after name class eg ballh would contain interface for class ball interface declaration takes form @interface classname superclassname { // instance variables } + classmethod1 + returntypeclassmethod2 + returntypeclassmethod3param1typeparam1varname - returntypeinstancemethod1with1parameterparam1typeparam1varname - returntypeinstancemethod2with2parametersparam1typeparam1varname param2callnameparam2typeparam2varname @end above plus signs denote class methods methods that can be called on class itself not on instance minus signs denote instance methods which can only be called on particular instance class class methods also have no access instance variables code above roughly equivalent following c++ interface class classname public superclassname { protected // instance variables public // class static functions static void classmethod1 static returntype classmethod2 static returntype classmethod3param1type param1varname // instance member functions returntype instancemethod1with1parameter param1type param1varname returntype instancemethod2with2parameters param1type param1varname param2type param2varname=default } note that instancemethod2with2parametersparam2callname demonstrates interleaving selector segments with argument expressions for which there no direct equivalent c/c++ return types can be any standard c type pointer generic objective-c object pointer specific type object such nsarray nsimage nsstring pointer class which method belongs instancetype default return type generic objective-c type id method arguments begin with name labeling argument that part method name followed by colon followed by expected argument type parentheses argument name label can be omitted - voidsetrangestartintstart endintend - voidimportdocumentwithnamensstring name withspecifiedpreferences preferences prefs beforepageintinsertpage implementation interface only declares class interface not methods themselves actual code written implementation file implementation method files normally have file extension m which originally signified messages @implementation classname + returntypeclassmethod { // implementation } - returntypeinstancemethod { // implementation } @end methods are written using their interface declarations comparing objective-c c - intmethodinti { return } int function int i { return squarerooti } syntax allows pseudo-naming arguments - intchangecolortoredfloatred greenfloatgreen bluefloatblue internal representations method vary between different implementations objective-c if mycolor class color instance method -changecolortoredgreenblue might be internally labeled icolorchangecolortoredgreenblue i refer instance method with class then method names appended colons changed underscores order parameters part method name cannot be changed suit coding style expression with true named parameters however internal names function are rarely used directly generally messages are converted function calls defined objective-c runtime library not necessarily known at link time which method will be called because class receiver object being sent message need not be known until runtime instantiation once objective-c class written can be instantiated this done by first allocating uninitialized instance class object then by initializing object not fully functional until both steps have been completed these steps should be accomplished with one line code so that there never allocated object that hasn't undergone initialization because unwise keep intermediate result since -init can return different object than that on which called instantiation with default no-parameter initializer myobject o = init] instantiation with custom initializer myobject o = initwithstringmystring] case where no custom initialization being performed new method can often be used place alloc-init messages myobject o = also some classes implement class method initializers like +new they combine +alloc -init but unlike +new they return autoreleased instance some class method initializers take parameters myobject o = myobject o2 = alloc message allocates enough memory hold all instance variables for object sets all instance variables zero values turns memory into instance class at no point during initialization memory instance superclass init message performs set-up instance upon creation init method often written follows - idinit { self = if self { // perform initialization object here } return self } above example notice id return type this type stands for pointer any object objective-c see dynamic typing section initializer pattern used assure that object properly initialized by its superclass before init method performs its initialization performs following actions self = sends superclass instance init message assigns result self pointer current object if self checks if returned object pointer valid before performing any initialization return self returns value self caller non-valid object pointer has value nil conditional statements like if treat nil like null pointer so initialization code will not be executed if returned nil if there error initialization init method should perform any necessary cleanup including sending release message self return nil indicate that initialization failed any checking for such errors must only be performed after having called superclass initialization ensure that destroying object will be done correctly if class has more than one initialization method only one them designated initializer needs follow this pattern others should call designated initializer instead superclass initializer protocols other programming languages these are called interfaces objective-c was extended at next introduce concept multiple inheritance specification but not implementation through introduction protocols this pattern achievable either abstract multiple inherited base class c++ interface java c objective-c makes use ad hoc protocols called informal protocols compiler-enforced protocols called formal protocols informal protocol list methods that class can opt implement specified documentation since has no presence language informal protocols are implemented category see below on nsobject often include optional methods which if implemented can change behavior class for example text field class might have delegate that implements informal protocol with optional method for performing auto-completion user-typed text text field discovers whether delegate implements that method via reflection if so calls delegate's method support auto-complete feature formal protocol similar interface java c ada list methods that any class can declare itself implement versions objective-c before required that class must implement all methods protocol declares itself adopting compiler will emit error if class does not implement every method from its declared protocols objective-c added support for marking certain methods protocol optional compiler will not enforce implementation optional methods class must be declared implement that protocol be said conform this detectable at runtime formal protocols cannot provide any implementations they simply assure callers that classes that conform protocol will provide implementations next/apple library protocols are frequently used by distributed objects system represent abilities object executing on remote system syntax @protocol nslocking - voidlock - voidunlock @end denotes that there abstract idea locking by stating class definition that protocol implemented @interface nslock nsobject // @end instances nslock claim that they will provide implementation for two instance methods dynamic typing objective-c like smalltalk can use dynamic typing object can be sent message that not specified its interface this can allow for increased flexibility allows object capture message send message different object that can respond message appropriately likewise send message on another object this behavior known message forwarding delegation see below alternatively error handler can be used case message cannot be forwarded if object does not forward message respond handle error then system will generate runtime exception if messages are sent nil null object pointer they will be silently ignored raise generic exception depending on compiler options static typing information may also optionally be added variables this information then checked at compile time following four statements increasingly specific type information provided statements are equivalent at runtime but extra information allows compiler warn programmer if passed argument does not match type specified - voidsetmyvalueidfoo above statement foo may be any class - voidsetmyvalueidfoo above statement foo may be instance any class that conforms nscopying protocol - voidsetmyvaluensnumber foo above statement foo must be instance nsnumber class - voidsetmyvaluensnumber foo above statement foo must be instance nsnumber class must conform nscopying protocol forwarding objective-c permits sending message object that may not respond rather than responding simply dropping message object can forward message object that can respond forwarding can be used simplify implementation certain design patterns such observer pattern proxy pattern objective-c runtime specifies pair methods object forwarding methods - retvaltforwardselsel argsarglisttargs // with gcc - idforwardselsel argsmarglistargs // with next/apple systems action methods - retvaltperformvselsel argsarglisttargs // with gcc - idperformvselsel argsmarglistargs // with next/apple systems object wishing implement forwarding needs only override forwarding method with new method define forwarding behavior action method performv need not be overridden this method merely performs action based on selector arguments notice sel type which type messages objective-c note openstep cocoa gnustep commonly used frameworks objective-c one does not use object class - voidforwardinvocationnsinvocation aninvocation method nsobject class used do forwarding example here example program that demonstrates basics forwarding forwarderh import @interface forwarder object { id recipient //the object we want forward message } //accessor methods - idrecipient - idsetrecipientidrecipient @end forwarderm import forwarderh @implementation forwarder - retvaltforwardselsel argsarglistt args { / check whether recipient actually responds message this may may not be desirable for example if recipient turn does not respond message might do forwarding itself / if { return } else { return } } - idsetrecipientidrecipient { recipient = return self } - id recipient { return recipient } @end recipienth import // simple recipient object @interface recipient object - idhello @end recipientm import recipienth @implementation recipient - idhello { printfrecipient says hello\n return self } @end mainm import forwarderh import recipienth int mainvoid { forwarder forwarder = recipient recipient = //set recipient / observe forwarder does not respond hello message will be forwarded all unrecognized methods will be forwarded recipient if recipient responds them written forwarder / return } notes when compiled using gcc compiler reports $ gcc -x objective-c -wno-import forwarderm recipientm mainm -lobjc mainm function `main' mainm12 warning `forwarder' does not respond `hello' $ compiler reporting point made earlier that forwarder does not respond hello messages this circumstance safe ignore warning since forwarding was implemented running program produces this output $ /aout recipient says hello categories during design objective-c one main concerns was maintainability large code bases experience from structured programming world had shown that one main ways improve code was break down into smaller pieces objective-c borrowed extended concept categories from smalltalk implementations help with this process furthermore methods within category are added class at run-time thus categories permit programmer add methods existing class without need recompile that class even have access its source code for example if system does not contain spell checker its string implementation could be added without modifying string source code methods within categories become indistinguishable from methods class when program run category has full access all instance variables within class including private variables if category declares method with same method signature existing method class category's method adopted thus categories can not only add methods class but also replace existing methods this feature can be used fix bugs other classes by rewriting their methods cause global change class's behavior within program if two categories have methods with same name not be confused with method signature undefined which category's method adopted other languages have attempted add this feature variety ways tom took objective-c system step further allowed for addition variables also other languages have used prototype-based solutions instead most notable being self c visual basicnet languages implement superficially similar functionality form extension methods but these lack access private variables class ruby several other dynamic programming languages refer technique monkey patching logtalk implements concept categories first-class entities that subsumes objective-c categories functionality logtalk categories can also be used fine-grained units composition when defining eg new classes prototypes particular logtalk category can be virtually imported by any number classes prototypes example usage categories this example builds up integer class by defining first basic class with only accessor methods implemented adding two categories arithmetic display which extend basic class while categories can access base class's private data members often good practice access these private data members through accessor methods which helps keep categories more independent from base class implementing such accessors one typical usage categories another use categories add methods base class however not regarded good practice use categories for subclass overriding also known monkey patching informal protocols are implemented category on base nsobject class by convention files containing categories that extend base classes will take name baseclass+extensionclassh integerh import @interface integer object { int integer } - int integer - id integer int integer @end integerm import integerh @implementation integer - int integer { return integer } - id integer int integer { integer = integer return self } @end integer+arithmetich import integerh @interface integer arithmetic - id add integer addend - id sub integer subtrahend @end integer+arithmeticm import integer+arithmetich @implementation integer arithmetic - id add integer addend { return + ] } - id sub integer subtrahend { return - ] } @end integer+displayh import integerh @interface integer display - id showstars - id showint @end integer+displaym import integer+displayh @implementation integer display - id showstars { int i x = for i = i name order use dot notation invoke property accessors within instance method self keyword should be used -void introducemyselfwithpropertiesboolusegetter { nslog@hi my name %@ usegetter selfname name // note getter vs ivar access } class protocol's properties may be dynamically introspected int i int propertycount = objcpropertyt propertylist = classcopypropertylist &propertycount for i = i include typedef int ^intblock intblock makecounterint start int increment { block int i = start return blockcopy { int ret = i i += increment return ret } } int mainvoid { intblock mycounter = makecounter5 printffirst call %d\n mycounter printfsecond call %d\n mycounter printfthird call %d\n mycounter / because was copied must also be released / blockreleasemycounter return } / output first call second call third call / modern objective-c automatic reference counting main article automatic reference counting automatic reference counting arc compile-time feature that eliminates need for programmers manually manage retain counts using retain release unlike garbage collection which occurs at run time arc eliminates overhead separate process managing retain counts arc manual memory management are not mutually exclusive programmers can continue use non-arc code arc-enabled projects by disabling arc for individual code files xcode can also attempt automatically upgrade project arc literals next apple obj-c runtimes have long included short-form way create new strings using literal syntax @a new string drop corefoundation constants kcfbooleantrue kcfbooleanfalse for nsnumber with boolean values using this format saves programmer from having use longer initwithstring similar methods when doing certain operations when using apple llvm compiler later arrays dictionaries numbers nsarray nsdictionary nsnumber classes can also be created using literal syntax instead methods example without literals nsarray myarray = nsdictionary mydictionary1 = nsdictionary mydictionary2 = nsnumber mynumber = nsnumber mysumnumber= nsnumber myboolnumber = example with literals nsarray myarray = @ nsdictionary mydictionary1 = @{ @key someobject } nsdictionary mydictionary2 = @{ key1 object1 key2 object2 } nsnumber mynumber = @myint nsnumber mysumnumber = @2+3 nsnumber myboolnumber = @yes nsnumber myintegernumber = @8 however different from string literals which compile constants executable these literals compile code equivalent above method calls particular under manually reference-counted memory management these objects are autoreleased which requires added care when eg used with function-static variables other kinds globals subscripting when using apple llvm compiler later arrays dictionaries nsarray nsdictionary classes can be manipulated using subscripting subscripting can be used retrieve values from indexes array keys dictionary with mutable objects can also be used set objects indexes keys code subscripting represented using brackets example without subscripting id object1 = id object2 = example with subscripting id object1 = somearray id object2 = somedictionary somemutablearray = object3 somemutabledictionary = object4 modern objective-c syntax after purchase next by apple attempts were made make language more acceptable programmers more familiar with java than smalltalk one these attempts was introducing what was dubbed modern syntax for objective-c at time opposed current classic syntax there was no change behaviour this was merely alternative syntax instead writing method invocation like object = init] was instead written object = myclassallocinit objectfirstlabel param1 param2 similarly declarations went from form -void firstlabel intparam1 secondlabel intparam2 -void firstlabel int param1 int param2 this modern syntax no longer supported current dialects objective-c language portable object compiler besides gcc/next/apple implementation which added several extensions original stepstone implementation another free open-source objective-c implementation called portable object compiler also exists set extensions implemented by portable object compiler differs from gcc/next/apple implementation particular includes smalltalk-like blocks for objective-c while lacks protocols categories two features used extensively openstep its derivatives relatives overall poc represents older pre-next stage language's evolution roughly conformant brad cox's book also includes runtime library called objectpak which based on cox's original icpak101 library which turn derives from smalltalk-80 class library quite radically different from openstep foundationkit geos objective-c pc geos system used programming language known geos objective-c goc despite name similarity two languages are similar only overall concept use keywords prefixed with @ sign clang clang compiler suite part llvm project implements objective-c other languages library use objective-c today often used tandem with fixed library standard objects often known kit framework such cocoa gnustep objfw these libraries often come with operating system gnustep libraries often come with linux based distributions cocoa comes with os x programmer not forced inherit functionality from existing base class nsobject / ofobject objective-c allows for declaration new root classes that do not inherit any existing functionality originally objective-c based programming environments typically offered object class base class from which almost all other classes inherited with introduction openstep next created new base class named nsobject which offered additional features over object emphasis on using object references reference counting instead raw pointers for example almost all classes cocoa inherit from nsobject not only did renaming serve differentiate new default behavior classes within openstep api but allowed code that used object—the original base class used on nextstep more less other objective-c class libraries—to co-exist same runtime with code that used nsobject with some limitations introduction two letter prefix also became simplistic form namespaces which objective-c lacks using prefix create informal packaging identifier became informal coding standard objective-c community continues this day more recently package managers have started appearing such cocoapods which aims be both package manager repository packages lot open-source objective-c code that was written last few years can now be installed using cocoapods analysis language this section needs additional citations for verification please help improve this article by adding citations reliable sources unsourced material may be challenged removed december learn how when remove this template message objective-c implementations use thin runtime system written c which adds little size application contrast most object-oriented systems at time that was created used large virtual machine runtimes programs written objective-c tend be not much larger than size their code that libraries which generally do not need be included software distribution contrast smalltalk systems where large amount memory was used just open window objective-c applications tend be larger than similar c c++ applications because objective-c dynamic typing does not allow methods be stripped inlined since programmer has such freedom delegate forward calls build selectors on fly pass them runtime system objective-c compiler cannot assume safe remove unused methods inline calls likewise language can be implemented atop extant c compilers gcc first preprocessor then module rather than new compiler this allows objective-c leverage huge existing collection c code libraries tools etc existing c libraries can be wrapped objective-c wrappers provide oo-style interface this aspect similar gobject library vala language which are widely used development gtk applications all these practical changes lowered barrier entry likely biggest problem for widespread acceptance smalltalk 1980s common criticism that objective-c does not have language support for namespaces instead programmers are forced add prefixes their class names which are traditionally shorter than namespace names thus more prone collisions all mac os x classes functions cocoa programming environment are prefixed with ns eg nsobject nsbutton identify them belonging mac os x ios core ns derives from names classes defined during development nextstep since objective-c strict superset c does not treat c primitive types first-class objects unlike c++ objective-c does not support operator overloading also unlike c++ objective-c allows object directly inherit only from one class forbidding multiple inheritance however most cases categories protocols may be used alternative ways achieve same results because objective-c uses dynamic runtime typing because all method calls are function calls some cases syscalls many common performance optimizations cannot be applied objective-c methods for example inlining constant propagation interprocedural optimizations scalar replacement aggregates this limits performance objective-c abstractions relative similar abstractions languages such c++ where such optimizations are possible memory management first versions objective-c did not support garbage collection at time this decision was matter some debate many people considered long dead times when smalltalk performed collection render entire system unusable some 3rd party implementations have added this feature most notably gnustep apple has implemented mac os x v105 however more recent versions mac os x ios garbage collection has been deprecated favor automatic reference counting arc introduced with arc compiler inserts retain release calls automatically into objective-c code based on static code analysis automation relieves programmer having write memory management code arc also adds weak references objective-c language philosophical differences between objective-c c++ design implementation c++ objective-c represent fundamentally different approaches extending c addition c's style procedural programming c++ directly supports certain forms object-oriented programming generic programming metaprogramming c++ also comes with large standard library that includes several container classes similarly objective-c adds object-oriented programming dynamic typing reflection c objective-c does not provide standard library per se but most places where objective-c used used with openstep-like library such openstep cocoa gnustep which provides functionality similar c++'s standard library one notable difference that objective-c provides runtime support for reflective features whereas c++ adds only small amount runtime support c objective-c object can be queried about its own properties eg whether will respond certain message c++ this not possible without use external libraries use reflection part wider distinction between dynamic run-time features static compile-time features language although objective-c c++ each employ mix both features objective-c decidedly geared toward run-time decisions while c++ geared toward compile-time decisions tension between dynamic static programming involves many classic trade-offs programming dynamic features add flexibility static features add speed type checking generic programming metaprogramming can be implemented both languages using runtime polymorphism c++ this takes form virtual functions runtime type identification while objective-c offers dynamic typing reflection objective-c lacks compile-time polymorphism generic functions entirely while c++ supports via function overloading templates see also c programming language c++ comparison programming languages comparison with com gobject som windows runtime xpcom swift xcode references lattner chris chris lattner's homepage chris lattner retrieved swift language product tireless effort from team language experts documentation gurus compiler optimization ninjas incredibly important internal dogfooding group who provided feedback help refine battle-test ideas course also greatly benefited from experiences hard-won by many other languages field drawing ideas from objective-c rust haskell ruby python c clu far too many others list singh amit december brief history mac os x mac os x internals retrieved june garling caleb iphone coding language now world's third most popular wired retrieved may wentk richard cocoa volume developer reference apple developer series john wiley sons isbn 0-470-49589-8 biancuzzi federico warden shane masterminds programming o'reilly media inc pp 242–246 isbn 0-596-51517-0 cox brad object oriented pre-compiler programming smalltalk methods c language acm sigplan notices new york ny acm doi101145/948093948095 retrieved common lisp readline issue first arose when next proposed distribute modified gcc two parts let user link them jobs asked me whether this was lawful seemed me at time that was following reasoning like what you are using but since result was very undesirable for free software i said i would have ask lawyer what lawyer said surprised me he said that judges would consider such schemes be subterfuges would be very harsh toward them he said judge would ask whether really one program rather than how labeled so i went back jobs said we believed his plan was not allowed by gpl direct result this that we now have objective c front end they had wanted distribute objective c parser separate proprietary package link with gcc back end but since i didn't agree this was allowed they made free gnustep introduction gnustep developers/gnu project retrieved kresten krab thorup | linkedin wwwlinkedincom retrieved write objective-c code applecom retrieved objective-c boot camp objective-c strict superset ansi c examining objective-c objective-c object-oriented strict superset c pro objective-c by keith lee tags for objective-c headers objective-c superset c appscan source now available objective-c programming language superset c programming language apple inc october dynamic method resolution objective-c runtime programming guide retrieved november apple inc october avoiding messaging errors objective-c programming language archived from original on september dalrymple mark knaster scott learn objective-c on mac p m extension originally stood for messages when objective-c was first introduced referring central feature objective-c objective-c runtime programming guide apple inc example categories concept extension methods c programming guide microsoft october retrieved using c++ with objective-c mac os x reference library last retrieved clang language extensions — clang documentation clangllvmorg retrieved objective-c more clues listsapplecom retrieved re objective-c listsapplecom retrieved gcc release series changes new features fixes garbage collection programming guide garbage collection api apple developer website - search for strong garbage collection programming guide introduction garbage collection apple inc leopard technology series for developers objective-c overview apple inc archived from original on july retrieved transitioning arc release notes apple inc retrieved mike ash friday q&a arm64 you mikeashcom retrieved hamster emporium non-pointer isa sealiesoftwarecom retrieved apple inc fast enumeration applecom retrieved free software foundation inc gcc release series – changes new features fixes gccgnuorg retrieved blocks programming topics – mac developer library apple inc march retrieved november transitioning arc apple inc retrieved october b programming with objective-c values collections apple inc retrieved october objective-c literals — clang documentation clangllvmorg retrieved rhapsody developer's guide ap professional portable object compiler userspandorabe retrieved breadbox computer company llc homepage retrieved december apple inc august mac os x leopard – xcode applecom archived from original on october retrieved transitioning arc release notes ios developer library developerapplecom retrieved further reading cox brad j object oriented programming evolutionary approach addison wesley isbn 0-201-54834-8 external links wikibooks has book on topic objective-c programming programming with objective-c from apple objective-c programming language from apple objective-c runtime programming guide from apple objective-c gnustep base programming manual objective-c by brad cox objective-c faq v t e c programming language ansi c o c89 c90 c99 c11 embedded c misra c features functions header files libraries operators string syntax preprocessor data types standard library functions char ctypeh file i/o stdioh math mathh dynamic memory stdlibh string stringh time timeh variadic stdargh posix standard libraries bionic o libhybris dietlibc eglibc glibc klibc microsoft run-time library musl newlib uclibc bsd libc compilers comparison compilers ack borland turbo c clang gcc icc lcc pelles c pcc sdcc tcc microsoft visual studio / express / c++ watcom c/c++ ides comparison ides anjuta codeblocks codelite eclipse geany microsoft visual studio netbeans comparison with other languages compatibility c c++ comparison with embedded c comparison with pascal comparison programming languages descendant languages c++ c d objective-c alef limbo go vala category authority control gnd 4335874-3 retrieved from https//enwikipediaorg/w/indexphptitle=objective-c&oldid=744398661 categories c programming language family class-based programming languages dynamically typed programming languages gnustep next object-oriented programming languages objective-c programming languages created hidden categories all articles with unsourced statements articles with unsourced statements from april articles with unsourced statements from august articles with unsourced statements from november articles needing additional references from november all articles needing additional references articles needing additional references from december use dmy dates from january wikipedia articles with gnd identifiers navigation menu personal tools not logged talk contributions create account log namespaces article talk variants views read edit view history more search navigation main page contents featured content current events random article donate wikipedia wikipedia store interaction help about wikipedia community portal recent changes contact page tools what links here related changes upload file special pages permanent link page information wikidata item cite this page print/export create book download pdf printable version other projects wikimedia commons wikibooks languages العربية azərbaycanca বাংলা български català čeština dansk deutsch español esperanto فارسی français galego 한국어 հայերեն italiano עברית ქართული қазақша magyar nederlands 日本語 norsk bokmål polski português русский scots simple english slovenčina slovenščina српски / srpski suomi svenska தமிழ் ไทย тоҷикӣ türkçe українська 中文 edit links this page was last modified on october at text available under creative commons attribution-sharealike license additional terms may apply by using this site you agree terms use privacy policy wikipedia® registered trademark wikimedia foundation inc non-profit organization privacy policy about wikipedia disclaimers contact wikipedia developers cookie statement mobile view 