data-flow analysis from wikipedia free encyclopedia   redirected from data flow analysis jump navigation search data-flow analysis technique for gathering information about possible set values calculated at various points computer program program's control flow graph cfg used determine those parts program which particular value assigned variable might propagate information gathered often used by compilers when optimizing program canonical example data-flow analysis reaching definitions simple way perform data-flow analysis programs set up data-flow equations for each node control flow graph solve them by repeatedly calculating output from input locally at each node until whole system stabilizes ie reaches fixpoint this general approach was developed by gary kildall while teaching at naval postgraduate school contents basic principles iterative algorithm o convergence o work list approach o order matters o initialization examples o forward analysis o backward analysis other approaches bit vector problems sensitivities list data-flow analyses see also references further reading basic principles process collecting information about way variables are used defined program data-flow analysis attempts obtain particular information at each point procedure usually enough obtain this information at boundaries basic blocks since from that easy compute information at points basic block forward flow analysis exit state block function block's entry state this function composition effects statements block entry state block function exit states its predecessors this yields set data-flow equations for each block b o u t b = t r n s b i n b {\displaystyle out{b}=trans{b}in{b}} i n b = j o i n p ∈ p r e d b o u t p {\displaystyle in{b}=join{p\in pred{b}}out{p}} this t r n s b {\displaystyle trans{b}} transfer function block b {\displaystyle b} works on entry state i n b {\displaystyle in{b}} yielding exit state o u t b {\displaystyle out{b}} join operation j o i n {\displaystyle join} combines exit states predecessors p ∈ p r e d b {\displaystyle p\in pred{b}} b {\displaystyle b} yielding entry state b {\displaystyle b} after solving this set equations entry and/or exit states blocks can be used derive properties program at block boundaries transfer function each statement separately can be applied get information at point inside basic block each particular type data-flow analysis has its own specific transfer function join operation some data-flow problems require backward flow analysis this follows same plan except that transfer function applied exit state yielding entry state join operation works on entry states successors yield exit state entry point forward flow plays important role since has no predecessors its entry state well defined at start analysis for instance set local variables with known values empty if control flow graph does not contain cycles there were no explicit implicit loops procedure solving equations straightforward control flow graph can then be topologically sorted running order this sort entry states can be computed at start each block since all predecessors that block have already been processed so their exit states are available if control flow graph does contain cycles more advanced algorithm required iterative algorithm most common way solving data-flow equations by using iterative algorithm starts with approximation in-state each block out-states are then computed by applying transfer functions on in-states from these in-states are updated by applying join operations latter two steps are repeated until we reach so-called fixpoint situation which in-states out-states consequence do not change basic algorithm for solving data-flow equations round-robin iterative algorithm for i ← n initialize node i while sets are still changing for i ← n recompute sets at node i convergence be usable iterative approach should actually reach fixpoint this can be guaranteed by imposing constraints on combination value domain states transfer functions join operation value domain should be partial order with finite height ie there are no infinite ascending chains x {\displaystyle x{1}} b then b2 c = + b d = b3 endif c = return b d + c backward analysis // {} b1 = b = d = x = //x never being used later thus not out set {abd} if > b then // out {abd} //union all successors b1 => b2 {ab} b3{bd} // {ab} b2 c = + b d = // out {bd} // {bd} b3 endif c = return b d + c // out{} in-state b3 only contains b d since c has been written out-state b1 union in-states b2 b3 definition c b2 can be removed since c not live immediately after statement solving data-flow equations starts with initializing all in-states out-states empty set work list initialized by inserting exit point b3 work list typical for backward flow its computed in-state differs from previous one so its predecessors b1 b2 are inserted process continues progress summarized table below processing out-state old in-state new in-state work list b3 {} {} {bd} b1b2 b1 {bd} {} {} b2 b2 {bd} {} {ab} b1 b1 {abd} {} {} note that b1 was entered list before b2 which forced processing b1 twice b1 was re-entered predecessor b2 inserting b2 before b1 would have allowed earlier completion initializing with empty set optimistic initialization all variables start out dead note that out-states cannot shrink from one iteration next although out-state can be smaller than in-state this can be seen from fact that after first iteration out-state can only change by change in-state since in-state starts empty set can only grow further iterations other approaches markus mohnen described new method data-flow analysis that does not require explicit construction data-flow graph instead relying on abstract interpretation program keeping working set program counters at each conditional branch both targets are added working set each path followed for many instructions possible until end program until has looped with no changes then removed from set next program counter retrieved bit vector problems examples above are problems which data-flow value set eg set reaching definitions using bit for definition position program set live variables these sets can be represented efficiently bit vectors which each bit represents set membership one particular element using this representation join transfer functions can be implemented bitwise logical operations join operation typically union intersection implemented by bitwise logical logical transfer function for each block can be decomposed so-called gen kill sets example live-variable analysis join operation union kill set set variables that are written block whereas gen set set variables that are read without being written first data-flow equations become o u t b = ⋃ s ∈ s u c c b i n s {\displaystyle out{b}=\bigcup {s\in succ{b}}in{s}} i n b = o u t b − k i l l b ∪ g e n b {\displaystyle in{b}=out{b}-kill{b}\cup gen{b}} logical operations this reads outb = for s succb outb = outb ins inb = outb not killb genb sensitivities data-flow analysis inherently flow-sensitive data-flow analysis typically path-insensitive though possible define data-flow equations that yield path-sensitive analysis flow-sensitive analysis takes into account order statements program for example flow-insensitive pointer alias analysis may determine variables x y may refer same location while flow-sensitive analysis may determine after statement variables x y may refer same location path-sensitive analysis computes different pieces analysis information dependent on predicates at conditional branch instructions for instance if branch contains condition x>0 then on fall-through path analysis would assume that x0 holds context-sensitive analysis interprocedural analysis that considers calling context when analyzing target function call particular using context information one can jump back original call site whereas without that information analysis information has be propagated back all possible call sites potentially losing precision list data-flow analyses reaching definitions liveness analysis definite assignment analysis available expression constant propagation see also xlt86 control flow analysis references kildall gary unified approach global program optimization proceedings 1st annual acm sigact-sigplan symposium on principles programming languages 194–206 doi 101145/512927512945 retrieved keith d cooper timothy j harvey ken kennedy iterative data-flow analysis revisited mohnen markus graph-free approach data-flow analysis lecture notes computer science lecture notes computer science 185–213 doi101007/3-540-45937-56 isbn 978-3-540-43369-9 retrieved further reading cooper keith d torczon linda engineering compiler morgan kaufmann muchnick steven s advanced compiler design implementation morgan kaufmann hecht matthew s flow analysis computer programs elsevier north-holland inc khedker uday p sanyal amitabha karkare bageshri data flow analysis theory practice crc press taylor francis group flemming nielson hanne riis nielson chris hankin principles program analysis springer v t e compiler optimizations basic block peephole optimization loop optimization induction variable strength reduction loop fusion loop inversion loop interchange loop-invariant code motion loop nest optimization loop unrolling loop splitting loop unswitching software pipelining automatic parallelization data-flow analysis common subexpression elimination constant folding induction variable recognition elimination dead store elimination use-define chain live variable analysis available expression ssa-based global value numbering sparse conditional constant propagation code generation register allocation instruction selection instruction scheduling rematerialization functional tail call elimination deforestation global interprocedural optimization other bounds-checking elimination dead code elimination inline expansion jump threading static analysis alias analysis pointer analysis shape analysis escape analysis array access analysis dependence analysis control flow analysis data flow analysis retrieved from https//enwikipediaorg/w/indexphptitle=data-flowanalysis&oldid=743070292 categories compiler optimizations data-flow analysis navigation menu personal tools not logged talk contributions create account log namespaces article talk variants views read edit view history more search navigation main page contents featured content current events random article donate wikipedia wikipedia store interaction help about wikipedia community portal recent changes contact page tools what links here related changes upload file special pages permanent link page information wikidata item cite this page print/export create book download pdf printable version languages deutsch 한국어 日本語 slovenčina 中文 edit links this page was last modified on october at text available under creative commons attribution-sharealike license additional terms may apply by using this site you agree terms use privacy policy wikipedia® registered trademark wikimedia foundation inc non-profit organization privacy policy about wikipedia disclaimers contact wikipedia developers cookie statement mobile view 