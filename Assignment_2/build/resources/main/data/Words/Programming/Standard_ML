standard ml from wikipedia free encyclopedia jump navigation search standard ml paradigm multi-paradigm functional imperative typing discipline strong static inferred filename extensions sml major implementations mlkit mlton mlworks moscow ml poly/ml sml/nj mlj smlnet dialects alice concurrent ml dependent ml influenced by ml hope influenced elm f ocaml rust scala standard ml sml general-purpose modular functional programming language with compile-time type checking type inference popular among compiler writers programming language researchers well development theorem provers sml modern descendant ml programming language used logic for computable functions lcf theorem-proving project distinctive among widely used languages that has formal specification given typing rules operational semantics definition standard ml revised simplified definition standard ml revised contents language o type synonyms o algebraic datatypes pattern matching o higher-order functions o exceptions o module system code examples o hello world o insertion sort o mergesort o quicksort o expression language o arbitrary-precision factorial function libraries o numerical derivative higher-order functions o discrete wavelet transform pattern matching implementations see also references external links language standard ml functional programming language with some impure features programs written standard ml consist expressions be evaluated opposed statements commands although some expressions return trivial unit value are only evaluated for their side-effects like all functional programming languages key feature standard ml function which used for abstraction for instance factorial function can be expressed fun factorial n = if n = then else n factorial n-1 standard ml compiler required infer static type int -> int this function without user-supplied type annotations ie has deduce that n only used with integer expressions must therefore itself be integer that all value-producing expressions within function return integers same function can be expressed with clausal function definitions where if-then-else conditional replaced by sequence templates factorial function evaluated for specific values separated by '|' which are tried one by one order written until match found fun factorial = | factorial n = n factorial n - this can be rewritten using case statement like this val rec factorial = fn n => case n => | n => n factorial n - lambda function val rec factorial = fn => | n => n factorialn here keyword val introduces binding identifier value fn introduces definition anonymous function case introduces sequence patterns corresponding expressions using local function this function can be rewritten more efficient tail recursive style fun factorial n = let fun lp acc = acc | lp m acc = lp m-1 macc lp n end value let-expression that expression between end encapsulation invariant-preserving tail-recursive tight loop with one more accumulator parameters inside invariant-free outer function seen here common idiom standard ml appears with great frequency sml code type synonyms type synonym defined with type keyword here type synonym for points plane functions computing distances between two points area triangle with given corners per heron's formula type loc = real real fun dist x0 y0 x1 y1 = let val dx = x1 - x0 val dy = y1 - y0 mathsqrt dx dx + dy dy end fun heron b c = let val ab = dist b val bc = dist b c val ac = dist c val perim = ab + bc + ac val s = perim / mathsqrt s s - ab s - bc s - ac end algebraic datatypes pattern matching standard ml provides strong support for algebraic datatypes ml datatype can be thought disjoint union tuples sum products they are easy define easy program with large part because standard ml's pattern matching well most standard ml implementations' pattern exhaustiveness checking pattern redundancy checking datatype defined with datatype keyword datatype shape = circle loc real center radius | square loc real upper-left corner side length axis-aligned | triangle loc loc loc corners see above for definition loc note datatypes not type synonyms are necessary define recursive constructors this not at issue present example order matters pattern matching patterns that are textually first are tried first pattern matching can be syntactically embedded function definitions follows fun area circle r = r r | area square s = s s | area triangle b c = heron b c see above note that subcomponents whose values are not needed particular computation are ellided with underscores so-called wildcard patterns so-called clausal form style function definition where patterns appear immediately after function name merely syntactic sugar for fun area shape = case shape circle r => r r | square s => s s | triangle b c => heron b c pattern exhaustiveness checking will make sure each case datatype has been accounted for will produce warning if not following pattern inexhaustive fun center circle c = c | center square x y s = x + s / y + s / there no pattern for triangle case center function compiler will issue warning that pattern inexhaustive if at runtime triangle passed this function exception match will be raised set clauses following function definition exhaustive not redundant fun hascorners circle = false | hascorners = true if control gets past first pattern circle we know value must be either square triangle either those cases we know shape has corners so we can return true without discriminating which case we are pattern second clause following meaningless function redundant fun f circle x y r = x+y | f circle = | f = any value that matches pattern second clause will also match pattern first clause so second clause unreachable therefore this definition whole exhibits redundancy causes compile-time warning c programmers can use tagged unions dispatching on tag values accomplish what ml accomplishes with datatypes pattern matching nevertheless while c program decorated with appropriate checks will be sense robust corresponding ml program those checks will necessity be dynamic ml provides set static checks that give programmer high degree confidence correctness program at compile time note that object-oriented programming languages such java disjoint union can be expressed by designing class hierarchies however opposed class hierarchies adts are closed this makes adt extensible way that orthogonal extensibility class hierarchies class hierarchies can be extended with new subclasses but no new methods while adts can be extended provide new behavior for all existing constructors but do not allow defining new constructors higher-order functions functions can consume functions arguments fun applytoboth f x y = f x f y functions can produce functions return values fun constantfn k = let fun const anything = k const end alternatively fun constantfn k = fn anything => k functions can also both consume produce functions fun compose f g = let fun h x = f g x h end alternatively fun compose f g = fn x => f g x function listmap from basis library one most commonly used higher-order functions standard ml fun map = | map f xxs = f x map f xs more efficient implementation map would define tail-recursive inner loop follows fun map f xs = let fun m acc = listrev acc | m xxs acc = m xs f x acc m xs end exceptions exceptions are raised with raise keyword handled with pattern matching handle constructs exception undefined fun max = x | max xxs = let val m = max xs if x > m then x else m end | max = raise undefined fun main xs = let val msg = inttostring max xs handle undefined => empty listthere no max print msg \n end exception system can be exploited implement non-local exit optimization technique suitable for functions like following exception zero fun listprod ns = let fun p = | p = raise zero | p ht = h p t p ns handle zero => end when exception zero raised case control leaves function p altogether consider alternative value would be returned most recent awaiting frame would be multiplied by local value h resulting value inevitably would be returned turn next awaiting frame so on raising exception allows control leapfrog directly over entire chain frames avoid associated computation has be noted that same optimization could have been obtained by using tail recursion for this example module system standard ml has advanced module system allowing programs be decomposed into hierarchically organized structures logically related type value declarations sml modules provide not only namespace control but also abstraction sense that they allow programmers define abstract data types three main syntactic constructs comprise sml module system signatures structures functors structure module consists collection types exceptions values structures called substructures packaged together into logical unit signature interface usually thought type for structure specifies names all entities provided by structure well arities type components types value components signatures for substructures definitions type components may may not be exported type components whose definitions are hidden are abstract types finally functor function from structures structures that functor accepts one more arguments which are usually structures given signature produces structure its result functors are used implement generic data structures algorithms for example signature for queue data structure might be signature queue = sig type 'a queue exception queueerror val empty 'a queue val isempty 'a queue -> bool val singleton 'a -> 'a queue val insert 'a 'a queue -> 'a queue val peek 'a queue -> 'a val remove 'a queue -> 'a 'a queue end this signature describes module that provides parameterized type queue queues exception called queueerror six values five which are functions providing basic operations on queues one can now implement queue data structure by writing structure with this signature structure twolistqueue > queue = struct type 'a queue = 'a list 'a list exception queueerror val empty = fun isempty = true | isempty = false fun singleton = fun insert = | insert ins outs = ains outs fun peek = raise queueerror | peek ins aouts = fun remove = raise queueerror | remove ins = rev ins | remove ins aouts = insouts end this definition declares that twolistqueue implementation queue signature furthermore opaque ascription denoted by > states that any type components whose definitions are not provided signature ie queue should be treated abstract meaning that definition queue pair lists not visible outside module body structure provides bindings for all components listed signature use structure one can access its type value members using dot notation for instance queue strings would have type string twolistqueuequeue empty queue twolistqueueempty remove first element from queue called q one would write twolistqueueremove q one popular algorithm for breadth-first search trees makes uses queues here we present version that algorithm parameterized over abstract queue structure functor bfs structure q queue = after okasaki icfp struct datatype 'a tree = e | t 'a 'a tree 'a tree fun bfsq q 'a tree qqueue 'a list = if qisempty q then else let val t q' = qremove q case t e => bfsq q' | t x l r => let val q'' = qinsert r qinsert l q' x bfsq q'' end end fun bfs t = bfsq qsingleton t end please note that inside bfs structure program has no access particular queue representation play more concretely there no way for program say select first list two-list queue representation if that indeed representation being used this data abstraction mechanism makes breadth-first code truly agnostic queue representation choice this general desirable present case queue structure can safely maintain any various logical invariants on which its correctness depends behind bulletproof wall abstraction code examples this section does not cite any sources please help improve this section by adding citations reliable sources unsourced material may be challenged removed june learn how when remove this template message snippets sml code are most easily studied by entering them into top-level also known read-eval-print loop repl this interactive session that prints inferred types resulting defined expressions many sml implementations provide interactive repl including sml/nj $ sml standard ml new jersey v11052 - code can then be entered at - prompt for example calculate 1+23 - + val = int top-level infers type expression be int gives result hello world following program hellosml print hello world\n can be compiled with mlton $ mlton hellosml executed $ /hello hello world insertion sort insertion sort for lists integers ascending expressed concisely follows fun ins n = | ins n ns ht = if n bool -> 'a list -> 'a list mergesort main article merge sort here classic mergesort algorithm implemented three functions split merge mergesort function split implemented with local function named loop which has two additional parameters local function loop written tail-recursive style such can be compiled efficiently this function makes use sml's pattern matching syntax differentiate between non-empty list xxs empty list cases for stability input list ns reversed before being passed loop split list into two near-halves returned pair “halves” will either be same size first will have one more element than second runs on time where n = |xs| local fun loop xyzs xs ys = loop zs xxs yys | loop x xs ys = xxs ys | loop xs ys = xs ys fun split ns = loop listrev ns end local-in-end syntax could be replaced with let-in-end syntax yielding equivalent definition fun split ns = let fun loop xyzs xs ys = loop zs xxs yys | loop x xs ys = xxs ys | loop xs ys = xs ys loop listrev ns end with split merge also uses local function loop for efficiency inner loop defined terms cases when two non-empty lists are passed when one non-empty list passed when two empty lists are passed note use underscore wildcard pattern this function merges two ascending lists into one ascending list note how accumulator out built backwards then reversed with listrev before being returned this common technique—build list backwards then reverse before returning sml lists are represented imbalanced binary trees thus efficient prepend element list but inefficient append element list extra pass over list linear time operation so while this technique requires more wall clock time asymptotics are not any worse merge two ordered lists using order lt pre given lists xs ys must already be ordered per lt runs on time where n = |xs| + |ys| fun merge lt xs ys = let fun loop out left xxs right yys = if lt x y then loop xout xs right else loop yout left ys | loop out xxs = loop xout xs | loop out yys = loop yout ys | loop out = listrev out loop xs ys end main function sort list according given ordering operation lt runs on log n time where n = |xs| fun mergesort lt xs = let val merge' = merge lt fun ms = | ms = | ms xs = let val left right = split xs merge' ms left ms right end ms xs end also note that code makes no mention variable types with exception syntax which signify lists this code will sort lists any type so long consistent ordering function lt can be defined using hindley–milner type inference compiler capable inferring types all variables even complicated types such that lt function quicksort quicksort can be expressed follows this generic quicksort consumes order operator boolty then raise err else if typeof e2 typeof e3 then raise err else typeof e2 fun eval true = true | eval false = false | eval int n = int n | eval not e = case eval e true => false | false => true | => raise fail type-checking broken | eval add e1 e2 = let val int n1 = eval e1 val int n2 = eval e2 int n1 + n2 end | eval if e1 e2 e3 = if eval e1 = true then eval e2 else eval e3 fun chkeval e = ignore typeof e eval e will raise err on type error arbitrary-precision factorial function libraries sml intinf module provides arbitrary-precision integer arithmetic moreover integer literals may be used arbitrary-precision integers without programmer having do anything following program factsml implements arbitrary-precision factorial function prints factorial fun fact n intinfint = if n=0 then else n factn - val = print intinftostring fact \n can be compiled run with $ mlton factsml $ /fact numerical derivative higher-order functions since sml functional programming language easy create pass around functions sml programs this capability has enormous number applications calculating numerical derivative function one such application following sml function d computes numerical derivative given function f at given point x - fun d delta f x = f x + delta - f x - delta / delta val d = fn real -> real -> real -> real -> real this function requires small value delta good choice for delta when using this algorithm cube root machine epsilon type function d indicates that maps float onto another function with type real -> real -> real -> real this allows us partially apply arguments this functional style known currying this case useful partially apply first argument delta d obtain more specialised function - val d = d 1e~8 val d = fn real -> real -> real -> real note that inferred type indicates that replacement d expecting function with type real -> real its first argument we can compute numerical approximation derivative f x = x − x − {\displaystyle fx=x^{3}-x-1} at x = {\displaystyle x=3} with - d fn x => x x x - x - val = real correct answer f ′ x = x − {\displaystyle f'x=3x^{2}-1} f ′ = − = {\displaystyle f'3=27-1=26} function d called higher-order function because accepts another function f argument curried higher-order functions can be used eliminate redundant code for example library may require functions type -> b but more convenient write functions type c -> b where there fixed relationship between objects type c higher order function type c -> b -> -> b can factor out this commonality this example adapter pattern discrete wavelet transform pattern matching haar wavelet transform integer-power-of-two-length list numbers can be implemented very succinctly sml excellent example use pattern matching over lists taking pairs elements h1 h2 off front storing their sums differences on lists s d respectively - fun haar l = let fun aux d = s d | aux s d = aux s d | aux h1h2t s d = aux t h1+h2 s h1-h2 d | aux = raise empty aux l end val haar = fn int list -> int list for example - haar val = int list pattern matching useful construct that allows complicated transformations be represented clearly succinctly moreover sml compilers turn pattern matches into efficient code resulting programs that are not only shorter but also faster implementations many sml implementations exist including standard ml new jersey abbreviated sml/nj full compiler with associated libraries tools interactive shell documentation mlton whole-program optimizing compiler that produces very fast code compared other ml implementations ml kit integrates garbage collector which can be disabled region-based memory management with automatic inference regions aiming support realtime applications its implementation based very closely on definition poly/ml full implementation standard ml that produces fast code supports multicore hardware via posix threads its runtime system performs parallel garbage collection online sharing immutable substructures isabelle/ml integrates parallel poly/ml into interactive theorem prover with sophisticated ide based on jedit for official standard ml sml'97 isabelle/ml dialect proof language starting with isabelle2016 there also source-level debugger for ml moscow ml light-weight implementation based on caml light runtime engine implements full sml language including sml modules much sml basis library cakeml read-eval-print loop version ml with formally verified runtime translation assembler hamlet sml interpreter that aims be accurate accessible reference implementation standard tilt full certifying compiler for sml uses typed intermediate languages optimize code ensure correctness can compile typed assembly language smlnet allows compiling microsoft clr has extensions for linking with other net code sml2c batch compiler compiles only module-level declarations ie signatures structures functors into c based on sml/nj version shares front end most its run-time system but does not support sml/nj style debugging profiling module-level programs that run on sml/nj can be compiled by sml2c with no changes poplog system implements version sml with pop-11 optionally common lisp prolog allowing mixed language programming for all implementation language pop-11 which compiled incrementally also has integrated emacs-like editor that communicates with compiler sml extension sml providing record polymorphism c language interoperability conventional native compiler its name not allusion running on net framework alice interpreter for standard ml by saarland university adding features for lazy evaluation concurrency multithreading distributed computing via remote procedure calls constraint programming all these implementations are open-source freely available most are implemented themselves sml there are no longer any commercial sml implementations harlequin once produced commercial ide compiler for sml called mlworks company now defunct mlworks passed on xanalys was later acquired by ravenbrook limited on open sourced see also alice ml concurrent ml dependent ml extensible ml extended ml f ocaml ur/web references milner robin tofte mads harper robert macqueen david definition standard ml revised mit press isbn 0-262-63181-4 okasaki chris breadth-first numbering lessons from small exercise algorithm design international conference on functional programming acm cakeml cakemlorg external links standard ml family github project standard ml language mads tofte scholarpedia doi104249/scholarpedia7515 what sml what sml '97 successor ml sml intended provide vehicle for continued evolution ml using standard ml starting point programming standard ml programming standard ml '97 on-line tutorial univ chicago - sml tutorial slides cse341 programming languages dan grossman university washington also on coursera youtube retrieved from https//enwikipediaorg/w/indexphptitle=standardml&oldid=751183030 categories procedural programming languages ml programming language family functional languages programming languages created hidden categories articles needing additional references from june all articles needing additional references all articles with unsourced statements articles with unsourced statements from august articles with unsourced statements from may navigation menu personal tools not logged talk contributions create account log namespaces article talk variants views read edit view history more search navigation main page contents featured content current events random article donate wikipedia wikipedia store interaction help about wikipedia community portal recent changes contact page tools what links here related changes upload file special pages permanent link page information wikidata item cite this page print/export create book download pdf printable version languages català čeština dansk deutsch español français հայերեն italiano ქართული magyar 日本語 polski português русский simple english türkçe українська edit links this page was last modified on november at text available under creative commons attribution-sharealike license additional terms may apply by using this site you agree terms use privacy policy wikipedia® registered trademark wikimedia foundation inc non-profit organization privacy policy about wikipedia disclaimers contact wikipedia developers cookie statement mobile view 