rice's theorem from wikipedia free encyclopedia jump navigation search computability theory rice's theorem states that all non-trivial semantic properties programs are undecidable semantic property one about programs behavior for instance does program terminate for all inputs unlike syntactic property for instance does program contain if-then-else statement property non-trivial if neither true for every program nor for no program rice's theorem can also be put terms functions for any non-trivial property partial functions no general effective method can decide whether algorithm computes partial function with that property here property partial functions called trivial if holds for all partial computable functions for none effective decision method called general if decides correctly for every algorithm theorem named after henry gordon rice also known rice–myhill–shapiro theorem after rice john myhill norman shapiro contents introduction formal statement examples proof by kleene's recursion theorem proof by reduction halting problem o proof sketch o formal proof rice's theorem index sets analogue rice's theorem for recursive sets see also notes references external links introduction another way stating rice's theorem that more useful computability theory follows let s be set languages that nontrivial meaning there exists turing machine that recognizes language s there exists turing machine that recognizes language not s then undecidable determine whether language recognized by arbitrary turing machine lies s practice this means that there no machine that can always decide whether language given turing machine has particular nontrivial property special cases include undecidability whether turing machine accepts particular string whether turing machine recognizes particular recognizable language whether language recognized by turing machine could be recognized by nontrivial simpler machine such finite automaton important note that rice's theorem does not say anything about those properties machines programs that are not also properties functions languages for example whether machine runs for more than steps on some input decidable property even though non-trivial implementing exactly same language two different machines might require different number steps recognize same input similarly whether machine has more than states decidable property machine number states can simply be counted where property kind that either two machines may may not have while still implementing exactly same language property machines not language rice's theorem does not apply using rogers' characterization acceptable programming systems rice's theorem may essentially be generalized from turing machines most computer programming languages there exists no automatic method that decides with generality non-trivial questions on behavior computer programs example consider following variant halting problem let p be following property partial functions f one argument pf means that f defined for argument '1' obviously non-trivial since there are partial functions that are defined at others that are undefined at 1-halting problem problem deciding any algorithm whether defines function with this property ie whether algorithm halts on input by rice's theorem 1-halting problem undecidable similarly question whether turing machine t terminates on initially empty tape rather than with initial word w given second argument addition description t full halting problem still undecidable formal statement let ϕ n → p {\displaystyle \phi \colon \mathbb {n} \to \mathbf {p} ^{1}} be admissible numbering computable functions map from natural numbers class p {\displaystyle \mathbf {p} ^{1}} unary partial computable functions denote by ϕ e = ϕ e {\displaystyle \phi {e}=\phi e} eth partial computable function we identify each property that computable function may have with subset p {\displaystyle \mathbf {p} ^{1}} consisting functions with that property thus given set f ⊆ p {\displaystyle f\subseteq \mathbf {p} ^{1}} computable function ϕ e {\displaystyle \phi {e}} has property f if only if ϕ e ∈ f {\displaystyle \phi {e}\in f} for each property f ⊆ p {\displaystyle f\subseteq \mathbf {p} ^{1}} there associated decision problem d f {\displaystyle d{f}} determining given e whether ϕ e ∈ f {\displaystyle \phi {e}\in f} rice's theorem states that decision problem d f {\displaystyle d{f}} decidable also called recursive computable if only if f = ∅ {\displaystyle f=\emptyset } f = p {\displaystyle f=\mathbf {p} ^{1}} examples according rice's theorem if there at least one computable function particular class c computable functions another computable function not c then problem deciding whether particular program computes function c undecidable for example rice's theorem shows that each following sets computable functions undecidable class computable functions that return for every input its complement class computable functions that return for at least one input its complement class computable functions that are constant its complement class indices for computable functions that are total class indices for recursively enumerable sets that are cofinite class indices for recursively enumerable sets that are recursive proof by kleene's recursion theorem corollary kleene's recursion theorem states that for every gödel numbering ϕ n → p {\displaystyle \phi \colon \mathbb {n} \to \mathbf {p} ^{1}} computable functions every computable function q x y {\displaystyle qxy} there index e {\displaystyle e} such that ϕ e y {\displaystyle \phi {e}y} returns q e y {\displaystyle qey} following we say that f x {\displaystyle fx} returns g x {\displaystyle gx} if either f x = g x {\displaystyle fx=gx} both f x {\displaystyle fx} g x {\displaystyle gx} are undefined intuitively ϕ e {\displaystyle \phi {e}} quine function that returns its own source code gödel number except that rather than returning directly ϕ e {\displaystyle \phi {e}} passes its gödel number q {\displaystyle q} returns result let f {\displaystyle f} be set computable functions such that ∅ ≠ f ≠ p {\displaystyle \emptyset \neq f\neq \mathbf {p} ^{1}} then there are computable functions f ∈ f {\displaystyle f\in f} g ∉ f {\displaystyle g\notin f} suppose that set indices x {\displaystyle x} such that ϕ x ∈ f {\displaystyle \phi {x}\in f} decidable then there exists function q x y {\displaystyle qxy} that returns g y {\displaystyle gy} if ϕ x ∈ f {\displaystyle \phi {x}\in f} f y {\displaystyle fy} otherwise by corollary recursion theorem there index e {\displaystyle e} such that ϕ e y {\displaystyle \phi {e}y} returns q e y {\displaystyle qey} but then if ϕ e ∈ f {\displaystyle \phi {e}\in f} then ϕ e {\displaystyle \phi {e}} same function g {\displaystyle g} therefore ϕ e ∉ f {\displaystyle \phi {e}\notin f} if ϕ e ∉ f {\displaystyle \phi {e}\notin f} then ϕ e {\displaystyle \phi {e}} f {\displaystyle f} therefore ϕ e ∈ f {\displaystyle \phi {e}\in f} both cases we have contradiction proof by reduction halting problem proof sketch suppose for concreteness that we have algorithm for examining program p determining infallibly whether p implementation squaring function which takes integer d returns d2 proof works just well if we have algorithm for deciding any other nontrivial property programs given general below claim that we can convert our algorithm for identifying squaring programs into one that identifies functions that halt we will describe algorithm that takes inputs i determines whether program halts when given input i algorithm for deciding this conceptually simple constructs description new program t taking argument n which first executes program on input i both i being hard-coded into definition t then returns square n if ai runs forever then t never gets step regardless n then clearly t function for computing squares if only if step terminates since we've assumed that we can infallibly identify programs for computing squares we can determine whether t which depends on i such program that for every i thus we have obtained program that decides whether program halts on input i note that our halting-decision algorithm never executes t but only passes its description squaring-identification program which by assumption always terminates since construction description t can also be done way that always terminates halting-decision cannot fail halt either halts ai { define tn { ai return n×n } return isasquaringfunctiont } this method doesn't depend specifically on being able recognize functions that compute squares long some program can do what we're trying recognize we can add call obtain our t we could have had method for recognizing programs for computing square roots programs for computing monthly payroll programs that halt when given input abraxas programs that commit array bounds errors each case we would be able solve halting problem similarly formal proof if we have algorithm that decides non-trivial property we can construct turing machine that decides halting problem for formal proof algorithms are presumed define partial functions over strings are themselves represented by strings partial function computed by algorithm represented by string denoted fa this proof proceeds by reductio ad absurdum we assume that there non-trivial property that decided by algorithm then show that follows that we can decide halting problem which not possible therefore contradiction let us now assume that pa algorithm that decides some non-trivial property fa without loss generality we may assume that pno-halt = no with no-halt being representation algorithm that never halts if this not true then this holds for negation property since p decides non-trivial property follows that there string b that represents algorithm pb = yes we can then define algorithm ha i follows construct string t that represents algorithm tj such that t first simulates computation fai then t simulates computation fbj returns its result return pt we can now show that h decides halting problem assume that algorithm represented by halts on input i this case ft = fb because pb = yes output px depends only on fx follows that pt = yes therefore ha i = yes assume that algorithm represented by does not halt on input i this case ft = fno-halt ie partial function that never defined since pno-halt = no output px depends only on fx follows that pt = no therefore ha i = no since halting problem known be undecidable this contradiction assumption that there algorithm pa that decides non-trivial property for function represented by must be false rice's theorem index sets rice's theorem can be succinctly stated terms index sets let c {\displaystyle {\mathcal {c}}} be class partial recursive functions with index set c {\displaystyle c} then c {\displaystyle c} recursive if only if c = ∅ {\displaystyle c=\emptyset } c = n {\displaystyle c=\mathbb {n} } where n {\displaystyle \mathbb {n} } set natural numbers including zero analogue rice's theorem for recursive sets one can regard rice's theorem asserting impossibility effectively deciding for any recursively enumerable set whether has certain nontrivial property this section we give analogue rice's theorem for recursive sets instead recursively enumerable sets roughly speaking analogue says that if one can effectively determine for any recursive set whether has certain property then finitely many integers determine whether recursive set has property this result analogous original rice's theorem because both assert that property decidable only if one can determine whether set has that property by examining for at most finitely many i {\displaystyle i} for no i {\displaystyle i} for original theorem if i {\displaystyle i} belongs set let w {\displaystyle w} be class called simple game thought property recursive sets if s {\displaystyle s} recursive set then for some e {\displaystyle e} computable function ϕ e {\displaystyle \phi {e}} characteristic function s {\displaystyle s} we call e {\displaystyle e} characteristic index for s {\displaystyle s} there are infinitely many such e {\displaystyle e} let's say class w {\displaystyle w} computable if there algorithm computable function that decides for any nonnegative integer e {\displaystyle e} not necessarily characteristic index if e {\displaystyle e} characteristic index for recursive set belonging w {\displaystyle w} then algorithm gives yes if e {\displaystyle e} characteristic index for recursive set not belonging w {\displaystyle w} then algorithm gives no set s ⊆ n {\displaystyle s\subseteq \mathbb {n} } extends string τ {\displaystyle \tau } 0's 1's if for any k journal mathematical economics doi101016/jjmateco200705012 kumabe m mihara h r nakamura numbers for computable simple games social choice welfare doi101007/s00355-008-0300-5 references hopcroft john ullman jeffrey introduction automata theory languages computation addison-wesley 185–192 rice h g classes recursively enumerable sets their decision problems trans amer math soc 358-366 rogers hartley theory recursive functions effective computability new york mcgraw-hill external links weisstein eric w rice's theorem mathworld retrieved from https//enwikipediaorg/w/indexphptitle=rice%27stheorem&oldid=749712808 categories theorems theory computation theorems foundations mathematics undecidable problems hidden categories articles containing proofs articles with inconsistent citation formats navigation menu personal tools not logged talk contributions create account log namespaces article talk variants views read edit view history more search navigation main page contents featured content current events random article donate wikipedia wikipedia store interaction help about wikipedia community portal recent changes contact page tools what links here related changes upload file special pages permanent link page information wikidata item cite this page print/export create book download pdf printable version languages deutsch español français italiano עברית lietuvių nederlands 日本語 polski português русский edit links this page was last modified on november at text available under creative commons attribution-sharealike license additional terms may apply by using this site you agree terms use privacy policy wikipedia® registered trademark wikimedia foundation inc non-profit organization privacy policy about wikipedia disclaimers contact wikipedia developers cookie statement mobile view 