anonymous function from wikipedia free encyclopedia jump navigation search computer programming anonymous function function literal lambda abstraction function definition that not bound identifier anonymous functions are often arguments being passed higher-order functions used for constructing result higher-order function that needs return function if function only used once limited number times anonymous function may be syntactically lighter than using named function anonymous functions are ubiquitous functional programming languages other languages with first-class functions where they fulfill same role for function type literals do for other data types anonymous functions originate work alonzo church his invention lambda calculus before electronic computers which all functions are anonymous several programming languages anonymous functions are introduced using keyword lambda anonymous functions are often referred lambdas lambda abstractions anonymous functions have been feature programming languages since lisp growing number modern programming languages support anonymous functions anonymous functions are form nested function allowing access variables scope containing function non-local variables this means anonymous functions need be implemented using closures unlike named nested functions they cannot be recursive without assistance fixpoint operator also termed anonymous fixpoint anonymous recursion binding them name contents uses o sorting o closures o currying o higher-order functions + map + filter + fold list languages examples o c non-standard extension + gcc + clang c c++ objective-c objective-c++ o c++ since c++11 o c o coldfusion markup language cfml o d o dart o delphi o elixir o erlang o go o haskell o haxe o java + java limitations o javascript o julia o lisp + common lisp + scheme + clojure o lua o wolfram language mathematica o matlab octave o maxima o ml + ocaml + f + standard ml o perl + perl + perl o php + php + php o prolog's dialects + logtalk + visual prolog o python o r o ruby o scala o smalltalk o swift o tcl o visual basic net see also references external links uses anonymous functions can be used for containing functionality that need not be named possibly for short-term use some notable examples include closures currying use anonymous functions matter style using them never only way solve problem each anonymous function could instead be defined named function called by name some programmers use anonymous functions encapsulate specific non-reusable code without littering code with lot little one-line normal functions some programming languages anonymous functions are commonly implemented for very specific purposes such binding events callbacks instantiating function for particular values which may be more efficient more readable less error-prone than calling more-generic named function all code following sections written python 2x not 3x sorting when attempting sort non-standard way may be easier contain comparison logic anonymous function instead creating named function most languages provide generic sort function that implements sort algorithm that will sort arbitrary objects this function usually accepts arbitrary comparison function that supplied two items function indicates if they are equal if one greater less than other usually indicated by returning negative number zero positive number consider sorting list strings by length string >>> = >>> asortlambda xy cmplenx leny >>> printa anonymous function this example lambda expression lambda xy cmp anonymous function accepts two arguments x y returns comparison between them using built-in function cmp another example would be sorting items list by name their class python everything has class >>> = >>> asortlambda xy cmpxclassname yclassname >>> printa note that has class name float has class name int 'number' has class name str sorted order float int then str closures main article closure computer science closures are functions evaluated environment containing bound variables following example binds variable threshold anonymous function that compares input threshold def compthreshold return lambda x x >> funca = comp10 >>> funcb = comp20 >>> print funca5 funca8 funca13 funca21 true true false false >>> print funcb5 funcb8 funcb13 funcb21 true true true false would be impractical create function for every possible comparison function may be too inconvenient keep threshold around for further use regardless reason why closure used anonymous function entity that contains functionality that does comparing currying main article currying currying process changing function so that takes fewer inputs this case transforming function that performs division by any integer into one that performs division by set integer >>> def dividex y return x / y >>> def divisord return lambda x dividex d >>> half = divisor2 >>> third = divisor3 >>> print half32 third32 >>> print half40 third40 while use anonymous functions perhaps not common with currying still can be used above example function divisor generates functions with specified divisor functions half third curry divide function with fixed divisor divisor function also forms closure by binding d variable higher-order functions python 2x includes several functions that take anonymous functions argument this section describes some them map main article map higher-order function map function performs function call on each element list following example squares every element array with anonymous function >>> = >>> print maplambda x xx anonymous function accepts argument multiplies by itself squares above form discouraged by creators language who maintains that form presented below has same meaning more aligned with philosophy language >>> = >>> print filter main article filter higher-order function filter function returns all elements from list that evaluate true when passed certain function >>> = >>> print filterlambda x x % == anonymous function checks if argument passed even same with map form below considered more appropriate >>> = >>> print fold main article fold higher-order function fold/reduce function runs over all elements list usually left-to-right accumulating value goes common use this combine all elements list into one value for example >>> = >>> print reducelambda xy xy this performs × × × × = {\displaystyle \left\left\left1\times 2\right\times 3\right\times 4\right\times 5=120} anonymous function here multiplication two arguments result fold need not be one value instead both map filter can be created using fold map value that accumulated new list containing results applying function each element original list filter value that accumulated new list containing only those elements that match given condition list languages following list programming languages that support unnamed anonymous functions fully partly some variant not at all this table shows some general trends first languages that do not support anonymous functions c pascal object pascal are all conventional statically typed languages however statically typed languages can support anonymous functions for example ml languages are statically typed fundamentally include anonymous functions delphi dialect object pascal has been extended support anonymous functions second languages that treat functions first-class functions dylan haskell javascript lisp ml perl python ruby scheme generally have anonymous function support so that functions can be defined passed around easily other data types however new c++11 standard adds them c++ even though this conventional statically typed language this list incomplete you can help by expanding language support notes actionscript y ada n expression functions are part ada2012 algol y brainfuck n bash y library has been made support anonymous functions bash c n support provided clang along with llvm compiler-rt lib gcc support given for macro implementation which enables possibility use details see below c y c++ y c++11 standard cfml y railo coldfusion clojure y cobol n micro focus's non-standard managed cobol dialect supports lambdas which are called anonymous delegates/methods curl y d y dart y delphi y dylan y eiffel y elixir y erlang y f y factor y quotations support this fortran n frink y go y gosu y groovy y haskell y haxe y java y supported java see java limitations section below for details javascript y julia y lisp y logtalk y lua y mumps n mathematica y maple y matlab y maxima y ocaml y octave y object pascal y delphi dialect object pascal supports anonymous functions formally anonymous methods natively since delphi oxygene object pascal dialect also supports them objective-c mac os x 106+ y called blocks addition objective-c blocks can also be used on c c++ when programming on apple's platform pascal n perl y php y php true anonymous functions are supported formerly only partial anonymous functions were supported which worked much like c's implementation pl/i n python y python supports anonymous functions through lambda syntax which supports only expressions not statements r y racket y rexx n rpg n ruby y ruby's anonymous functions inherited from smalltalk are called blocks rust y scala y scheme y smalltalk y smalltalk's anonymous functions are called blocks standard ml y swift y swift's anonymous functions are called closures typescript y tcl y vala y visual basic net v9 y visual prolog v y wolfram language y examples numerous languages support anonymous functions something similar c non-standard extension anonymous function not supported by standard c programming language but supported by some c dialects such gcc clang gcc gnu compiler collection gcc supports anonymous functions mixed by nested functions statement expressions has form { returntype anonymousfunctionsname parameters { functionbody } anonymousfunctionsname } following example works only with gcc because how macros are expanded lbody cannot contain any commas outside parentheses gcc treats comma delimiter between macro arguments argument lrettype can be removed if typeof available example below using typeof on array would return testtype which can be dereferenced for actual value if needed include // this definition anonymous function / define lambdalrettype larguments lbody \ { \ lrettype lanonymousfunctionsname larguments \ lbody \ &lanonymousfunctionsname \ } define foreachinarrayfearrtype fearr fefnbody \ { \ int i=0 \ fori include int mainvoid { void ^countloop = ^{ for int i = i returntype { functionbody } example lambda function defined follows int x int y -> int { return x + y } c++11 also supports closures closures are defined between square brackets declaration lambda expression mechanism allows these variables be captured by value by reference following table demonstrates this //no variables defined attempting use any external variables lambda error //x captured by value y captured by reference //any external variable implicitly captured by reference if used //any external variable implicitly captured by value if used //x explicitly captured by value other variables will be captured by reference //z explicitly captured by reference other variables will be captured by value variables captured by value are constant by default adding mutable after parameter list makes them non-constant following two examples demonstrate use lambda expression stdvector somelist{ } int total = stdforeachbeginsomelist endsomelist int x { total += x } this computes total all elements list variable total stored part lambda function's closure since reference stack variable total can change its value stdvector somelist{ } int total = int value = stdforeachbeginsomelist endsomelist int x { total += x value this->somefunc } this will cause total be stored reference but value will be stored copy capture this special can only be captured by value not by reference this can only be captured if closest enclosing function non-static member function lambda will have same access member that created terms protected/private members if this captured either explicitly implicitly then scope enclosed class members also tested accessing members this does not need explicit use this-> syntax specific internal implementation can vary but expectation that lambda function that captures everything by reference will store actual stack pointer function created rather than individual references stack variables however because most lambda functions are small local scope they are likely candidates for inlining thus need no added storage for references if closure object containing references local variables invoked after innermost block scope its creation behaviour undefined lambda functions are function objects implementation-dependent type this type's name only available compiler if user wishes take lambda function parameter type must be template type they must create stdfunction similar object capture lambda value use auto keyword can help store lambda function auto mylambdafunc = int x { // } auto myonheaplambdafunc = new autoint x { // } here example storing anonymous functions variables vectors arrays passing them named parameters include include include double evalstdfunction f double x = { return fx } int main { stdfunction f0 = double x{return 1} auto f1 = double x{return x} decltypef0 fa = {f0f1double x{return xx}} stdvector fv = {f0f1} fvpushback double x{return xx} forint i=0i section for more information // first int x' type // second int return type // /> func foo = x => xx consolewritelinefoo7 while function anonymous cannot be assigned implicitly typed variable because lambda syntax may be used for denoting anonymous function expression tree choice cannot automatically be decided by compiler eg this does not work // will not compile var foo = int x => xx however lambda expression can take part type inference can be used method argument eg use anonymous functions with map capability available with systemcollectionsgenericlist convertall method // initialize list var values = new list { } // map anonymous function over all elements list return new list var foo = valuesconvertalld => dd // result foo variable type systemcollectionsgenericlist prior versions c had more limited support for anonymous functions c v10 introduced february with net framework v10 provided partial anonymous function support through use delegates this construct somewhat similar php delegates c delegates are like function pointers that refer explicitly named method within class but unlike php name unneeded at time delegate used c v20 released november with net framework v20 introduced concept anonymous methods way write unnamed inline statement blocks that can be executed delegate invocation c continues support these constructs but also supports lambda expression construct this example will compile c exhibits three forms public class testdriver { delegate int squaredelegateint d static int squareint d { return dd } static void mainstring args { // c original delegate syntax needed // initializing with named method squaredelegate = new squaredelegatesquare systemconsolewritelinea3 // c delegate can be initialized with // inline code called anonymous method this // method takes int input parameter squaredelegate b = delegateint d { return dd } systemconsolewritelineb5 // c delegate can be initialized with // lambda expression lambda takes int returns int // type x inferred by compiler squaredelegate c = x => xx systemconsolewritelinec7 // c delegate that accepts one input // returns one output can also be implicitly declared with func type systemfunc d = x => xx systemconsolewritelined9 } } case c version c compiler takes code block anonymous function creates static private function internally function gets generated name course this generated name based on name method which delegate declared but name not exposed application code except by using reflection case c version same mechanism applies coldfusion markup language cfml fn = function{ // statements } cfml supports any statements within function's definition not simply expressions cfml supports recursive anonymous functions factorial = functionn{ return n > n factorialn-1 } cfml anonymous functions implement closure d d uses inline delegates implement anonymous functions full syntax for inline delegate returntype delegatearguments{/body/} if unambiguous return type keyword delegate can be omitted x{return xx} delegate x{return xx} // if more verbosity needed int x{return xx} // if parameter type cannot be inferred delegate int x{return xx} // ditto delegate doubleint x{return xx} // if return type must be forced manually since version d allocates closures on heap unless compiler can prove unnecessary scope keyword can be used for forcing stack allocation since version possible use shorthand notation x => xx int x => xx xy => xy int x int y => xy anonymous function can be assigned variable used like this auto sqr = double x{return xx} double y = sqr4 dart dart supports anonymous functions var sqr = x => x x printsqr5 printx => x x5 delphi delphi introduced anonymous functions since version program demo type tsimpleprocedure = reference procedure tsimplefunction = reference functionx string integer var x1 tsimpleprocedure y1 tsimplefunction begin x1 = procedure begin writeln'hello world' end x1 //invoke anonymous method just defined y1 = functionx string integer begin result = lengthx end writelny1'bar' end elixir elixir uses closure fn for anonymous functions sum = fna b -> + b end sum4 => square = fnx -> x x end enummap square => erlang erlang uses syntax for anonymous functions similar that named functions % anonymous function bound square variable square = funx -> x x end % named function with same functionality squarex -> x x go go supports anonymous functions foo = funcx int int { return x x } fmtprintlnfoo10 haskell haskell uses concise syntax for anonymous functions lambda expressions \x -> x x lambda expressions are fully integrated with type inference engine support all syntax features ordinary functions except for use multiple definitions for pattern-matching since argument list only specified once map \x -> x x -- returns following are all equivalent f x y = x + y f x = \y -> x + y f = \x y -> x + y haxe haxe anonymous functions are called lambda use syntax functionargument-list expression var f = functionx return xx f8 // functionxy return x+y56 // java java supports anonymous functions named lambda expressions starting with jdk lambda expression consists comma separated list formal parameters enclosed parentheses arrow token -> body data types parameters can always be omitted can parentheses if there only one parameter body can consist one statement statement block // with no parameter -> systemoutprintlnhello world // with one parameter this example identity function -> // with one expression b -> + b // with explicit type information long id string name -> id + id + name + name // with code block b -> { return + b } // with multiple statements lambda body needs code block // this example also includes two nested lambda expressions first one also closure id defaultprice -> { optional product = productliststreamfilterp -> pgetid == idfindfirst return productmapp -> pgetpriceorelsedefaultprice } lambda expressions are converted functional interfaces defined interfaces that contain only one abstract method addition one more default static methods following example public class calculator { interface integermath { int operationint int b default integermath swap { return b -> operationb } } private static int applyint int b integermath op { return opoperationa b } public static void mainstring args { integermath addition = b -> + b integermath subtraction = b -> - b systemoutprintln40 + = + apply40 addition systemoutprintln20 - = + apply20 subtraction systemoutprintln10 - = + apply20 subtractionswap } } this example functional interface called integermath declared lambda expressions that implement integermath are passed apply method be executed default methods like swap define methods on functions java introduced another mechanism named method reference operator create lambda on existing method method reference doesn't indicate number types arguments because those are extracted from abstract method functional interface intbinaryoperator sum = integersum example above functional interface intbinaryoperator declares abstract method int applyasintint int so compiler looks for method int sumint int class javalanginteger java limitations java lambdas have following limitations lambdas can throw checked exceptions but such lambdas will not work with interfaces used by collection api variables that are in-scope where lambda declared may only be accessed inside lambda if they are effectively final ie if variable not mutated inside outside lambda scope javascript javascript/ecmascript supports anonymous functions alertfunctionx{ return xx }10 es6 alertx => xx10 this construct often used bookmarklets for example change title current document visible its window's title bar its url following bookmarklet may seem work javascriptdocumenttitle=locationhref however assignment statement returns value url itself many browsers actually create new page display this value instead anonymous function that does not return value can be used javascriptfunction{documenttitle=locationhref} function statement first outer pair parentheses declares anonymous function which then executed when used with last pair parentheses this almost equivalent following which populates environment with f unlike anonymous function javascriptvar f = function{documenttitle=locationhref} f use void avoid new pages for arbitrary anonymous functions javascriptvoidfunction{return documenttitle=locationhref} just javascriptvoiddocumenttitle=locationhref javascript has syntactic subtleties for semantics defining invoking evaluating anonymous functions these subliminal nuances are direct consequence evaluation parenthetical expressions following constructs which are called immediately-invoked function expression illustrate this function{ } function{ } representing function{ } by f form constructs are parenthetical within parenthetical f parenthetical applied parenthetical f note general syntactic ambiguity parenthetical expression parenthesized arguments function parentheses around formal parameters function definition particular javascript defines comma operator context parenthetical expression no mere coincidence that syntactic forms coincide for expression function's arguments ignoring function formal parameter syntax if f not identified constructs above they become first provides no syntactic hint any resident function but second must evaluate first parenthetical function be legal javascript aside for instance 's could be {}42abcfunction{} long expression evaluates function also function object instance likewise objects are function instances object literal notation brackets {} for braced code are used when defining function this way opposed using new function very broad non-rigorous sense especially since global bindings are compromised arbitrary sequence braced javascript statements {stuff} can be considered be fixed point function{ function{ { function{stuff} } } } more correctly but with caveats function{stuff} ~= afixedpointof function{ return function{ return { return function{stuff} } } } note implications anonymous function javascript fragments that follow function{ } without surrounding 's generally not legal f=function{ } does not forget f globally unlike function f{ } performance metrics analyze space time complexities function calls call stack etc javascript interpreter engine implement easily with these last anonymous function constructs from implications results possible deduce some engine's recursive versus iterative implementation details especially tail-recursion julia julia programming language anonymous functions are defined using syntax arguments->expression julia> f = x -> xx f8 julia> xy->x+y56 lisp lisp scheme support anonymous functions using lambda construct which reference lambda calculus clojure supports anonymous functions with fn special form reader syntax lambda arg arg arg common lisp common lisp has concept lambda expressions lambda expression written list with symbol lambda its first element list then contains argument list documentation declarations function body lambda expressions can be used inside lambda forms with special operator function function lambda arg do-something arg function can be abbreviated ' also macro lambda exists which expands into function form using sharp quote 'lambda arg do-something arg using lambda macro lambda arg do-something arg one typical use anonymous functions common lisp pass them higher-order functions like mapcar which applies function each element list returns list results mapcar 'lambda x x x '1 -> lambda form common lisp allows lambda expression be written function call lambda x y + sqrt x sqrt y anonymous functions common lisp can also later be given global names setf symbol-function 'sqr lambda x x x which allows us call using name sqr sqr scheme interestingly scheme's named functions simply syntactic sugar for anonymous functions bound names define somename arg do-something arg expands equivalent define somename lambda arg do-something arg clojure clojure supports anonymous functions through fn special form fn + x there also reader syntax define lambda + % %2 %3 defines anonymous function that takes three arguments sums them like scheme clojure's named functions are simply syntactic sugar for lambdas bound names defn func + arg expands def func fn + arg lua lua much scheme all functions are anonymous named function lua simply variable holding reference function object thus lua function foox return 2x end just syntactical sugar for foo = functionx return 2x end example using anonymous functions for reverse-order sorting tablesortnetwork functionab return aname > bname end wolfram language mathematica wolfram language programming language mathematica anonymous functions are important programming latter there are several ways create them below are few anonymous functions that increment number first most common '1' refers first argument '&' marks end anonymous function 1+1& function x \ x+1 so for instance f= 1^2&f 1+2& also mathematica has added construct make recursive anonymous functions symbol '0' refers entire function following function calculates factorial its input if]& matlab octave anonymous functions matlab octave are defined using syntax @argument-listexpression any variables that are not found argument list are inherited from enclosing scope > f = @xxx f8 ans = > @xyx+y56 % only works octave ans = maxima maxima anonymous functions are defined using syntax lambdaargument-listexpression f lambdaxx f8 lambdax+y56 ml various dialects ml support anonymous functions ocaml fun arg -> arg arg f f supports anonymous functions follows fun x -> x x // standard ml standard ml supports anonymous functions follows fn arg => arg arg perl perl perl supports anonymous functions follows sub { print i got called\n }-> fully anonymous called created my $squarer = sub { my $x = shift $x $x } assigned variable sub curry { my $sub @args = @ return sub { $sub->@args @ } return value another function } example currying perl programming sub sum { my $tot = $tot += $ for @ $tot } returns sum its arguments my $curried = curry \&sum print $curried->123 \n prints = + + + + + other constructs take bare blocks arguments which serve function similar lambda functions one parameter but don't have same parameter-passing convention functions -- @ not set my @squares = map { $ $ } map grep don't use 'sub' keyword my @square2 = map $ $ parentheses unneeded for one expression my @badexample = map { print for @ } values not passed like normal perl function perl perl all blocks even those associated with if while etc are anonymous functions block that not used rvalue executed immediately fully anonymous called created { say i got called } assigned variable my $squarer1 = -> $x { $x $x } 2a pointy block my $squarer2 = { $^x $^x } 2b twigil my $squarer3 = { my $x = shift @ $x $x } 2b perl style currying sub add $m $n { $m + $n } my $seven = add3 my $addone = &addassumingm => my $eight = $addone$seven php before php had no anonymous function support php php introduced createfunction which was initial anonymous function support this function call makes new randomly named function returns its name string $foo = createfunction'$x' 'return $x$x' $bar = createfunction\$x return \$x\$x echo $foo10 argument list function body must be single quotes dollar signs must be escaped otherwise php assumes $x means variable $x will substitute into string despite possibly not existing instead leaving $x string for functions with quotes functions with lots variables can get quite tedious ensure intended function body what php interprets each invocation createfunction makes new function which exists for rest program cannot be garbage collected using memory program irreversibly if this used create anonymous functions many times eg loop can cause problems such memory bloat php php added new class called closure magic method invoke that makes class instance invocable $x = $func = function$z { return $z = } echo $func$x // prints this example $func instance closure echo $func equivalent $func->invoke$z php mimics anonymous functions but does not support true anonymous functions because php functions are still not first-class objects php does support closures but variables must be explicitly indicated such $x = $func = function use&$x { $x = } $func echo $x // prints variable $x bound by reference so invocation $func modifies changes are visible outside function prolog's dialects logtalk logtalk uses following syntax for anonymous predicates lambda expressions {freevar1 freevar2 }/>>goal simple example with no free variables using list mapping predicate | - metamap>>y 2x ys ys = yes currying also supported above example can be written | - metamap>>>>y 2x ys ys = yes visual prolog anonymous functions general anonymous predicates were introduced visual prolog version anonymous predicates can capture values from context if created object member can also access object state by capturing this mkadder returns anonymous function which has captured argument x closure returned function function that adds x its argument clauses mkadderx = { y = x+y } python python supports simple anonymous functions through lambda form executable body lambda must be expression can't be statement which restriction that limits its utility value returned by lambda value contained expression lambda forms can be used anywhere ordinary functions can however these restrictions make very limited version normal function here example >>> foo = lambda x xx >>> printfoo10 general python convention encourages use named functions defined same scope one might typically use anonymous functions other languages this acceptable locally defined functions implement full power closures are almost efficient use lambda python this example built-in power function can be said have been curried >>> def makepown def fixedexponentpowx return powx n return fixedexponentpow >>> sqr = makepow2 >>> print sqr10 >>> cub = makepow3 >>> print cub10 r for more details on this topic see r programming language gnu r anonymous functions are defined using syntax functionargument-listexpression > f functionxyx+y56 ruby for more details on this topic see ruby programming language § blocks iterators ruby supports anonymous functions by using syntactical structure called block there are two data types for blocks ruby procs behave similarly closures whereas lambdas behave more analogous anonymous function when passed method block converted into proc some circumstances irbmain0010> example irbmain0020 purely anonymous functions using blocks irbmain0030 ex = => irbmain0040> exsortby { |x| x - xtoi } sort by fractional part ignoring integer part => irbmain0050> example irbmain0060 first-class functions explicit object proc - irbmain0070 ex = procnew { puts hello world } => irbmain0080> excall hello world => nil irbmain0090> example irbmain0100 function that returns lambda function object with parameters irbmain0110 def ismultipleofn irbmain0121> lambda{|x| x % n == 0} irbmain0131> end => nil irbmain0140> multiplefour = ismultipleof4 => irbmain0150> multiplefourcall16 => true irbmain0160> multiplefour => false scala scala anonymous functions use following syntax x int y int => x + y certain contexts like when anonymous function parameter being passed another function compiler can infer types parameters anonymous function they can be omitted syntax such contexts also possible use shorthand for anonymous functions using underscore character introduce unnamed parameters val list = list1 listreduceleft x y => x + y // here compiler can infer that types x y are both int // thus needs no type annotations on parameters anonymous function listreduceleft + // each underscore stands for new unnamed parameter anonymous function // this results even shorter equivalent anonymous function above smalltalk smalltalk anonymous functions are called blocks value returns swift swift anonymous functions are called closures syntax has following form { parameters -> returntype statement } for example { s1 string s2 string -> bool return s1 > s2 } for sake brevity expressiveness parameter types return type can be omitted if these can be inferred { s1 s2 return s1 > s2 } similarly swift also supports implicit return statements for one-statement closures { s1 s2 s1 > s2 } finally parameter names can be omitted well when omitted parameters are referenced using shorthand argument names consisting $ symbol followed by their position eg $0 $1 $2 etc { $0 > $1 } tcl tcl applying anonymous squaring function looks follows apply {x {expr {$x$x}}} returns this example involves two candidates for what means be function tcl most generic usually called command prefix if variable f holds such function then way perform function application fx would be {}$f $x where {} expansion prefix new tcl command prefix above example apply {x {expr {$x$x}}} command names can be bound command prefixes by means interp alias command command prefixes support currying command prefixes are very common tcl apis other candidate for function tcl usually called lambda appears {x {expr {$x$x}}} part above example this part which caches compiled form anonymous function but can only be invoked by being passed apply command lambdas do not support currying unless paired with apply form command prefix lambdas are rare tcl apis visual basic net visual basic net introduced anonymous functions through lambda form combined with implicit typing vb provides economical syntax for anonymous functions with python vbnet anonymous functions must be defined on one line they cannot be compound statements further anonymous function vbnet must truly be vbnet function - must return value dim foo = functionx x x consolewritelinefoo10 visual basicnet added support for multiline lambda expressions anonymous functions without return value for example function for use thread dim t new systemthreadingthreadsub for n integer = 'count consolewritelinen 'print each number next end sub tstart see also computer programming portal first-class function references higher order functions learnyouahaskellcom retrieved december fernandez maribel models computation introduction computability theory undergraduate topics computer science springer science & business media p isbn lambda calculus was introduced by alonzo church 1930s precise notation for theory anonymous functions lecture fixpoints recursion cs3110 spring data structures functional programming cornell university - computer science retrieved december bash lambda closure support whats new coldfusion managed cobol reference micro focus documentation micro focus retrieved february quotations - factor documentation retrieved december quotation anonymous function value denoting snippet code which can be used value called using fundamental combinators gosu documentation pdf retrieved march groovy documentation retrieved may järvi jaakko powell gary nd chapter boostlambda boost documentation boost retrieved december b java tutorials lambda expressions docsoraclecom programming lua - more about functions archived from original on may retrieved top page indicates this with php >= php anonymous predicates visual prolog language reference sosinski robert understanding ruby blocks procs lambdas reactiveio retrieved apply manual page retrieved external links anonymous methods - when should they be used blog about anonymous function delphi compiling lambda expressions scala vs java php anonymous functions php anonymous functions lambda functions various programming languages retrieved from https//enwikipediaorg/w/indexphptitle=anonymousfunction&oldid=749157356 categories data types functional programming lambda calculus subroutines hidden categories all wikipedia articles needing clarification wikipedia articles needing clarification from march incomplete lists from august articles with example code navigation menu personal tools not logged talk contributions create account log namespaces article talk variants views read edit view history more search navigation main page contents featured content current events random article donate wikipedia wikipedia store interaction help about wikipedia community portal recent changes contact page tools what links here related changes upload file special pages permanent link page information wikidata item cite this page print/export create book download pdf printable version languages български català deutsch eesti ελληνικά français italiano nederlands 日本語 polski русский simple english suomi українська 中文 edit links this page was last modified on november at text available under creative commons attribution-sharealike license additional terms may apply by using this site you agree terms use privacy policy wikipedia® registered trademark wikimedia foundation inc non-profit organization privacy policy about wikipedia disclaimers contact wikipedia developers cookie statement mobile view 