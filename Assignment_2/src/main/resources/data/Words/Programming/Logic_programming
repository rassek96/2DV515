logic programming from wikipedia free encyclopedia jump navigation search programming paradigms action agent-oriented array-oriented automata-based concurrent computing o relativistic programming data-driven declarative contrast imperative o constraint + constraint logic concurrent constraint logic o dataflow + flow-based + cell-oriented spreadsheets + reactive o functional + functional logic + purely functional o logic + abductive logic + answer set + concurrent logic + functional logic + inductive logic dynamic end-user programming event-driven o service-oriented o time-driven expression-oriented feature-oriented function-level contrast value-level generic imperative contrast declarative o literate o procedural inductive programming language-oriented o natural language programming o discipline-specific o domain-specific o grammar-oriented + dialecting o intentional metaprogramming o automatic o reflective + attribute-oriented o homoiconic o template + policy-based non-structured contrast structured o array nondeterministic parallel computing o process-oriented point-free style o concatenative semantic structured contrast non-structured o block-structured o modular contrast monolithic o object-oriented + actor-based + class-based + concurrent + prototype-based + by separation concerns aspect-oriented role-oriented subject-oriented o recursive value-level contrast function-level probabilistic concept v t e logic programming programming paradigm based on formal logic program written logic programming language set sentences logical form expressing facts rules about some problem domain major logic programming language families include prolog answer set programming asp datalog all these languages rules are written form clauses h - b1 … bn are read declaratively logical implications h if b1 … bn h called head rule b1 … bn called body facts are rules that have no body are written simplified form h simplest case which h b1 … bn are all atomic formulae these clauses are called definite clauses horn clauses however there exist many extensions this simple case most important one being case which conditions body clause can also be negations atomic formulae logic programming languages that include this extension have knowledge representation capabilities non-monotonic logic asp datalog logic programs have only declarative reading their execution performed by means proof procedure model generator whose behaviour not meant be under control programmer however prolog family languages logic programs also have procedural interpretation goal-reduction procedures solve h solve b1 solve bn consider for example following clause falliblex - humanx based on example used by terry winograd illustrate programming language planner clause logic program can be used both procedure test whether x fallible by testing whether x human procedure find x that fallible by finding x that human even facts have procedural interpretation for example clause humansocrates can be used both procedure show that socrates human procedure find x that human by assigning socrates x declarative reading logic programs can be used by programmer verify their correctness moreover logic-based program transformation techniques can also be used transform logic programs into logically equivalent programs that are more efficient prolog family logic programming languages programmer can also use known problem-solving behaviour execution mechanism improve efficiency programs contents history concepts o logic control o problem solving o negation failure o knowledge representation variants extensions o prolog o abductive logic programming o metalogic programming o constraint logic programming o concurrent logic programming o concurrent constraint logic programming o inductive logic programming o higher-order logic programming o linear logic programming o object-oriented logic programming o transaction logic programming see also references o general introductions o other sources further reading external links history use mathematical logic represent execute computer programs also feature lambda calculus developed by alonzo church 1930s however first proposal use clausal form logic for representing computer programs was made by cordell green this used axiomatization subset lisp together with representation input-output relation compute relation by simulating execution program lisp foster elcock's absys on other hand employed combination equations lambda calculus assertional programming language which places no constraints on order which operations are performed logic programming its present form can be traced back debates late 1960s early 1970s about declarative versus procedural representations knowledge artificial intelligence advocates declarative representations were notably working at stanford associated with john mccarthy bertram raphael cordell green edinburgh with john alan robinson academic visitor from syracuse university pat hayes robert kowalski advocates procedural representations were mainly centered at mit under leadership marvin minsky seymour papert although was based on proof methods logic planner developed at mit was first language emerge within this proceduralist paradigm planner featured pattern-directed invocation procedural plans from goals ie goal-reduction backward chaining from assertions ie forward chaining most influential implementation planner was subset planner called micro-planner implemented by gerry sussman eugene charniak terry winograd was used implement winograd's natural-language understanding program shrdlu which was landmark at that time cope with very limited memory systems at time planner used backtracking control structure so that only one possible computation path had be stored at time planner gave rise programming languages qa-4 popler conniver qlisp concurrent language ether hayes kowalski edinburgh tried reconcile logic-based declarative approach knowledge representation with planner's procedural approach hayes developed equational language golux which different procedures could be obtained by altering behavior theorem prover kowalski on other hand developed sld resolution variant sl-resolution showed how treats implications goal-reduction procedures kowalski collaborated with colmerauer marseille who developed these ideas design implementation programming language prolog association for logic programming was founded promote logic programming prolog gave rise programming languages alf fril gödel mercury oz ciao visual prolog xsb λprolog well variety concurrent logic programming languages constraint logic programming languages datalog concepts logic control main article declarative programming logic programming can be viewed controlled deduction important concept logic programming separation programs into their logic component their control component with pure logic programming languages logic component alone determines solutions produced control component can be varied provide alternative ways executing logic program this notion captured by slogan algorithm = logic + control where logic represents logic program control represents different theorem-proving strategies problem solving simplified propositional case which logic program top-level atomic goal contain no variables backward reasoning determines and-or tree which constitutes search space for solving goal top-level goal root tree given any node tree any clause whose head matches node there exists set child nodes corresponding sub-goals body clause these child nodes are grouped together by alternative sets children corresponding alternative ways solving node are grouped together by any search strategy can be used search this space prolog uses sequential last-in-first-out backtracking strategy which only one alternative one sub-goal considered at time other search strategies such parallel search intelligent backtracking best-first search find optimal solution are also possible more general case where sub-goals share variables other strategies can be used such choosing subgoal that most highly instantiated that sufficiently instantiated so that only one procedure applies such strategies are used for example concurrent logic programming negation failure main article negation failure for most practical applications well for applications that require non-monotonic reasoning artificial intelligence horn clause logic programs need be extended normal logic programs with negative conditions clause normal logic program has form h - a1 … not b1 … not bn read declaratively logical implication h if a1 … not b1 … not bn where h all ai bi are atomic formulas negation negative literals not bi commonly referred negation failure because most implementations negative condition not bi shown hold by showing that positive condition bi fails hold for example canflyx - birdx not abnormalx abnormalx - woundedx birdjohn birdmary woundedjohn given goal finding something that can fly - canflyx there are two candidate solutions which solve first subgoal birdx namely x = john x = mary second subgoal not abnormaljohn first candidate solution fails because woundedjohn succeeds therefore abnormaljohn succeeds however second subgoal not abnormalmary second candidate solution succeeds because woundedmary fails therefore abnormalmary fails therefore x = mary only solution goal micro-planner had construct called thnot which when applied expression returns value true if only if evaluation expression fails equivalent operator normally built-in modern prolog's implementations normally written notgoal \+ goal where goal some goal proposition be proved by program this operator differs from negation first-order logic negation such \+ x == fails when variable x has been bound atom but succeeds all other cases including when x unbound this makes prolog's reasoning non-monotonic x = \+ x == always fails while \+ x == x = can succeed binding x depending on whether x was initially bound note that standard prolog executes goals left-to-right order logical status negation failure was unresolved until keith clark showed that under certain natural conditions correct sometimes complete implementation classical negation with respect completion program completion amounts roughly regarding set all program clauses with same predicate on left hand side say h - body1 … h - bodyk definition predicate h iff body1 … bodyk where iff means if only if writing completion also requires explicit use equality predicate inclusion set appropriate axioms for equality however implementation negation by failure needs only if-halves definitions without axioms equality for example completion program above canflyx iff birdx not abnormalx abnormalx iff woundedx birdx iff x = john x = mary x = x not john = mary not mary = john notion completion closely related mccarthy's circumscription semantics for default reasoning closed world assumption alternative completion semantics negation failure can also be interpreted epistemically stable model semantics answer set programming this interpretation notbi means literally that bi not known not believed epistemic interpretation has advantage that can be combined very simply with classical negation extended logic programming formalise such phrases contrary can not be shown where contrary classical negation can not be shown epistemic interpretation negation failure knowledge representation fact that horn clauses can be given procedural interpretation vice versa that goal-reduction procedures can be understood horn clauses + backward reasoning means that logic programs combine declarative procedural representations knowledge inclusion negation failure means that logic programming kind non-monotonic logic despite its simplicity compared with classical logic this combination horn clauses negation failure has proved be surprisingly expressive for example provides natural representation for common-sense laws cause effect formalised by both situation calculus event calculus has also been shown correspond quite naturally semi-formal language legislation particular prakken sartor credit representation british nationality act logic program with being hugely influential for development computational representations legislation showing how logic programming enables intuitively appealing representations that can be directly deployed generate automatic inferences variants extensions prolog main article prolog programming language prolog was developed by alain colmerauer emerged from collaboration between colmerauer marseille robert kowalski edinburgh colmerauer was working on natural language understanding using logic represent semantics using resolution for question-answering during summer colmerauer kowalski discovered that clausal form logic could be used represent formal grammars that resolution theorem provers could be used for parsing they observed that some theorem provers like hyper-resolution behave bottom-up parsers others like sl-resolution behave top-down parsers was following summer that kowalski again working with colmerauer developed procedural interpretation implications this dual declarative/procedural interpretation later became formalised prolog notation h - b1 … bn which can be read used both declaratively procedurally also became clear that such clauses could be restricted definite clauses horn clauses where h b1 … bn are all atomic predicate logic formulae that sl-resolution could be restricted generalised lush sld-resolution kowalski's procedural interpretation lush were described memo published colmerauer with philippe roussel used this dual interpretation clauses basis prolog which was implemented summer autumn first prolog program also written implemented marseille was french question-answering system use prolog practical programming language was given great momentum by development compiler by david warren edinburgh experiments demonstrated that edinburgh prolog could compete with processing speed other symbolic programming languages such lisp edinburgh prolog became de facto standard strongly influenced definition iso standard prolog abductive logic programming abductive logic programming extension normal logic programming that allows some predicates declared abducible predicates be open undefined clause abductive logic program has form h - b1 … bn a1 … where h atomic formula that not abducible all bi are literals whose predicates are not abducible ai are atomic formulas whose predicates are abducible abducible predicates can be constrained by integrity constraints which can have form false - b1 … bn where bi are arbitrary literals defined abducible atomic negated for example canflyx - birdx normalx false - normalx woundedx birdjohn birdmary woundedjohn where predicate normal abducible problem solving achieved by deriving hypotheses expressed terms abducible predicates solutions problems be solved these problems can be either observations that need be explained classical abductive reasoning goals be solved normal logic programming for example hypothesis normalmary explains observation canflymary moreover same hypothesis entails only solution x = mary goal finding something that can fly - canflyx abductive logic programming has been used for fault diagnosis planning natural language processing machine learning has also been used interpret negation failure form abductive reasoning metalogic programming because mathematical logic has long tradition distinguishing between object language metalanguage logic programming also allows metalevel programming simplest metalogic program so-called vanilla meta-interpreter solvetrue solveab- solveasolveb solvea- clauseabsolveb where true represents empty conjunction clauseab means there object-level clause form - b metalogic programming allows object-level metalevel representations be combined natural language can also be used implement any logic that specified by means inference rules metalogic used logic programming implement metaprograms which manipulate other programs databases knowledge bases axiomatic theories data constraint logic programming main article constraint logic programming constraint logic programming combines horn clause logic programming with constraint solving extends horn clauses by allowing some predicates declared constraint predicates occur literals body clauses constraint logic program set clauses form h - c1 … cn ◊ {\displaystyle \diamond } b1 … bn where h all bi are atomic formulas ci are constraints declaratively such clauses are read ordinary logical implications h if c1 … cn b1 … bn however whereas predicates heads clauses are defined by constraint logic program predicates constraints are predefined by some domain-specific model-theoretic structure theory procedurally subgoals whose predicates are defined by program are solved by goal-reduction ordinary logic programming but constraints are checked for satisfiability by domain-specific constraint-solver which implements semantics constraint predicates initial problem solved by reducing satisfiable conjunction constraints following constraint logic program represents toy temporal database john's history teacher teachesjohn hardware t - ≤ t t highly scalable commercial system ontobroker logtalk extends prolog programming language with support for objects protocols other oop concepts highly portable supports most standard-complaint prolog systems backend compilers transaction logic programming transaction logic extension logic programming with logical theory state-modifying updates has both model-theoretic semantics procedural one implementation subset transaction logic available flora-2 system other prototypes are also available see also boolean satisfiability problem constraint logic programming datalog fril functional programming fuzzy logic inductive logic programming logic computer science includes formal methods logic programming languages programming paradigm r++ reasoning system rule-based machine learning satisfiability references this article includes list references but its sources remain unclear because has insufficient inline citations please help improve this article by introducing more precise citations february learn how when remove this template message b t winograd understanding natural language cognitive psychology 1–191 doi101016/0010-02857290002-3 cordell green application theorem proving problem solving ijcai jm foster ew elcock absys incremental compiler for assertions introduction machine intelligence edinburgh u press pp 423–429 carl hewitt planner language for proving theorems robots ijcai pat hayes computation deduction proceedings 2nd mfcs symposium czechoslovak academy sciences pp 105–118 b robert kowalski predicate logic programming language memo department artificial intelligence edinburgh university also proceedings ifip congress stockholm north holland publishing co pp 569–574 robert kowalski donald kuehner linear resolution with selection function artificial intelligence vol pp 227–60 shapiro ehud family concurrent logic programming languages pdf international summer school on logic algebra computation also appeared shapiro e family concurrent logic programming languages acm computing surveys 413–510 doi101145/7255172555 rakowalski july algorithm=logic + control communications acm 424–436 doi 101145/359131359136 prakken h sartor g law logic review from argumentation perspective artificial intelligence 214-245 sergot mj sadri f kowalski ra kriwaczek f hammond p cory ht british nationality act logic program communications acm 370-386 shunichi uchida kazuhiro fuchi proceedings fgcs project evaluation workshop institute for new generation computer technology icot hewitt carl april inconsistency robustness for logic programs hal archives pp 21–26 retrieved november joshua hodas dale miller logic programming fragment intuitionistic linear logic information computation 327-365 naoki kobayashi akinori yonezawa asynchronous communication model based on linear logic formal aspects computing 279-294 general introductions baral c gelfond m logic programming knowledge representation pdf journal logic programming 19-20 73–148 doi 101016/0743-10669490025-6 robert kowalski early years logic programming kowalski r early years logic programming pdf communications acm 38–43 doi101145/3504335046 lloyd j w foundations logic programming 2nd edition springer-verlag other sources john mccarthy programs with common sense symposium on mechanization thought processes national physical laboratory teddington england d miller g nadathur f pfenning scedrov uniform proofs foundation for logic programming annals pure applied logic vol pp 125–157 ehud shapiro editor concurrent prolog mit press james slagle experiments with deductive question-answering program cacm december further reading carl hewitt procedural embedding knowledge planner ijcai carl hewitt repeated demise logic programming why will be reincarnated what went wrong why lessons from ai research applications technical report ss-06-08 aaai press march evgeny dantsin thomas eiter georg gottlob andrei voronkov complexity expressive power logic programming acm comput surv 374-425 ulf nilsson jan maluszynski logic programming prolog external links logic programming virtual library entry bibliographies on logic programming association for logic programming alp theory practice logic programming journal logic programming c++ with castor logic programming oz prolog development center racklog logic programming racket v t e types programming languages actor-based array aspect-oriented class-based concatenative concurrent data-structured dataflow declarative domain-specific dynamic esoteric event-driven extensible functional imperative logic macro metaprogramming+multi-paradigm object-based object-oriented pipeline procedural prototype-based reflective rule-based scripting synchronous templating assembly compiled interpreted machine low-level high-level very high-level first generation second generation third generation fourth generation fifth generation non-english-based visual v t e computable knowledge topics concepts alphabet human thought authority control automated reasoning commonsense knowledge commonsense reasoning computability formal system inference engine knowledge base knowledge-based systems knowledge engineering knowledge extraction knowledge representation knowledge retrieval library classification logic programming ontology personal knowledge base question answering semantic reasoner proposals implementations zairja ars magna essay towards real character philosophical language calculus ratiocinator & characteristica universalis dewey decimal classification begriffsschrift mundaneum logical atomism tractatus logico-philosophicus hilbert's program 1920s incompleteness theorem world brain memex general problem solver prolog cyc semantic web evi wolfram alpha watson siri knowledge graph wikidata cortana viv fiction engine gulliver's travels joe logic named joe librarian snow crash dr know ai artificial intelligence waterhouse baroque cycle see also logic machines fiction list fictional computers authority control lccn sh86003454 gnd 4195096-3 bnf cb12067891q data bne xx550687 retrieved from https//enwikipediaorg/w/indexphptitle=logicprogramming&oldid=749678248 categories introductions logic programming programming paradigms hidden categories all articles with unsourced statements articles with unsourced statements from july all articles with minor pov problems articles with minor pov problems from august articles lacking in-text citations from february all articles lacking in-text citations wikipedia articles with lccn identifiers wikipedia articles with gnd identifiers wikipedia articles with bnf identifiers navigation menu personal tools not logged talk contributions create account log namespaces article talk variants views read edit view history more search navigation main page contents featured content current events random article donate wikipedia wikipedia store interaction help about wikipedia community portal recent changes contact page tools what links here related changes upload file special pages permanent link page information wikidata item cite this page print/export create book download pdf printable version languages العربية বাংলা български bosanski čeština deutsch eesti español فارسی français gaeilge galego 한국어 hrvatski ido italiano עברית bahasa melayu nederlands 日本語 polski português русиньскый русский shqip simple english српски / srpski suomi svenska ไทย türkçe українська tiếng việt 中文 edit links this page was last modified on november at text available under creative commons attribution-sharealike license additional terms may apply by using this site you agree terms use privacy policy wikipedia® registered trademark wikimedia foundation inc non-profit organization privacy policy about wikipedia disclaimers contact wikipedia developers cookie statement mobile view 