halting problem from wikipedia free encyclopedia jump navigation search computability theory halting problem problem determining from description arbitrary computer program input whether program will finish running continue run forever alan turing proved that general algorithm solve halting problem for all possible program-input pairs cannot exist key part proof was mathematical definition computer program which became known turing machine halting problem undecidable over turing machines one first examples decision problem jack copeland attributes term halting problem martin davis contents background importance consequences representation set sketch proof proof corollary uncomputability kolmogorov complexity common pitfalls formalization relationship with gödel's incompleteness theorems variants halting problem o halting on all inputs o recognizing partial solutions o generalized oracle machines history avoiding halting problem see also notes references external links background halting problem decision problem about properties computer programs on fixed turing-complete model computation ie all programs that can be written some given programming language that general enough be equivalent turing machine problem determine given program input program whether program will eventually halt when run with that input this abstract framework there are no resource limitations on amount memory time required for program's execution can take arbitrarily long use arbitrarily much storage space before halting question simply whether given program will ever halt on particular input for example pseudocode program while true continue does not halt rather goes on forever infinite loop on other hand program print hello world does halt while deciding whether these programs halt simple more complex programs prove problematic one approach problem might be run program for some number steps check if halts but if program does not halt unknown whether program will eventually halt run forever turing proved no algorithm exists that always correctly decides whether for given arbitrary program input program halts when run with that input essence turing's proof that any such algorithm can be made contradict itself therefore cannot be correct importance consequences halting problem historically important because was one first problems be proved undecidable turing's proof went press may whereas alonzo church's proof undecidability problem lambda calculus had already been published april church subsequently many other undecidable problems have been described typical method proving problem be undecidable with technique reduction do this sufficient show that if solution new problem were found could be used decide undecidable problem by transforming instances undecidable problem into instances new problem since we already know that no method can decide old problem no method can decide new problem either often new problem reduced solving halting problem note same technique used demonstrate that problem np complete only this case rather than demonstrating that there no solution demonstrates there no polynomial time solution assuming p ≠ np for example one such consequence halting problem's undecidability that there cannot be general algorithm that decides whether given statement about natural numbers true not reason for this that proposition stating that certain program will halt given certain input can be converted into equivalent statement about natural numbers if we had algorithm that could find truth value every statement about natural numbers could certainly find truth value this one but that would determine whether original program halts which impossible since halting problem undecidable rice's theorem generalizes theorem that halting problem unsolvable states that for any non-trivial property there no general decision procedure that for all programs decides whether partial function implemented by input program has that property partial function function which may not always produce result so used model programs which can either produce results fail halt for example property halt for input undecidable here non-trivial means that set partial functions that satisfy property neither empty set nor set all partial functions for example halts fails halt on input clearly true all partial functions so trivial property can be decided by algorithm that simply reports true also note that this theorem holds only for properties partial function implemented by program rice's theorem does not apply properties program itself for example halt on input within steps not property partial function that implemented by program—it property program implementing partial function very much decidable gregory chaitin has defined halting probability represented by symbol ω type real number that informally said represent probability that randomly produced program halts these numbers have same turing degree halting problem normal transcendental number which can be defined but cannot be completely computed this means one can prove that there no algorithm which produces digits ω although its first few digits can be calculated simple cases while turing's proof shows that there can be no general method algorithm determine whether algorithms halt individual instances that problem may very well be susceptible attack given specific algorithm one can often show that must halt for any input fact computer scientists often do just that part correctness proof but each proof has be developed specifically for algorithm at hand there no mechanical general way determine whether algorithms on turing machine halt however there are some heuristics that can be used automated fashion attempt construct proof which succeed frequently on typical programs this field research known automated termination analysis since negative answer halting problem shows that there are problems that cannot be solved by turing machine church–turing thesis limits what can be accomplished by any machine that implements effective methods however not all machines conceivable human imagination are subject church–turing thesis eg oracle machines open question whether there can be actual deterministic physical processes that long run elude simulation by turing machine particular whether any such hypothetical process could usefully be harnessed form calculating machine hypercomputer that could solve halting problem for turing machine amongst other things also open question whether any such unknown physical processes are involved working human brain whether humans can solve halting problem copeland p representation set conventional representation decision problems set objects possessing property question halting set k = { i x | program i halts when run on input x} represents halting problem this set recursively enumerable which means there computable function that lists all pairs i x contains however complement this set not recursively enumerable there are many equivalent formulations halting problem any set whose turing degree equals that halting problem such formulation examples such sets include { i | program i eventually halts when run with input } { i | there input x such that program i eventually halts when run with input x } sketch proof proof shows there no total computable function that decides whether arbitrary program i halts on arbitrary input x that following function h not computable penrose p 57–63 h i x = { if program i halts on input x otherwise {\displaystyle hix={\begin{cases}1&{\text{if }}{\text{ program }}i{\text{ halts on input }}x\\0&{\text{otherwise}}\end{cases}}} here program i refers i th program enumeration all programs fixed turing-complete model computation fij i j fii gi u u u possible values for total computable function f arranged array orange cells are diagonal values fii gi are shown at bottom u indicates that function g undefined for particular input value proof proceeds by directly establishing that every total computable function with two arguments differs from required function h this end given any total computable binary function f following partial function g also computable by some program e g i = { if f i i = undefined otherwise {\displaystyle gi={\begin{cases}0&{\text{if }}fii=0\\{\text{undefined}}&{\text{otherwise}}\end{cases}}} verification that g computable relies on following constructs their equivalents computable subprograms program that computes f subprogram program e duplication values program e computes inputs ii for f from input i for g conditional branching program e selects between two results depending on value computes for fii not producing defined result for example by looping forever returning value following pseudocode illustrates straightforward way compute g procedure computegi if fii == then return else loop forever because g partial computable there must be program e that computes g by assumption that model computation turing-complete this program one all programs on which halting function h defined next step proof shows that hee will not have same value fee follows from definition g that exactly one following two cases must hold fee = so ge = this case hee = because program e halts on input e fee ≠ so ge undefined this case hee = because program e does not halt on input e either case f cannot be same function h because f was arbitrary total computable function with two arguments all such functions must differ from h this proof analogous cantor's diagonal argument one may visualize two-dimensional array with one column one row for each natural number indicated table above value fij placed at column i row j because f assumed be total computable function any element array can be calculated using f construction function g can be visualized using main diagonal this array if array has at position ii then gi otherwise gi undefined contradiction comes from fact that there some column e array corresponding g itself now assume f was halting function h if ge defined ge = this case ge halts so f ee = but ge = only when fee = contradicting fee = similarly if ge not defined then halting function fee = which leads ge = under g's construction this contradicts assumption that ge not being defined both cases contradiction arises therefore any arbitrary computable function f cannot be halting function h proof corollary uncomputability kolmogorov complexity undecidability halting problem also follows from fact that kolmogorov complexity not computable if halting problem were decidable would be possible construct program that generated programs increasing length running those that halt comparing their final outputs with string parameter until one matched which must happen eventually any string can be generated by program that contains data just lists length matching generated program would then be kolmogorov complexity parameter since all shorter programs were proven not output desired string common pitfalls difficulty halting problem lies requirement that decision procedure must work for all programs inputs particular program either halts on given input does not halt consider one algorithm that always answers halts another that always answers doesn't halt for any specific program input one these two algorithms answers correctly even though nobody may know which one yet neither algorithm solves halting problem generally there are programs interpreters that simulate execution whatever source code they are given such programs can demonstrate that program does halt if this case interpreter itself will eventually halt its simulation which shows that original program halted however interpreter will not halt if its input program does not halt so this approach cannot solve halting problem stated does not successfully answer doesn't halt for programs that do not halt halting problem theoretically decidable for linear bounded automata lbas deterministic machines with finite memory machine with finite memory has finite number states thus any deterministic program on must eventually either halt repeat previous state any finite-state machine if left completely itself will fall eventually into perfectly periodic repetitive pattern duration this repeating pattern cannot exceed number internal states machine italics original minsky p minsky warns us however that machines such computers with eg million small parts each with two states will have at least possible states this followed by about three hundred thousand zeroes even if such machine were operate at frequencies cosmic rays aeons galactic evolution would be nothing compared time journey through such cycle minsky p minsky exhorts reader be suspicious—although machine may be finite finite automata have number theoretical limitations magnitudes involved should lead one suspect that theorems arguments based chiefly on mere finiteness state diagram may not carry great deal significance minsky p can also be decided automatically whether nondeterministic machine with finite memory halts on none some all possible sequences nondeterministic decisions by enumerating states after each possible decision formalization his original proof turing formalized concept algorithm by introducing turing machines however result no way specific them applies equally any other model computation that equivalent its computational power turing machines such markov algorithms lambda calculus post systems register machines tag systems what important that formalization allows straightforward mapping algorithms some data type that algorithm can operate upon for example if formalism lets algorithms define functions over strings such turing machines then there should be mapping these algorithms strings if formalism lets algorithms define functions over natural numbers such computable functions then there should be mapping algorithms natural numbers mapping strings usually most straightforward but strings over alphabet with n characters can also be mapped numbers by interpreting them numbers n-ary numeral system relationship with gödel's incompleteness theorems concepts raised by gödel's incompleteness theorems are very similar those raised by halting problem proofs are quite similar fact weaker form first incompleteness theorem easy consequence undecidability halting problem this weaker form differs from standard statement incompleteness theorem by asserting that complete consistent sound axiomatization all statements about natural numbers unachievable sound part weakening means that we require axiomatic system question prove only true statements about natural numbers more general statement incompleteness theorems does not require soundness assumption this kind weaker form theorem can be proven from undecidability halting problem follows assume that we have consistent complete axiomatization all true first-order logic statements about natural numbers then we can build algorithm that enumerates all these statements this means that there algorithm nn that given natural number n computes true first-order logic statement about natural numbers such that for all true statements there at least one n such that nn yields that statement now suppose we want decide whether algorithm with representation halts on input i by using kleene's t predicate we can express statement halts on input i statement ha i language arithmetic since axiomatization complete follows that either there n such that nn = ha i there n' such that nn' = ¬ ha i so if we iterate over all n until we either find ha i its negation we will always halt this means that this gives us algorithm decide halting problem since we know that there cannot be such algorithm follows that assumption that there consistent complete axiomatization all true first-order logic statements about natural numbers must be false variants halting problem many variants halting problem can be found computability textbooks eg sipser davis minsky hopcroft ullman börger typically their undecidability follows by reduction from standard halting problem however some them have higher degree unsolvability next two examples are typical halting on all inputs universal halting problem also known recursion theory totality problem determining whether given computer program will halt for every input name totality comes from equivalent question whether computed function total this problem not only undecidable halting problem but highly undecidable terms arithmetical hierarchy π {\displaystyle \pi {2}^{0}} -complete this means particular that cannot be decided even with oracle for halting problem recognizing partial solutions there are many programs that for some inputs return correct answer halting problem while for other inputs they do not return answer at all however problem ″given program p partial halting solver″ sense described at least hard halting problem see this assume that there algorithm phsr ″partial halting solver recognizer″ do that then can be used solve halting problem follows test whether input program x halts on y construct program p that on input xy reports true diverges on all other inputs then test p with phsr above argument reduction halting problem phs recognition same manner harder problems such halting on all inputs can also be reduced implying that phs recognition not only undecidable but higher arithmetical hierarchy specifically π {\displaystyle \pi {2}^{0}} -complete generalized oracle machines see also turing jump machine with oracle for halting problem can determine whether particular turing machines will halt on particular inputs but they cannot determine general if machines equivalent themselves will halt more generally there no oracle machines with oracle some problem that can determine general whether machine with oracle same problem will halt thus for any oracle o halting problem for oracle turing machines with oracle o not o-computable history further information history algorithms david hilbert poses his questions now known hilbert's problems at second international congress mathematicians paris these second was that proving consistency 'peano axioms' on which he had shown rigour mathematics depended hodges p davis' commentary davis p 1920–1921 emil post explores halting problem for tag systems regarding candidate for unsolvability absolutely unsolvable problems relatively undecidable propositions – account anticipation davis pp 340–433 its unsolvability was not established until much later by marvin minsky hilbert recasts his 'second problem' at bologna international congress reid pp 188–189 hodges claims he posed three questions ie was mathematics complete was mathematics consistent was mathematics decidable hodges p third question known entscheidungsproblem decision problem hodges p penrose p kurt gödel announces proof answer first two hilbert's questions at first he was only angry frustrated but then he began try deal constructively with problem gödel himself felt—and expressed thought his paper—that his work did not contradict hilbert's formalistic point view reid p gödel publishes on formally undecidable propositions principia mathematica related systems i reprinted davis p 5ff april alonzo church publishes unsolvable problem elementary number theory wherein he identifies what means for function be effectively calculable such function will have algorithm fact that algorithm has terminated becomes effectively known davis p church publishes first proof that entscheidungsproblem unsolvable note on entscheidungsproblem reprinted davis p october emil post's paper finite combinatory processes formulation i received post adds his process instruction c stop he called such process type if process determines terminates for each specific problem davis p 289ff alan turing's paper on computable numbers with application entscheidungsproblem reaches print january reprinted davis p turing's proof departs from calculation by recursive functions introduces notion computation by machine stephen kleene refers this one first examples decision problems proved unsolvable j barkley rosser observes essential equivalence effective method defined by gödel church turing rosser davis p informal exposition proofs gödel's theorem church's theorem paper stephen kleene states that setting up complete algorithmic theory what we do describe procedure which procedure necessarily terminates such manner that from outcome we can read definite answer 'yes' 'no' question 'is predicate value true' kleene chapter xiii computable functions includes discussion unsolvability halting problem for turing machines reformulates terms machines that eventually stop ie halt there no algorithm for deciding whether any given machine when started from any given situation eventually stops kleene p martin davis thinks likely that he first used term 'halting problem' series lectures that he gave at control systems laboratory at university illinois letter from davis copeland december footnote copeland pp 40ff avoiding halting problem many practical situations programmers try avoid infinite loops—they want every subroutine finish halt particular hard real-time computing programmers attempt write subroutines that are not only guaranteed finish halt but are guaranteed finish before given deadline sometimes these programmers use some general-purpose turing-complete programming language but attempt write restricted style—such misra c—that makes easy prove that resulting subroutines finish before given deadline other times these programmers apply rule least power—they deliberately use computer language that not quite fully turing-complete often language that guarantees that all subroutines are guaranteed finish such coq see also busy beaver generic-case complexity geoffrey k pullum gödel's incompleteness theorem kolmogorov complexity p versus np problem termination analysis worst-case execution time notes none his work did turing use word halting termination turing's biographer hodges does not have word halting words halting problem his index earliest known use words halting problem proof by davis p 70–71 theorem there exists turing machine whose halting problem recursively unsolvable related problem printing problem for simple turing machine z with respect symbol si davis adds no attribution for his proof so one infers that original with him but davis has pointed out that statement proof exists informally kleene p copeland p states that halting problem was so named appears first stated by martin davis often said that turing stated proved halting theorem 'on computable numbers' but strictly this not true b moore cristopher mertens stephan nature computation oxford university press pp 236–237 isbn stated without proof course notes for data compression - kolmogorov complexity pb miltersen p7 börger egon computability complexity logic north-holland p references alan turing on computable numbers with application entscheidungsproblem proceedings london mathematical society series volume pp 230–265 doi101112/plms/s2-421230 — alan turing on computable numbers with application entscheidungsproblem correction proceedings london mathematical society series volume pp 544–546 doi101112/plms/s2-436544 free online version both parts this epochal paper where turing defines turing machines formulates halting problem shows that well entscheidungsproblem unsolvable sipser michael section halting problem introduction theory computation second ed pws publishing pp 173–182 isbn 0-534-94728-x c2haltingproblem church alonzo unsolvable problem elementary number theory american journal mathematics 345–363 doi 102307/2371045 jstor b jack copeland ed essential turing seminal writings computing logic philosophy artificial intelligence artificial life plus secrets enigma clarendon press oxford university press oxford uk isbn 0-19-825079-7 davis martin undecidable basic papers on undecidable propositions unsolvable problems computable functions new york raven press turing's paper this volume papers include those by godel church rosser kleene post davis martin computability unsolvability new york mcgraw-hill alfred north whitehead bertrand russell principia mathematica cambridge at university press re problem paradoxes authors discuss problem set not be object any its determining functions particular introduction chap p difficulties which arise formal logic chap 2i vicious-circle principle p 37ff chap 2viii contradictions p 60ff martin davis what computation mathematics today lynn arthur steen vintage books random house wonderful little paper perhaps best ever written about turing machines for non-specialist davis reduces turing machine far-simpler model based on post's model computation discusses chaitin proof includes little biographies emil post julia robinson marvin minsky computation finite infinite machines prentice-hall inc nj see chapter section unsolvability halting problem excellent ie readable sometimes fun classic roger penrose emperor's new mind concerning computers minds laws physics oxford university press oxford england with corrections cf chapter algorithms turing machines over-complicated presentation see davis's paper for better model but thorough presentation turing machines halting problem church's lambda calculus john hopcroft jeffrey ullman introduction automata theory languages computation addison-wesley reading mass see chapter turing machines book centered around machine-interpretation languages np-completeness etc andrew hodges alan turing enigma simon schuster new york cf chapter spirit truth for history leading discussion his proof constance reid hilbert copernicus springer-verlag new york first published fascinating history german mathematics physics from 1880s through 1930s hundreds names familiar mathematicians physicists engineers appear its pages perhaps marred by no overt references few footnotes reid states her sources were numerous interviews with those who personally knew hilbert hilbert's letters papers edward beltrami what random chance order mathematics life copernicus springer-verlag new york nice gentle read for mathematically inclined non-specialist puts tougher stuff at end has turing-machine model discusses chaitin contributions ernest nagel james r newman godel’s proof new york university press wonderful writing about very difficult subject for mathematically inclined non-specialist discusses gentzen's proof on pages 96–97 footnotes appendices discuss peano axioms briefly gently introduce readers formal logic taylor booth sequential machines automata theory wiley new york cf chapter turing machines difficult book meant for electrical engineers technical specialists discusses recursion partial-recursion with reference turing machines halting problem has turing machine model references at end chapter catch most older books ie until including authors martin davis f c hennie h hermes s c kleene m minsky t rado various technical papers see note under busy-beaver programs busy beaver programs are described scientific american august also march p reference booth attributes them rado t1962 on non-computable functions bell systems tech j booth also defines rado's busy beaver problem problems chapter p david bolter turing’s man western culture computer age university north carolina press chapel hill for general reader may be dated has yet another very simple turing machine model stephen kleene introduction metamathematics north-holland chapter xiii computable functions includes discussion unsolvability halting problem for turing machines departure from turing's terminology circle-free nonhalting machines kleene refers instead machines that stop ie halt logical limitations machine ethics with consequences lethal autonomous weapons - paper discussed does halting problem mean no moral robots external links scooping loop snooper - poetic proof undecidability halting problem animated movie - animation explaining proof undecidability halting problem 2-minute proof 2nd-most important theorem 2nd millennium - proof only lines authority control gnd 4247732-3 retrieved from https//enwikipediaorg/w/indexphptitle=haltingproblem&oldid=751717376 categories theory computation computability theory mathematical problems undecidable problems introductions hidden categories wikipedia articles with gnd identifiers pages using isbn magic links navigation menu personal tools not logged talk contributions create account log namespaces article talk variants views read edit view history more search navigation main page contents featured content current events random article donate wikipedia wikipedia store interaction help about wikipedia community portal recent changes contact page tools what links here related changes upload file special pages permanent link page information wikidata item cite this page print/export create book download pdf printable version languages العربية български català čeština dansk deutsch ελληνικά español esperanto فارسی français 한국어 हिन्दी hrvatski italiano עברית nederlands 日本語 polski português русский simple english slovenčina српски / srpski suomi svenska ไทย türkçe українська tiếng việt 中文 edit links this page was last modified on november at text available under creative commons attribution-sharealike license additional terms may apply by using this site you agree terms use privacy policy wikipedia® registered trademark wikimedia foundation inc non-profit organization privacy policy about wikipedia disclaimers contact wikipedia developers cookie statement mobile view 