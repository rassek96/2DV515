functional programming from wikipedia free encyclopedia jump navigation search for subroutine-oriented programming see procedural programming programming paradigms action agent-oriented array-oriented automata-based concurrent computing o relativistic programming data-driven declarative contrast imperative o constraint + constraint logic concurrent constraint logic o dataflow + flow-based + cell-oriented spreadsheets + reactive o functional + functional logic + purely functional o logic + abductive logic + answer set + concurrent logic + functional logic + inductive logic dynamic end-user programming event-driven o service-oriented o time-driven expression-oriented feature-oriented function-level contrast value-level generic imperative contrast declarative o literate o procedural inductive programming language-oriented o natural language programming o discipline-specific o domain-specific o grammar-oriented + dialecting o intentional metaprogramming o automatic o reflective + attribute-oriented o homoiconic o template + policy-based non-structured contrast structured o array nondeterministic parallel computing o process-oriented point-free style o concatenative semantic structured contrast non-structured o block-structured o modular contrast monolithic o object-oriented + actor-based + class-based + concurrent + prototype-based + by separation concerns aspect-oriented role-oriented subject-oriented o recursive value-level contrast function-level probabilistic concept v t e computer science functional programming programming paradigm—a style building structure elements computer programs—that treats computation evaluation mathematical functions avoids changing-state mutable data declarative programming paradigm which means programming done with expressions declarations instead statements functional code output value function depends only on arguments that are input function so calling function f twice with same value for argument x will produce same result fx each time eliminating side effects ie changes state that do not depend on function inputs can make much easier understand predict behavior program which one key motivations for development functional programming functional programming has its roots lambda calculus formal system developed 1930s investigate computability entscheidungsproblem function definition function application recursion many functional programming languages can be viewed elaborations on lambda calculus another well-known declarative programming paradigm logic programming based on relations contrast imperative programming changes state with commands source language most simple example being assignment imperative programming does have functions—not mathematical sense—but sense subroutines they can have side effects that may change value program state functions without return values therefore make sense because this they lack referential transparency ie same language expression can result different values at different times depending on state executing program functional programming languages especially purely functional ones such hope have largely been emphasized academia rather than commercial software development however prominent programming languages which support functional programming such common lisp scheme clojure wolfram language also known mathematica racket erlang ocaml haskell f have been used industrial commercial applications by wide variety organizations functional programming also supported some domain-specific programming languages like r statistics j k q from kx systems financial analysis xquery/xslt xml opal widespread domain-specific declarative languages like sql lex/ yacc use some elements functional programming especially eschewing mutable values programming functional style can also be accomplished languages that are not specifically designed for functional programming for example imperative perl programming language has been subject book describing how apply functional programming concepts this also true php programming language c++11 java c all added constructs facilitate functional style julia language also offers functional programming abilities interesting case that scala – frequently written functional style but presence side effects mutable state place grey area between imperative functional languages contents history concepts o first-class higher-order functions o pure functions o recursion o strict versus non-strict evaluation o type systems o referential transparency o functional programming non-functional languages o data structures comparison imperative programming o simulating state o efficiency issues o coding styles + python + haskell + perl + erlang + elixir + lisp + clojure + d + r + sequencel use industry education see also references further reading external links history lambda calculus provides theoretical framework for describing functions their evaluation although mathematical abstraction rather than programming language forms basis almost all functional programming languages today equivalent theoretical formulation combinatory logic commonly perceived more abstract than lambda calculus preceded invention combinatory logic lambda calculus were both originally developed achieve clearer approach foundations mathematics early functional-flavored language was lisp developed late 1950s for ibm 700/7000 series scientific computers by john mccarthy while at massachusetts institute technology mit lisp introduced many features now found functional languages though lisp technically multi-paradigm language scheme dylan were later attempts simplify improve lisp information processing language ipl sometimes cited first computer-based functional programming language assembly-style language for manipulating lists symbols does have notion generator which amounts function accepting function argument since assembly-level language code can be used data so ipl can be regarded having higher-order functions however relies heavily on mutating list structure similar imperative features kenneth e iverson developed apl early 1960s described his book programming language isbn apl was primary influence on john backus's fp early 1990s iverson roger hui created j mid-1990s arthur whitney who had previously worked with iverson created k which used commercially financial industries along with its descendant q john backus presented fp his turing award lecture can programming be liberated from von neumann style functional style its algebra programs he defines functional programs being built up hierarchical way by means combining forms that allow algebra programs modern language this means that functional programs follow principle compositionality backus's paper popularized research into functional programming though emphasized function-level programming rather than lambda-calculus style which has come be associated with functional programming 1970s ml was created by robin milner at university edinburgh david turner initially developed language sasl at university st andrews later language miranda at university kent also edinburgh 1970s burstall darlington developed functional language npl npl was based on kleene recursion equations was first introduced their work on program transformation burstall macqueen sannella then incorporated polymorphic type checking from ml produce language hope ml eventually developed into several dialects most common which are now ocaml standard ml meanwhile development scheme partly functional dialect lisp described influential lambda papers textbook structure interpretation computer programs brought awareness power functional programming wider programming-languages community 1980s per martin-löf developed intuitionistic type theory also called constructive type theory which associated functional programs with constructive proofs arbitrarily complex mathematical propositions expressed dependent types this led powerful new approaches interactive theorem proving has influenced development many subsequent functional programming languages haskell language began with consensus form open standard for functional programming research implementation releases have been ongoing since concepts number concepts paradigms are specific functional programming generally foreign imperative programming including object-oriented programming however programming languages are often hybrids several programming paradigms so programmers using mostly imperative languages may have utilized some these concepts first-class higher-order functions main articles first-class function higher-order function higher-order functions are functions that can either take other functions arguments return them results calculus example higher-order function differential operator d / d x {\displaystyle d/dx} which returns derivative function f {\displaystyle f} higher-order functions are closely related first-class functions that higher-order functions first-class functions both allow functions arguments results other functions distinction between two subtle higher-order describes mathematical concept functions that operate on other functions while first-class computer science term that describes programming language entities that have no restriction on their use thus first-class functions can appear anywhere program that other first-class entities like numbers can including arguments other functions their return values higher-order functions enable partial application currying technique which function applied its arguments one at time with each application returning new function that accepts next argument this allows one succinctly express for example successor function addition operator partially applied natural number one pure functions pure functions expressions have no side effects memory i/o this means that pure functions have several useful properties many which can be used optimize code if result pure expression not used can be removed without affecting other expressions if pure function called with arguments that cause no side-effects result constant with respect that argument list sometimes called referential transparency ie if pure function again called with same arguments same result will be returned this can enable caching optimizations such memoization if there no data dependency between two pure expressions then their order can be reversed they can be performed parallel they cannot interfere with one another other terms evaluation any pure expression thread-safe if entire language does not allow side-effects then any evaluation strategy can be used this gives compiler freedom reorder combine evaluation expressions program for example using deforestation while most compilers for imperative programming languages detect pure functions perform common-subexpression elimination for pure function calls they cannot always do this for pre-compiled libraries which generally do not expose this information thus preventing optimizations that involve those external functions some compilers such gcc add extra keywords for programmer explicitly mark external functions pure enable such optimizations fortran also allows functions be designated pure recursion main article recursion computer science iteration looping functional languages usually accomplished via recursion recursive functions invoke themselves allowing operation be performed over over until base case reached though some recursion requires maintaining stack tail recursion can be recognized optimized by compiler into same code used implement iteration imperative languages scheme language standard requires implementations recognize optimize tail recursion tail recursion optimization can be implemented by transforming program into continuation passing style during compiling among other approaches common patterns recursion can be factored out using higher order functions with catamorphisms anamorphisms folds unfolds being most obvious examples such higher order functions play role analogous built-in control structures such loops imperative languages most general purpose functional programming languages allow unrestricted recursion are turing complete which makes halting problem undecidable can cause unsoundness equational reasoning generally requires introduction inconsistency into logic expressed by language's type system some special purpose languages such coq allow only well-founded recursion are strongly normalizing nonterminating computations can be expressed only with infinite streams values called codata consequence these languages fail be turing complete expressing certain functions them impossible but they can still express wide class interesting computations while avoiding problems introduced by unrestricted recursion functional programming limited well-founded recursion with few other constraints called total functional programming strict versus non-strict evaluation main article evaluation strategy functional languages can be categorized by whether they use strict eager non-strict lazy evaluation concepts that refer how function arguments are processed when expression being evaluated technical difference denotational semantics expressions containing failing divergent computations under strict evaluation evaluation any term containing failing subterm will itself fail for example expression print length will fail under strict evaluation because division by zero third element list under lazy evaluation length function will return value ie number items list since evaluating will not attempt evaluate terms making up list brief strict evaluation always fully evaluates function arguments before invoking function lazy evaluation does not evaluate function arguments unless their values are required evaluate function call itself usual implementation strategy for lazy evaluation functional languages graph reduction lazy evaluation used by default several pure functional languages including miranda clean haskell hughes argues for lazy evaluation mechanism for improving program modularity through separation concerns by easing independent implementation producers consumers data streams launchbury describes some difficulties that lazy evaluation introduces particularly analyzing program's storage requirements proposes operational semantics aid such analysis harper proposes including both strict lazy evaluation same language using language's type system distinguish them type systems especially since development hindley–milner type inference 1970s functional programming languages have tended use typed lambda calculus rejecting all invalid programs at compilation time risking false positive errors opposed untyped lambda calculus that accepts all valid programs at compilation time risks false negative errors used lisp its variants such scheme although they reject all invalid programs at runtime when information enough not reject valid programs use algebraic datatypes makes manipulation complex data structures convenient presence strong compile-time type checking makes programs more reliable absence other reliability techniques like test-driven development while type inference frees programmer from need manually declare types compiler most cases some research-oriented functional languages such coq agda cayenne epigram are based on intuitionistic type theory which allows types depend on terms such types are called dependent types these type systems do not have decidable type inference are difficult understand program with but dependent types can express arbitrary propositions predicate logic through curry–howard isomorphism then well-typed programs these languages become means writing formal mathematical proofs from which compiler can generate certified code while these languages are mainly interest academic research including formalized mathematics they have begun be used engineering well compcert compiler for subset c programming language that written coq formally verified limited form dependent types called generalized algebraic data types gadt's can be implemented way that provides some benefits dependently typed programming while avoiding most its inconvenience gadt's are available glasgow haskell compiler ocaml since version scala case classes have been proposed additions other languages including java c referential transparency main article referential transparency functional programs do not have assignment statements that value variable functional program never changes once defined this eliminates any chances side effects because any variable can be replaced with its actual value at any point execution so functional programs are referentially transparent consider c assignment statement x = x this changes value assigned variable x let us say that initial value x was then two consecutive evaluations variable x will yield respectively clearly replacing x = x with either gives program with different meaning so expression not referentially transparent fact assignment statements are never referentially transparent now consider another function such int plusoneint x {return x+1} transparent will not implicitly change input x thus has no such side effects functional programs exclusively use this type function are therefore referentially transparent functional programming non-functional languages possible use functional style programming languages that are not traditionally considered functional languages for example both d fortran explicitly support pure functions javascript lua python had first class functions from their inception amrit prem added support python for lambda map reduce filter well closures python though python relegated reduce functools standard library module first-class functions have been introduced into other mainstream languages such php visual basic c c++11 java anonymous classes can sometimes be used simulate closures however anonymous classes are not always proper replacements closures because they have more limited capabilities java supports lambda expressions replacement for some anonymous classes however presence checked exceptions java can make functional programming inconvenient because can be necessary catch checked exceptions then rethrow them—a problem that does not occur other jvm languages that do not have checked exceptions such scala c anonymous classes are not necessary because closures lambdas are fully supported libraries language extensions for immutable data structures are being developed aid programming functional style c many object-oriented design patterns are expressible functional programming terms for example strategy pattern simply dictates use higher-order function visitor pattern roughly corresponds catamorphism fold similarly idea immutable data from functional programming often included imperative programming languages for example tuple python which immutable array data structures main article purely functional data structure purely functional data structures are often represented different way than their imperative counterparts for example array with constant-time access update basic component most imperative languages many imperative data-structure such hash table binary heap are based on arrays arrays can be replaced by map random access list which admits purely functional implementation but access update time logarithmic therefore purely functional data structures can be used languages which are non-functional but they may not be most efficient tool available especially if persistency not required comparison imperative programming functional programming very different from imperative programming most significant differences stem from fact that functional programming avoids side effects which are used imperative programming implement state i/o pure functional programming completely prevents side-effects provides referential transparency higher-order functions are rarely used older imperative programming traditional imperative program might use loop traverse modify list functional program on other hand would probably use higher-order “map” function that takes function list generating returning new list by applying function each list item simulating state there are tasks for example maintaining bank account balance that often seem most naturally implemented with state pure functional programming performs these tasks i/o tasks such accepting user input printing screen different way pure functional programming language haskell implements them using monads derived from category theory monads offer way abstract certain types computational patterns including but not limited modeling computations with mutable state other side effects such i/o imperative manner without losing purity while existing monads may be easy apply program given appropriate templates examples many students find them difficult understand conceptually eg when asked define new monads which sometimes needed for certain types libraries another way which functional languages can simulate state by passing around data structure that represents current state parameter function calls on each function call copy this data structure created with whatever differences are result function this referred 'state-passing style' impure functional languages usually include more direct method managing mutable state clojure for example uses managed references that can be updated by applying pure functions current state this kind approach enables mutability while still promoting use pure functions preferred way express computations alternative methods such hoare logic uniqueness have been developed track side effects programs some modern research languages use effect systems make presence side effects explicit efficiency issues functional programming languages are typically less efficient their use cpu memory than imperative languages such c pascal this related fact that some mutable data structures like arrays have very straightforward implementation using present hardware which highly evolved turing machine flat arrays may be accessed very efficiently with deeply pipelined cpus prefetched efficiently through caches with no complex pointer chasing handled with simd instructions also not easy create their equally efficient general-purpose immutable counterparts for purely functional languages worst-case slowdown logarithmic number memory cells used because mutable memory can be represented by purely functional data structure with logarithmic access time such balanced tree however such slowdowns are not universal for programs that perform intensive numerical computations functional languages such ocaml clean are only slightly slower than c for programs that handle large matrices multidimensional databases array functional languages such j k were designed with speed optimizations immutability data can many cases lead execution efficiency by allowing compiler make assumptions that are unsafe imperative language thus increasing opportunities for inline expansion lazy evaluation may also speed up program even asymptotically whereas may slow down at most by constant factor however may introduce memory leaks if used improperly launchbury discusses theoretical issues related memory leaks from lazy evaluation o'sullivan et al give some practical advice for analyzing fixing them however most general implementations lazy evaluation making extensive use dereferenced code data perform poorly on modern processors with deep pipelines multi-level caches where cache miss may cost hundreds cycles coding styles this section does not cite any sources please help improve this section by adding citations reliable sources unsourced material may be challenged removed july learn how when remove this template message imperative programs have environment sequence steps manipulating environment functional programs have expression that successively substituted until reaches normal form example illustrates this with different solutions same programming goal calculating fibonacci numbers python printing first fibonacci numbers iterative def fibonaccin first=0 second=1 while n = printfirst end=\n side-effect n first second = n - second first + second assignment fibonacci10 printing first fibonacci numbers functional expression style fibonacci = lambda n first=0 second=1 if n == else strfirst + \n + fibonaccin - second first + second printfibonacci10 end= printing list with first fibonacci numbers with generators def fibonaccin first=0 second=1 while n = yield first n first second = n - second first + second assignment printlistfibonacci10 printing list with first fibonacci numbers functional expression style fibonacci = lambda n first=0 second=1 if n == else + fibonaccin - second first + second printfibonacci10 haskell printing first fibonacci numbers functional expression style fibonacciaux = \n first second-> if n == then else show first ++ \n ++ fibonacciaux n - second first + second fibonacci = \n-> fibonacciaux n main = putstr fibonacci printing list with first fibonacci numbers functional expression style fibonacciaux = \n first second-> if n == then else ++ fibonacciaux n - second first + second fibonacci = \n-> fibonacciaux n main = putstrln show fibonacci printing 11th fibonacci number functional expression style fibonacci = \n-> if n == then else if n == then else fibonaccin - + fibonaccin - main = putstrln show fibonacci printing 11th fibonacci number functional expression style tail recursive fibonacciaux = \n first second-> if n == then first else fibonacciaux n - second first + second fibonacci = \n-> fibonacciaux n main = putstrln show fibonacci printing 11th fibonacci number functional expression style with recursive lists fibonacciaux = \first second-> first fibonacciaux second first + second select = \n zs-> if n==0 then head zs else select n - tail zs fibonacci = \n-> select n fibonacciaux main = putstrln show fibonacci printing 11th fibonacci number functional expression style with primitives for recursive lists fibonacciaux = \first second-> first fibonacciaux second first + second fibonacci = \n-> fibonacciaux n main = putstrln show fibonacci printing 11th fibonacci number functional expression style with primitives for recursive lists more concisely fibonacciaux = 01zipwith + fibonacciaux tail fibonacciaux fibonacci = \n-> fibonacciaux n main = putstrln show fibonacci printing 11th fibonacci number functional declaration style tail recursive fibonacciaux first = first fibonacciaux n first second = fibonacciaux n - second first + second fibonacci n = fibonacciaux n main = putstrln show fibonacci printing 11th fibonacci number functional declaration style using lazy infinite lists primitives fibs = zipwith + fibs tail fibs -- infinite list fibonacci numbers -- fibs defined terms fibs fibonacci = fibs main = putstrln $ show $ fibonacci perl influenced by haskell others perl has several functional declarative approaches problems for example you can declaratively build up well-typed recursive version type constraints are optional through signature pattern matching subset nonnegativeint int where >= proto fib | cached returns nonnegativeint {} multi fib { } multi fib { } multi fib nonnegativeint $n { fib$n - + fib$n - } for ^10 -> $n { say fib$n } alternative this construct lazy iterative sequence which appears almost direct illustration sequence my @fib = + each additional entry sum previous two this sequence extends lazily indefinitely say @fib display first entries erlang erlang functional concurrent general-purpose programming language fibonacci algorithm implemented erlang note this only for demonstrating erlang syntax use other algorithms for fast performance -modulefib % this file 'fiberl' module filename must match -export % this exports function 'fib' arity fib1 -> % if then return otherwise note semicolon meaning 'else' fib2 -> % if then return otherwise fibn -> fibn - + fibn - elixir elixir functional concurrent general-purpose programming language that runs on erlang virtual machine beam fibonacci function can be written elixir follows defmodule fibonacci do def fib0 do def fib1 do def fibn do fibn-1 + fibn-2 end lisp fibonacci function can be written common lisp follows defun fib n &optional b if = n fib - n b + b program can then be called fib clojure fibonacci function can be written clojure follows defn fib loop if zero i recur b + b dec i program can then be called fib d d has support for functional programming import stdstdio import stdrange void main { / 'f' range representing first fibonacci numbers / auto f = recurrenceseq i => seq + seq0 take10 writelnf } r r environment for statistical computing graphics also functional programming language fibonacci function can be written r recursive function follows fib b b hudak paul september conception evolution application functional programming languages pdf acm computing surveys 359–411 doi 101145/7255172554 b clinger will multitasking macscheme mactech retrieved b hartheimer anne programming text editor macscheme+toolsmith mactech retrieved b kidd eric terrorism response training scheme cufp retrieved b cleis richard scheme space cufp retrieved user conference schedule includes papers on commercial use r r-projectorg retrieved chambers john m programming with data guide s language springer verlag pp 67–70 isbn 978-0-387-98503-9 b wolfram language guide functional programming retrieved state-based scripting uncharted pdf archived from original pdf on retrieved b who uses erlang for product development frequently asked questions about erlang retrieved b armstrong joe june history erlang third acm sigplan conference on history programming languages san diego california retrieved b larson jim march erlang for concurrent programming communications acm doi101145/14672471467263 b minsky yaron weeks stephen july caml trading — experiences with functional programming on wall street journal functional programming cambridge university press 553–564 doi101017/s095679680800676x retrieved b leroy xavier some uses caml industry pdf cufp retrieved b haskell industry haskell wiki retrieved haskell has diverse range use commercially from aerospace defense finance web startups hardware design firms lawnmower manufacturers b c hudak paul hughes j jones s p wadler p june history haskell being lazy with class third acm sigplan conference on history programming languages san diego california doi101145/12388441238856 retrieved b mansell howard quantitative finance f cufp retrieved b peake alex first substantial line business application f cufp retrieved department applied math university colorado functional vs procedural programming language archived from original on retrieved dimitre novatchev functional programming language xslt — proof through examples topxml retrieved may david mertz xml programming paradigms part four functional programming approached xml processing ibm developerworks retrieved may optimized applicative language donald d chamberlin raymond f boyce sequel structured english query language proceedings acm sigfidet 249–264 dominus mark j higher-order perl morgan kaufmann isbn 1-55860-701-3 holywell simon functional programming php php isbn effective scala scala wiki retrieved effective scala haskell brooks curry robert feys combinatory logic north-holland publishing company retrieved february mccarthy john june history lisp acm sigplan history programming languages conference 217–223 doi 101145/800025808387 memoir herbert simon models my life pp189-190 isbn 0-465-04640-1 claims that he al newell cliff shaw are commonly adjudged be parents artificial intelligence for writing logic theorist program which proved theorems from principia mathematica automatically order accomplish this they had invent language paradigm which which viewed retrospectively embeds functional programming rm burstall design considerations for functional programming language invited paper proc infotech state art conf software revolution copenhagen 45–57 rm burstall j darlington transformation system for developing recursive programs journal association for computing machinery 24144–67 rm burstall db macqueen dt sannella hope experimental applicative language proc lisp conference stanford 136–143 dick pountain functional programming comes age bytecom august archived from original on retrieved august turner da total functional programming journal universal computer science 751–768 doi 103217/jucs-010-07-0751 implementation functional programming languages simon peyton jones published by prentice hall hughes john why functional programming matters b john launchbury natural semantics for lazy evaluation robert w harper practical foundations for programming languages pdf compcert verified compiler simon peyton jones dimitrios vytiniotis stephanie weirich geoffrey washburn simple unification-based type inference for gadts icfp pp 50–61 andrew kennedy claudio russo october generalized algebraic data types object-oriented programming pdf oopsla san diego california archived from original pdf on source citation huges john why functional programming matters pdf chalmers tekniska h¨ogskola external link |website= help hartel pieter henk muller hugh glaser march functional c experience pdf journal functional programming 129–135 doi 101017/s0956796803004817 david mertz functional programming python part ibm developerworks archived from original on retrieved part part functions — d programming language digital mars retrieved lua unofficial faq ufaq brendan eich van rossum guido origins python's functional features history python retrieved external link |publisher= help functools — higher order functions operations on callable objects python software foundation retrieved skarsaune martin sics java port project automatic translation large object oriented system from smalltalk java gosling james closures james gosling on java road oracle retrieved may java se lambda quick start bloch joshua effective java second ed pp item purely functional data structures by chris okasaki cambridge university press isbn 0-521-66350-4 newbern j all about monads comprehensive guide theory practice monadic programming haskell retrieved larry c paulson june ml for working programmer cambridge university press isbn 978-0-521-56543-1 retrieved february daniel spiewak implementing persistent vectors scala retrieved apr which programs are fastest | computer language benchmarks game benchmarksgamealiothdebianorg retrieved igor pechtchanski vivek sarkar immutability specification its applications concurrency computation practice experience 5–6 639–662 doi101002/cpe853 chapter profiling optimization bookrealworldhaskellorg retrieved odersky martin spoon lex venners bill december programming scala comprehensive step-by-step guide 2nd ed artima inc pp 883/852 isbn 978-0-9815316-4-9 piro christopher functional programming at facebook cufp retrieved sim-diasca large-scale discrete event concurrent simulation engine erlang november million so // whatsapp blog last important piece our infrastracture erlang momtahan lee scala at edf trading implementing domain-specific language for derivative pricing with scala cufp retrieved graham paul beating averages retrieved sims steve building startup with standard ml pdf cufp retrieved laurikari ville functional programming communications security cufp retrieved lorimer r j live production clojure application announced emmanuel schanzer bootstrap interviewed on tv show triangulation on twittv network further reading abelson hal sussman gerald jay structure interpretation computer programs mit press cousineau guy michel mauny functional approach programming cambridge uk cambridge university press curry haskell brooks feys robert craig william combinatory logic volume i north-holland publishing company amsterdam curry haskell b hindley j roger seldin jonathan p combinatory logic vol ii amsterdam north holland isbn 0-7204-2208-6 dominus mark jason higher-order perl morgan kaufmann felleisen matthias findler robert flatt matthew krishnamurthi shriram how design programs mit press graham paul ansi common lisp englewood cliffs new jersey prentice hall maclennan bruce j functional programming practice theory addison-wesley o'sullivan brian stewart don goerzen john real world haskell o'reilly pratt terrence w marvin v zelkowitz programming languages design implementation 3rd ed englewood cliffs new jersey prentice hall salus peter h functional logic programming languages vol handbook programming languages indianapolis indiana macmillan technical publishing thompson simon haskell craft functional programming harlow england addison-wesley longman limited external links listen this article info/dl this audio file was created from revision functional programming article dated does not reflect subsequent edits article audio help more spoken articles ford neal functional thinking why functional programming on rise retrieved akhmechet slava defmacro – functional programming for rest us retrieved introduction functional programming python by david mertz part part part v t e types programming languages actor-based array aspect-oriented class-based concatenative concurrent data-structured dataflow declarative domain-specific dynamic esoteric event-driven extensible functional imperative logic macro metaprogramming+multi-paradigm object-based object-oriented pipeline procedural prototype-based reflective rule-based scripting synchronous templating assembly compiled interpreted machine low-level high-level very high-level first generation second generation third generation fourth generation fifth generation non-english-based visual authority control lccn sh87007844 gnd 4198740-8 bnf cb121910539 data bne xx547935 retrieved from https//enwikipediaorg/w/indexphptitle=functionalprogramming&oldid=750235164 categories programming paradigms functional programming hidden categories cs1 errors external links all articles with dead external links articles with dead external links from february pages using isbn magic links all articles with unsourced statements articles with unsourced statements from december articles with unsourced statements from april articles with unsourced statements from march articles with unsourced statements from june articles needing additional references from july all articles needing additional references wikipedia articles needing clarification from april spoken articles articles with haudio microformats wikipedia articles with lccn identifiers wikipedia articles with gnd identifiers wikipedia articles with bnf identifiers navigation menu personal tools not logged talk contributions create account log namespaces article talk variants views read edit view history more search navigation main page contents featured content current events random article donate wikipedia wikipedia store interaction help about wikipedia community portal recent changes contact page tools what links here related changes upload file special pages permanent link page information wikidata item cite this page print/export create book download pdf printable version other projects wikimedia commons languages العربية বাংলা беларуская български català čeština dansk deutsch eesti ελληνικά español فارسی français gaeilge galego 한국어 hrvatski bahasa indonesia italiano עברית latina magyar bahasa melayu mirandés nederlands 日本語 norsk bokmål polski português română русиньскый русский scots slovenčina српски / srpski srpskohrvatski / српскохрватски suomi svenska தமிழ் türkçe українська tiếng việt zazaki 中文 edit links this page was last modified on november at text available under creative commons attribution-sharealike license additional terms may apply by using this site you agree terms use privacy policy wikipedia® registered trademark wikimedia foundation inc non-profit organization privacy policy about wikipedia disclaimers contact wikipedia developers cookie statement mobile view 