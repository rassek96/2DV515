scheme programming language from wikipedia free encyclopedia jump navigation search scheme paradigms multi-paradigm functional procedural meta designed by guy l steele gerald jay sussman first appeared stable release r7rs ratified standard / typing discipline strong dynamic scope lexical filename extensions scm ss website wwwscheme-reportsorg major implementations many see categoryscheme programming language implementations dialects t influenced by lisp racket algol mdl influenced clojure common lisp dylan eulisp haskell hop javascript julia lua r s racket ruby rust scala scheme at wikibooks scheme functional programming language one two main dialects programming language lisp unlike common lisp other main dialect scheme follows minimalist design philosophy specifying small standard core with powerful tools for language extension scheme was created during 1970s at mit ai lab released by its developers guy l steele gerald jay sussman via series memos now known lambda papers was first dialect lisp choose lexical scope first require implementations perform tail-call optimization giving stronger support for functional programming associated techniques such recursive algorithms was also one first programming languages support first-class continuations had significant influence on effort that led development common lisp scheme language standardized official ieee standard de facto standard called revisedn report on algorithmic language scheme rnrs most widely implemented standard r5rs new standard r6rs was ratified scheme has diverse user base due its compactness elegance but its minimalist philosophy has also caused wide divergence between practical implementations so much that scheme steering committee calls world's most unportable programming language family dialects rather than single language contents history o origins o r6rs o r7rs distinguishing features o fundamental design features + minimalism + lexical scope + lambda calculus + block structure + proper tail recursion + first-class continuations + shared namespace for procedures variables o implementation standards + numerical tower + delayed evaluation + order evaluation procedure arguments + hygienic macros + environments eval + treatment non-boolean values boolean expressions + disjointness primitive datatypes + equivalence predicates + comments + input/output + redefinition standard procedures o nomenclature naming conventions review standard forms procedures o standard forms o standard procedures scheme requests for implementation implementations usage see also references further reading external links history main article history scheme programming language origins scheme started 1970s attempt understand carl hewitt's actor model for which purpose steele sussman wrote tiny lisp interpreter using maclisp then added mechanisms for creating actors sending messages scheme was originally called schemer tradition other lisp-derived languages like planner conniver current name resulted from authors' use its operating system which limited filenames two components at most six characters each currently schemer commonly used refer scheme programmer r6rs new language standardization process began at scheme workshop with goal producing r6rs standard this process broke with earlier rnrs approach unanimity r6rs features standard module system allowing split between core language libraries number drafts r6rs specification were released final version being r597rs successful vote resulted ratification new standard announced on august currently newest releases various scheme implementations such chez scheme racket ikarus larceny ypsilon support r6rs standard there portable reference implementation proposed implicitly phased libraries for r6rs called psyntax which loads bootstraps itself properly on various older scheme implementations r6rs introduces numerous significant changes language source code now specified unicode large subset unicode characters may now appear scheme symbols identifiers there are other minor changes lexical rules character data also now specified unicode many standard procedures have been moved new standard libraries which themselves form large expansion standard containing procedures syntactic forms that were formerly not part standard new module system has been introduced systems for exception handling are now standardized syntax-rules has been replaced with more expressive syntactic abstraction facility syntax-case which allows use all scheme at macro expansion time compliant implementations are now required support scheme's full numeric tower semantics numbers have been expanded mainly direction support for ieee standard for floating point numerical representation r7rs r6rs standard has caused controversy because seen have departed from minimalist philosophy august scheme steering committee which oversees standardization process announced its intention recommend splitting scheme into two languages large modern programming language for programmers small version subset large version retaining minimalism praised by educators casual implementors two working groups were created work on these two new versions scheme scheme reports process site has links working groups charters public discussions issue tracking system ninth draft r7rs small language was made available on april vote ratifying this draft closed on may final report has been available since august that describes “small” language that effort therefore cannot be considered isolation successor r6rs distinguishing features see also lisp programming language scheme primarily functional programming language shares many characteristics with other members lisp programming language family scheme's very simple syntax based on s-expressions parenthesized lists which prefix operator followed by its arguments scheme programs thus consist sequences nested lists lists are also main data structure scheme leading close equivalence between source code data formats homoiconicity scheme programs can easily create evaluate pieces scheme code dynamically reliance on lists data structures shared by all lisp dialects scheme inherits rich set list-processing primitives such cons car cdr from its lisp progenitors scheme uses strictly but dynamically typed variables supports first class procedures thus procedures can be assigned values variables passed arguments procedures this section concentrates mainly on innovative features language including those features that distinguish scheme from other lisps unless stated otherwise descriptions features relate r5rs standard examples provided this section notation ===> result used indicate result evaluating expression on immediately preceding line this same convention used r5rs fundamental design features this subsection describes those features scheme that have distinguished from other programming languages from its earliest days these are aspects scheme that most strongly influence any product scheme language they are aspects that all versions scheme programming language from onward share minimalism main article minimalism computing scheme very simple language much easier implement than many other languages comparable expressive power this ease attributable use lambda calculus derive much syntax language from more primitive forms for instance s-expression-based syntactic constructs defined r5rs scheme standard are classed derived library forms which can be written macros involving more fundamental forms principally lambda r5rs says r5rs sec most fundamental variable binding constructs lambda expression because all other variable binding constructs can be explained terms lambda expressions fundamental forms define lambda if quote unquote unquote-splicing quasiquote define-syntax let-syntax letrec-syntax syntax-rules set library forms do let let letrec cond case begin named let delay example macro implement let expression using lambda perform variable bindings define-syntax let syntax-rules let var expr body lambda var body expr thus using let defined above scheme implementation would rewrite let 1b + b lambda b + b which reduces implementation's task that coding procedure instantiations sussman steele remarked that minimalism scheme was not conscious design goal but rather unintended outcome design process we were actually trying build something complicated discovered serendipitously that we had accidentally designed something that met all our goals but was much simpler than we had intendedwe realized that lambda calculus—a small simple formalism—could serve core powerful expressive programming language lexical scope see also scope programming like most modern programming languages unlike earlier lisps such maclisp scheme lexically scoped all possible variable bindings program unit can be analyzed by reading text program unit without consideration contexts which may be called this contrasts with dynamic scoping which was characteristic early lisp dialects because processing costs associated with primitive textual substitution methods used implement lexical scoping algorithms compilers interpreters day those lisps was perfectly possible for reference free variable inside procedure refer quite distinct bindings external procedure depending on context call impetus incorporate lexical scoping which was unusual scoping model early 1970s into their new version lisp came from sussman's studies algol he suggested that algol-like lexical scoping mechanisms would help realize their initial goal implementing hewitt's actor model lisp key insights on how introduce lexical scoping into lisp dialect were popularized sussman steele's lambda paper scheme interpreter for extended lambda calculus where they adopted concept lexical closure on page which had been described ai memo by joel moses who attributed idea peter j landin lambda calculus see also lambda calculus alonzo church's mathematical notation lambda calculus has inspired lisp's use lambda keyword for introducing procedure well influencing development functional programming techniques involving use higher-order functions lisp but early lisps were not suitable expressions lambda calculus because their treatment free variables introduction lexical scope resolved problem by making equivalence between some forms lambda notation their practical expression working programming language sussman steele showed that new language could be used elegantly derive all imperative declarative semantics other programming languages including algol fortran dynamic scope other lisps by using lambda expressions not simple procedure instantiations but control structures environment modifiers they introduced continuation-passing style along with their first description scheme first lambda papers subsequent papers they proceeded demonstrate raw power this practical use lambda calculus block structure scheme inherits its block structure from earlier block structured languages particularly algol scheme blocks are implemented by three binding constructs let let letrec for instance following construct creates block which symbol called var bound number define var goose any reference var here will be bound goose let var statements go here any reference var here will be bound any reference var here will be bound goose blocks can be nested create arbitrarily complex block structures according need programmer use block structuring create local bindings alleviates risk namespace collision that can otherwise occur one variant let let permits bindings refer variables defined earlier same construct thus let var1 var2 + var1 but definition var1 could not refer var2 other variant letrec designed enable mutually recursive procedures be bound one another calculation hofstadter's male female sequences list pairs define hofstadter-male-female n letrec female lambda n if = n - n male female - n male lambda n if = n - n female male - n let loop i if > i n ' cons cons female i male i loop + i hofstadter-male-female ===> see hofstadter's male female sequences for definitions used this example all procedures bound single letrec may refer one another by name well values variables defined earlier same letrec but they may not refer values defined later same letrec variant let named let form has identifier after let keyword this binds let variables argument procedure whose name given identifier whose body body let form body may be repeated desired by calling procedure named let widely used implement iteration example simple counter let loop n if > n ' cons n loop + n ===> like any procedure scheme procedure created named let first class object proper tail recursion for more details on this topic see tail recursion scheme has iteration construct do but more idiomatic scheme use tail recursion express iteration standard-conforming scheme implementations are required optimize tail calls so support unbounded number active tail calls r5rs sec 35—a property scheme report describes proper tail recursion—making safe for scheme programmers write iterative algorithms using recursive structures which are sometimes more intuitive tail recursive procedures named let form provide support for iteration using tail recursion building list squares from note loop simply arbitrary symbol used label any symbol will do define list-of-squares n let loop i n res ' if first-class continuations main article continuation continuations scheme are first-class objects scheme provides procedure call-with-current-continuation also known call/cc capture current continuation by packing up escape procedure bound formal argument procedure provided by programmer r5rs sec first-class continuations enable programmer create non-local control constructs such iterators coroutines backtracking continuations can be used emulate behavior return statements imperative programming languages following function find-first given function func list lst returns first element x lst such that func x returns true define find-first func lst call-with-current-continuation lambda return-immediately for-each lambda x if func x return-immediately x lst f find-first integer '1/2 3/4 8/9 ===> find-first zero '1 ===> f following example traditional programmer's puzzle shows that scheme can handle continuations first-class objects binding them variables passing them arguments procedures let yin lambda cc display @ cc call-with-current-continuation lambda c c yang lambda cc display cc call-with-current-continuation lambda c c yin yang when executed this code displays counting sequence @@@@@@@@ shared namespace for procedures variables contrast common lisp all data procedures scheme share common namespace whereas common lisp functions data have separate namespaces making possible for function variable have same name requiring special notation for referring function value this sometimes known lisp-1 vs lisp-2 distinction referring unified namespace scheme separate namespaces common lisp scheme same primitives that are used manipulate bind data can be used bind procedures there no equivalent common lisp's defun ' primitives variable bound number define f f ===> mutation altering bound value set f + f f f ===> assigning procedure same variable set f lambda n + n f ===> assigning result expression same variable set f f f ===> functional programming apply + '1 ===> set f lambda n + n map f '1 ===> implementation standards this subsection documents design decisions that have been taken over years which have given scheme particular character but are not direct outcomes original design numerical tower main article numerical tower scheme specifies comparatively full set numerical datatypes including complex rational types which known scheme numerical tower r5rs sec standard treats these abstractions does not commit implementor any particular internal representations numbers may have quality exactness exact number can only be produced by sequence exact operations involving other exact numbers—inexactness thus contagious standard specifies that any two implementations must produce equivalent results for all operations resulting exact numbers r5rs standard specifies procedures exact->inexact inexact->exact which can be used change exactness number inexact->exact produces exact number that numerically closest argument exact->inexact produces inexact number that numerically closest argument r6rs standard omits these procedures from main report but specifies them r5rs compatibility procedures standard library rnrs r5rs r5rs standard scheme implementations are not required implement whole numerical tower but they must implement coherent subset consistent with both purposes implementation spirit scheme language r5rs sec new r6rs standard does require implementation whole tower exact integer objects exact rational number objects practically unlimited size precision implement certain proceduresso they always return exact results when given exact arguments r6rs sec sec example exact arithmetic implementation that supports exact rational complex numbers sum three rational real numbers two rational complex numbers define x + 1/3 1/4 -1/5 -1/3i 405/50+2/3i x ===> 509/60+1/3i check for exactness exact x ===> t example same arithmetic implementation that supports neither exact rational numbers nor complex numbers but does accept real numbers rational notation sum four rational real numbers define xr + 1/3 1/4 -1/5 405/50 sum two rational real numbers define xi + -1/3 2/3 xr ===> xi ===> check for exactness exact xr ===> f exact xi ===> f both implementations conform r5rs standard but second does not conform r6rs because does not implement full numerical tower delayed evaluation see also lazy evaluation scheme supports delayed evaluation through delay form procedure force define define eval-aplus2 delay + set force eval-aplus2 ===> define eval-aplus50 delay + let force eval-aplus50 ===> set force eval-aplus2 ===> lexical context original definition promise preserved its value also preserved after first use force promise only ever evaluated once these primitives which produce handle values known promises can be used implement advanced lazy evaluation constructs such streams r6rs standard these are no longer primitives but instead are provided part r5rs compatibility library rnrs r5rs r5rs suggested implementation delay force given implementing promise procedure with no arguments thunk using memoization ensure that only ever evaluated once irrespective number times force called r5rs sec srfi enables expression both finite infinite sequences with extraordinary economy for example this definition fibonacci sequence using functions defined srfi define fibonacci sequence define fibs stream-cons stream-cons stream-map + fibs stream-cdr fibs compute hundredth number sequence stream-ref fibs ===> order evaluation procedure arguments most lisps specify order evaluation for procedure arguments scheme does not order evaluation—including order which expression operator position evaluated—may be chosen by implementation on call-by-call basis only constraint that effect any concurrent evaluation operator operand expressions constrained be consistent with some sequential order evaluation r5rs sec let ev lambdan display evaluating display if procedure n procedure n newline n ev + ev ev ===> ev procedure that describes argument passed then returns value argument contrast with other lisps appearance expression operator position first item scheme expression quite legal long result expression operator position procedure calling procedure + add expressions ev + ev ev may be evaluated any order long effect not if they were evaluated parallel thus following three lines may be displayed any order by standard scheme when above example code executed although text one line may not be interleaved with another because that would violate sequential evaluation constraint evaluating evaluating evaluating procedure hygienic macros main article hygienic macro r5rs standard also later reports syntax scheme can easily be extended via macro system r5rs standard introduced powerful hygienic macro system that allows programmer add new syntactic constructs language using simple pattern matching sublanguage r5rs sec prior this hygienic macro system had been relegated appendix r4rs standard high level system alongside low level macro system both which were treated extensions scheme rather than essential part language implementations hygienic macro system also called syntax-rules are required respect lexical scoping rest language this assured by special naming scoping rules for macro expansion avoids common programming errors that can occur macro systems other programming languages r6rs specifies more sophisticated transformation system syntax-case which has been available language extension r5rs scheme for some time define macro implement variant if with multi-expression true branch no false branch define-syntax when syntax-rules when pred exp exps if pred begin exp exps invocations macros procedures bear close resemblance—both are s-expressions—but they are treated differently when compiler encounters s-expression program first checks see if symbol defined syntactic keyword within current lexical scope if so then attempts expand macro treating items tail s-expression arguments without compiling code evaluate them this process repeated recursively until no macro invocations remain if not syntactic keyword compiler compiles code evaluate arguments tail s-expression then evaluate variable represented by symbol at head s-expression call procedure with evaluated tail expressions passed actual arguments most scheme implementations also provide additional macro systems among popular ones are syntactic closures explicit renaming macros define-macro non-hygienic macro system similar defmacro system provided common lisp environments eval prior r5rs scheme had no standard equivalent eval procedure which ubiquitous other lisps although first lambda paper had described evaluate similar lisp function eval first revised report replaced this with enclose which took two arguments second third fourth revised reports omitted any equivalent eval reason for this confusion that scheme with its lexical scoping result evaluating expression depends on where evaluated for instance not clear whether result evaluating following expression should be let name '+ let + evaluate list name if evaluated outer environment where name defined result sum operands if evaluated inner environment where symbol + has been bound value procedure result product two operands r5rs resolves this confusion by specifying three procedures that return environments providing procedure eval that takes s-expression environment evaluates expression environment provided r5rs sec r6rs extends this by providing procedure called environment by which programmer can specify exactly which objects import into evaluation environment treatment non-boolean values boolean expressions most dialects lisp including common lisp by convention value nil evaluates value false boolean expression scheme since ieee standard all values except f including nil's equivalent scheme which written ' evaluate value true boolean expression r5rs sec where constant representing boolean value true t most lisps scheme t disjointness primitive datatypes scheme primitive datatypes are disjoint only one following predicates can be true any scheme object boolean pair symbol number char string vector port procedure r5rs sec within numerical datatype by contrast numerical values overlap for example integer value satisfies all integer rational real complex number predicates at same time r5rs sec equivalence predicates see also relational operator scheme has three different types equivalence between arbitrary objects denoted by three different equivalence predicates relational operators for testing equality eq eqv equal eq evaluates f unless its parameters represent same data object memory eqv generally same eq but treats primitive objects eg characters numbers specially so that numbers that represent same value are eqv even if they do not refer same object equal compares data structures such lists vectors strings determine if they have congruent structure eqv contentsr5rs sec type dependent equivalence operations also exist scheme string= string-ci= compare two strings latter performs case-independent comparison char= char-ci= compare characters = compares numbers comments see also comment computer programming up r5rs standard standard comment scheme was semicolon which makes rest line invisible scheme numerous implementations have supported alternative conventions permitting comments extend for more than single line r6rs standard permits two them entire s-expression may be turned into comment commented out by preceding with introduced srfi multiline comment block comment may be produced by surrounding text with | | input/output scheme's input output based on port datatype r5rs sec r5rs defines two default ports accessible with procedures current-input-port current-output-port which correspond unix notions standard input standard output most implementations also provide current-error-port redirection input standard output supported standard by standard procedures such with-input-from-file with-output-to-file most implementations provide string ports with similar redirection capabilities enabling many normal input-output operations be performed on string buffers instead files using procedures described srfi r6rs standard specifies much more sophisticated capable port procedures many new types port following examples are written strict r5rs scheme example with output defaulting current-output-port let hello0 lambda display hello world newline hello0 example but using optional port argument output procedures let hello1 lambda p display hello world p newline p hello1 current-output-port example but output redirected newly created file nb with-output-to-file optional procedure r5rs let hello0 lambda display hello world newline with-output-to-file helloworldoutputfile hello0 example but with explicit file open port close send output file let hello1 lambda p display hello world p newline p output-port open-output-file helloworldoutputfile hello1 output-port close-output-port output-port example but with using call-with-output-file send output file let hello1 lambda p display hello world p newline p call-with-output-file helloworldoutputfile hello1 similar procedures are provided for input r5rs scheme provides predicates input-port output-port for character input output write-char read-char peek-char char-ready are provided for writing reading scheme expressions scheme provides read write on read operation result returned end-of-file object if input port has reached end file this can be tested using predicate eof-object addition standard srfi defines basic formatting procedure resembling common lisp's format function after which named redefinition standard procedures scheme procedures are bound variables at r5rs language standard formally mandated that programs may change variable bindings built-in procedures effectively redefining them r5rs language changes for example one may extend + accept strings well numbers by redefining set + let original+ + lambda args if not null args string car args apply string-append args apply original+ args + ===> + ===> r6rs every binding including standard ones belongs some library all exported bindings are immutable r6rs sec because this redefinition standard procedures by mutation forbidden instead possible import different procedure under name standard one which effect similar redefinition nomenclature naming conventions standard scheme procedures that convert from one datatype another contain character string -> their name predicates end with procedures that change value already-allocated data end with these conventions are often followed by scheme programmers formal contexts such scheme standards word procedure used preference function refer lambda expression primitive procedure normal usage words procedure function are used interchangeably procedure application sometimes referred formally combination other lisps term thunk used scheme refer procedure with no arguments term proper tail recursion refers property all scheme implementations that they perform tail-call optimization so support indefinite number active tail calls form titles standards documents since r3rs revisedn report on algorithmic language scheme reference title algol standard document revised report on algorithmic language algol summary page r3rs closely modeled on summary page algol report review standard forms procedures this section does not cite any sources please help improve this section by adding citations reliable sources unsourced material may be challenged removed may learn how when remove this template message language formally defined standards r5rs r6rs they describe standard forms keywords accompanying syntax which provide control structure language standard procedures which perform common tasks standard forms this table describes standard forms scheme some forms appear more than one row because they cannot easily be classified into single function language forms marked l this table are classed derived library forms standard are often implemented macros using more fundamental forms practice making task implementation much easier than other languages standard forms language r5rs scheme purpose forms definition define binding constructs lambda do l let l let l letrec l conditional evaluation if cond l case l l l sequential evaluation begin iteration lambda do l named let l syntactic extension define-syntax let-syntax letrec-syntax syntax-rules r5rs syntax-case r6rs quoting quote' unquote quasiquote` unquote-splicing@ assignment set delayed evaluation delay l note that begin defined library syntax r5rs but expander needs know about achieve splicing functionality r6rs no longer library syntax standard procedures following two tables describe standard procedures r5rs scheme r6rs far more extensive summary this type would not be practical some procedures appear more than one row because they cannot easily be classified into single function language standard procedures language r5rs scheme purpose procedures construction vector make-vector make-string list equivalence predicates eq eqv equal string= string-ci= char= char-ci= type conversion vector->list list->vector number->string string->number symbol->string string->symbol char->integer integer->char string->list list->string numbers see separate table strings string make-string string string-length string-ref string-set string= string-ci= string string-ci> string>= string-ci>= substring string-append string->list list->string string-copy string-fill characters char char= char-ci= char char-ci> char>= char-ci>= char-alphabetic char-numeric char-whitespace char-upper-case char-lower-case char->integer integer->char char-upcase char-downcase vectors make-vector vector vector vector-length vector-ref vector-set vector->list list->vector vector-fill symbols symbol->string string->symbol symbol pairs lists pair cons car cdr set-car set-cdr null list list length append reverse list-tail list-ref memq memv member assq assv assoc list->vector vector->list list->string string->list identity predicates boolean pair symbol number char string vector port procedure continuations call-with-current-continuation call/cc values call-with-values dynamic-wind environments eval scheme-report-environment null-environment interaction-environment optional input/output display newline read write read-char write-char peek-char char-ready eof-object open-input-file open-output-file close-input-port close-output-port input-port output-port current-input-port current-output-port call-with-input-file call-with-output-file with-input-from-fileoptional with-output-to-fileoptional system interface load optional transcript-on optional transcript-off optional delayed evaluation force functional programming procedure apply map for-each booleans boolean not string character procedures that contain -ci their names perform case-independent comparisons between their arguments upper case lower case versions same character are taken be equal standard numeric procedures language r5rs scheme purpose procedures basic arithmetic operators + - / abs quotient remainder modulo gcd lcm expt sqrt rational numbers numerator denominator rational rationalize approximation floor ceiling truncate round exactness inexact->exact exact->inexact exact inexact inequalities >= = miscellaneous predicates zero negative positive odd even maximum minimum max min trigonometry sin cos tan asin acos atan exponentials exp log complex numbers make-rectangular make-polar real-part imag-part magnitude angle complex input-output number->string string->number type predicates integer rational real complex number implementations - / that take more than two arguments are defined but left optional at r5rs scheme requests for implementation main article scheme requests for implementation because scheme's minimalism many common procedures syntactic forms are not defined by standard order keep core language small but facilitate standardization extensions scheme community has scheme request for implementation srfi process by which extension libraries are defined through careful discussion extension proposals this promotes code portability many srfis are supported by all most scheme implementations srfis with fairly wide support different implementations include feature-based conditional expansion construct list library homogeneous numeric vector datatypes basic string ports receive binding multiple values defining record types string library character-set library syntax for procedures variable arity generalized set multithreading support time data types procedures multi-dimensional array primitives notation for specializing parameters without currying sources random bits basic format strings localization nested multi-line comments special form for recursive evaluation args-fold program argument processor parameter objects streams eager comprehensions vector library primitives for expressing iterative lazy algorithms integers bits more general cond clause octet vectors compare procedures full list accepted finalized srfis available at implementations main category scheme programming language implementations elegant minimalist design has made scheme popular target for language designers hobbyists educators because its small size that typical interpreter also popular choice for embedded systems scripting this has resulted scores implementations most which differ from each other so much that porting programs from one implementation another quite difficult small size standard language means that writing useful program any great complexity standard portable scheme almost impossible r6rs standard specifies much broader language attempt broaden its appeal programmers almost all implementations provide traditional lisp-style read–eval–print loop for development debugging many also compile scheme programs executable binary support for embedding scheme code programs written other languages also common relative simplicity scheme implementations makes popular choice for adding scripting capabilities larger systems developed languages such c gambit chicken bigloo work by compiling scheme c which makes embedding particularly easy addition bigloo's compiler can be configured generate jvm bytecode also features experimental bytecode generator for net some implementations support additional features for example kawa jscheme provide integration with java classes scheme c compilers often make easy use external libraries written c up allowing embedding actual c code scheme source another example pvts which offers set visual tools for supporting learning scheme usage scheme widely used by number schools particular number introductory computer science courses use scheme conjunction with textbook structure interpretation computer programs sicp for past years plt has run programbydesign formerly teachscheme project which has exposed close high school teachers thousands high school students rudimentary scheme programming mit's old introductory programming class was taught scheme although has been replaced by more modern courses sicp continues be taught at mit textbook how design programs by matthias felleisen currently at northeastern university used by some institutes higher education for their introductory computer science courses both northeastern university worcester polytechnic institute use scheme exclusively for their introductory courses fundamentals computer science cs2500 introduction program design cs1101 respectively rose-hulman uses scheme its more advanced programming language concepts course indiana university's introductory class c211 taught entirely scheme introductory class at uc berkeley cs 61a was until recently taught entirely scheme save minor diversions into logo demonstrate dynamic scope all course materials including lecture webcasts are available online free charge introductory computer science courses at yale grinnell college are also taught scheme programming design paradigms mandatory course for computer science graduate students at northeastern university also extensively uses scheme introductory computer science course at university minnesota - twin cities csci also uses scheme its primary language followed by course that introduces students java programming language software industry tata consultancy services asia's largest software consultancy firm uses scheme their month-long training program for fresh college graduates scheme is/was also used for following document style semantics specification language dsssl which provides method specifying sgml stylesheets uses scheme subset well-known open source raster graphics editor gimp uses tinyscheme scripting language guile has been adopted by gnu project its official scripting language that implementation scheme embedded such applications gnu lilypond gnucash scripting language for extensions likewise guile used be scripting language for desktop environment gnome gnome still has project that provides guile bindings its library stack there project incorporate guile into gnu emacs gnu's flagship program replacing current emacs lisp interpreter elk scheme used by synopsys scripting language for its technology cad tcad tools shiro kawai senior programmer on movie final fantasy spirits within used scheme scripting language for managing real-time rendering engine google app inventor for android uses scheme where kawa used compile scheme code down byte-codes for java virtual machine running on android devices see also computer programming portal mit/gnu scheme stalin compiler compiler for scheme structure interpretation computer programs classic computer science textbook essentials programming languages another classic computer science textbook lisp small pieces book showing how implement scheme lisp scheme how design programs which intends teach principles that go beyond scheme address perceived incongruities sicp call-with-current-continuation call/cc sxml illustrative representation for xml scheme that provides straightforward approach xml data processing scheme crpg game haxima written scheme references b c d e sperber michael dybvig r kent flatt matthew van straaten anton et al august revised6 report on algorithmic language scheme r6rs scheme steering committee retrieved common lisp language 2nd ed guy l steele jr digital press isbn 978-1-55558-041-4 common lisp new dialect lisp successor maclisp influenced strongly by zetalisp some extent by scheme interlisp b 1178-1990 reaff ieee standard for scheme programming language ieee part number stdpd14209 unanimously reaffirmed at meeting ieee-sa standards board standards review committee revcom march item on minutes reaffirmation minutes accessed october note this document only available for purchase from ieee not available online at time writing b c d e f g h i j k l m n o p q richard kelsey william clinger jonathan rees et al august revised5 report on algorithmic language scheme higher-order symbolic computation 7–105 doi101023/a1010051815785 retrieved r6rs ratification-voting results scheme steering committee retrieved b c will clinger marc feeley chris hanson jonathan rees olin shivers position statement draft scheme steering committee retrieved cs1 maint multiple names authors list link b c d gerald jay sussman guy l steele jr december first report on scheme revisited pdf higher-order symbolic computation 399–404 doi 101023/a1010079421970 issn 1388-3690 retrieved abdulaziz ghuloum r6rs libraries syntax-case system psyntax ikarus scheme retrieved revised^6 report on algorithmic language scheme appendix e language changes scheme steering committee retrieved r6rs electorate scheme steering committee retrieved marc feeley compilation implementors' intentions concerning r6rs scheme steering committee r6rs-discuss mailing list retrieved r7rs 9th draft available pdf will clinger extension voting period scheme language steering committee scheme-reports mailing list retrieved r7rs final available pdf scheme implementation so-named because interpreter was written by richard kelsey jonathan rees hours august 6th – 7th see richard kelsey jonathan rees mike sperber incomplete scheme reference manual for release jonathan rees s48org retrieved b gerald jay sussman & guy lewis steele jr december scheme interpreter for extended lambda calculus postscript pdf ai memos mit ai lab aim-349 retrieved joel moses june function function lisp why funarg problem should be called environment problem pdf ai memo retrieved useful metaphor for difference between function quote lisp think quote porous open covering function since free variables escape current environment function acts closed nonporous covering hence term closure used by landin thus we talk open lambda expressions functions lisp are usually lambda expressions closed lambda expressions my interest environment problem began while landin who had deep understanding problem visited mit during 1966-67 i then realized correspondence between funarg lists which are results evaluation closed lambda expressions lisp iswim's lambda closures gerald jay sussman & guy lewis steele jr march lambda ultimate imperative postscript pdf ai memos mit ai lab aim-353 retrieved gabriel richard p pitman kent technical issues separation function cells value cells lisp symbolic computation published june pp 81–101 doi 101007/bf01806178 retrieved b philip l bewig srfi streams srfi editors schemersorg retrieved william clinger jonathan rees editors revised4 report on algorithmic language scheme acm lisp pointers 1–55 retrieved jonathan rees scheme things june meeting postscript lisp pointers v4 october–december retrieved taylor campbell srfi s-expression comments srfi editors schemersorg retrieved william d clinger srfi basic string ports srfi editors schemersorg retrieved scott g miller srfi basic format strings srfi editors schemersorg retrieved jw backus fl bauer jgreen c katz j mccarthy p naur et al january–april revised report on algorithmic language algol numerische mathematik communications acm journal british computer society retrieved jonathan rees william clinger eds december revised3 report on algorithmic language scheme dedicated memory algol acm sigplan notices 37–79 doi101145/1504215043 retrieved scheme systems supporting srfis srfi editors schemersorg retrieved known implementations scheme are listed by scheme-faq-standards community scheme wiki retrieved ed martin list scheme-using schools schemers inc retrieved list sicp-using schools mit press retrieved eric grimson spring structure interpretation computer programs mit open courseware retrieved alex vandiver nelson elhage et al january - zombies drink caffeinated mit csail retrieved cs fundamentals computer science i northeastern university cs introduction program design a05 course software worcester polytechnic institute csse programming language concepts rose-hulman institute technology brian harvey fall computer science 61a berkeley department electrical engineering computer sciences berkeley retrieved dana angluin fall introduction computer science cpsc zoo yale university computer science department retrieved programming design paradigms csg107 course readings northeastern university college computer information science fall retrieved structure computer programming i computer science department university minnesota spring accessed 2010-1-30 robin cover dsssl - document style semantics specification language iso/iec cover pages retrieved major scripting language for gimp that has been attached today scheme from dov grobgeld gimp basic scheme tutorial gimp team retrieved todd graham lewis david zoll julian missig gnome faq from internet archive gnome team gnomeorg archived from original on retrieved guile-gnome free software foundation retrieved laurence brevard synopsys map-insm program update eda interoperability developers' forum pdf synopsis inc retrieved kawai shiro october gluing things together - scheme real-time cg content production proceedings first international lisp conference san francisco 342–348 retrieved bill magnuson hal abelson & mark friedman under hood app inventor for android google inc official google research blog retrieved felleisen findler flatt krishnamurthi structure interpretation computer science curriculum journal functional programming retrieved nazghul project further reading introduction scheme its implementation mirror christopher t haynes scheme programming language standardization experience guy l steele jr richard p gabriel evolution lisp pdf cs1 maint multiple names authors list link gerald sussman guy steele scheme interpreter for extended lambda calculus ai memo mit artificial intelligence laboratory cambridge massachusetts december external links wikimedia commons has media related scheme programming language wikibooks has book on topic scheme programming wikibooks has book on topic write yourself scheme hours revised7 report on algorithmic language scheme revised6 report on algorithmic language scheme tutorial for new scheme programmers text teach yourself scheme fixnum days by dorai sitaram scheme at dmoz scheme requests for implementation srfi schemersorg tour scheme gambit introduction on how do software development gambit scheme for people with experiences general programming languages learning scheme r6rs using drracket ide bibliography scheme-related research concrete abstractions introduction computer science using scheme timeline lisp dialectsedit lisp lisp maclisp maclisp interlisp interlisp zetalisp lisp machine lisp scheme scheme nil nil common lisp common lisp t t emacs lisp emacs lisp autolisp autolisp islisp islisp eulisp eulisp picolisp picolisp racket racket arc arc clojure clojure lfe lfe hy hy retrieved from https//enwikipediaorg/w/indexphptitle=schemeprogramminglanguage&oldid=749302873 categories lisp programming language family academic programming languages articles with example scheme code dynamically typed programming languages extensible syntax programming languages multi-paradigm programming languages programming languages created scheme programming language hidden categories cs1 maint multiple names authors list pages using isbn magic links pages using deprecated image syntax articles needing additional references from may all articles needing additional references all articles with unsourced statements articles with unsourced statements from august commons category with local link same on wikidata articles with dmoz links navigation menu personal tools not logged talk contributions create account log namespaces article talk variants views read edit view history more search navigation main page contents featured content current events random article donate wikipedia wikipedia store interaction help about wikipedia community portal recent changes contact page tools what links here related changes upload file special pages permanent link page information wikidata item cite this page print/export create book download pdf printable version other projects wikimedia commons wikibooks languages azərbaycanca বাংলা беларуская български català čeština dansk deutsch eesti ελληνικά español esperanto فارسی français 한국어 հայերեն hrvatski italiano עברית lietuvių magyar മലയാളം nederlands 日本語 norsk bokmål norsk nynorsk polski português română русиньскый русский simple english slovenčina slovenščina српски / srpski srpskohrvatski / српскохрватски suomi svenska தமிழ் тоҷикӣ türkçe українська tiếng việt žemaitėška 中文 edit links this page was last modified on november at text available under creative commons attribution-sharealike license additional terms may apply by using this site you agree terms use privacy policy wikipedia® registered trademark wikimedia foundation inc non-profit organization privacy policy about wikipedia disclaimers contact wikipedia developers cookie statement mobile view 