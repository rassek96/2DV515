algorithm from wikipedia free encyclopedia jump navigation search for other uses see algorithm disambiguation flow chart algorithm euclid's algorithm for calculating greatest common divisor gcd two numbers b locations named b algorithm proceeds by successive subtractions two loops if test b ≥ yields yes true more accurately number b location b greater than equal number location then algorithm specifies b ← b − meaning number b − replaces old b similarly if > b then ← − b process terminates when contents b yielding gcd algorithm derived from scott symbols drawing style from tausworthe mathematics computer science algorithm i/ˈælɡərɪðəm/ al-gə-ri-dhəm self-contained step-by-step set operations be performed algorithms perform calculation data processing and/or automated reasoning tasks english word 'algorithm' comes from medieval latin word algorism greek word arithmos ἀριθμός word 'algorism' therefore derived word 'algorithm' comes from al-khwārizmī persian خوارزمی‎‎ c 780–850 persian mathematician astronomer geographer scholar english adopted french term but wasn't until late 19th century that algorithm took on meaning that has modern english english was first used about then by chaucer another early use word from manual titled carmen de algorismo composed by alexandre de villedieu begins thus haec algorismus ars praesens dicitur qua / talibus indorum fruimur bis quinque figuris which translates algorism art by which at present we use those indian figures which number two times five poem not very long only few hundred lines summarizes art calculating with new style indian dice talibus indorum hindu numerals al-adad al-hindi algorithm effective method that can be expressed within finite amount space time well-defined formal language for calculating function starting from initial state initial input perhaps empty instructions describe computation that when executed proceeds through finite number well-defined successive states eventually producing output terminating at final ending state transition from one state next not necessarily deterministic some algorithms known randomized algorithms incorporate random input concept algorithm has existed for centuries however partial formalization what would become modern algorithm began with attempts solve entscheidungsproblem decision problem posed by david hilbert subsequent formalizations were framed attempts define effective calculability effective method those formalizations included gödel–herbrand–kleene recursive functions alonzo church's lambda calculus emil post's formulation alan turing's turing machines 1936–7 giving formal definition algorithms corresponding intuitive notion remains challenging problem contents informal definition formalization o expressing algorithms implementation computer algorithms examples o algorithm example o euclid’s algorithm + computer language for euclid's algorithm + inelegant program for euclid's algorithm + elegant program for euclid's algorithm o testing euclid algorithms o measuring improving euclid algorithms algorithmic analysis o formal versus empirical o execution efficiency classification o by implementation o by design paradigm o optimization problems o by field study o by complexity continuous algorithms legal issues etymology history development notion algorithm o ancient near east o discrete distinguishable symbols o manipulation symbols place holders for numbers algebra o mechanical contrivances with discrete states o mathematics during 19th century up mid-20th century o emil post alan turing 1936–37 o j b rosser s c kleene o history after see also notes references o secondary references further reading external links informal definition for detailed presentation various points view on definition algorithm see algorithm characterizations informal definition could be set rules that precisely defines sequence operations which would include all computer programs including programs that do not perform numeric calculations generally program only algorithm if stops eventually prototypical example algorithm euclid's algorithm determine maximum common divisor two integers example there are others described by flow chart above example later section boolos & jeffrey offer informal meaning word following quotation no human being can write fast enough long enough small enough† †smaller smaller without limit you'd be trying write on molecules on atoms on electrons list all members enumerably infinite set by writing out their names one after another some notation but humans can do something equally useful case certain enumerably infinite sets they can give explicit instructions for determining nth member set for arbitrary finite n such instructions are be given quite explicitly form which they could be followed by computing machine by human who capable carrying out only very elementary operations on symbols enumerably infinite set one whose elements can be put into one-to-one correspondence with integers thus boolos jeffrey are saying that algorithm implies instructions for process that creates output integers from arbitrary input integer integers that theory can be arbitrarily large thus algorithm can be algebraic equation such y = m + n – two arbitrary input variables m n that produce output y but various authors' attempts define notion indicate that word implies much more than this something on order for addition example precise instructions language understood by computer for fast efficient good process that specifies moves computer machine human equipped with necessary internally contained information capabilities find decode then process arbitrary input integers/symbols m n symbols + = effectively produce reasonable time output-integer y at specified place specified format concept algorithm also used define notion decidability that notion central for explaining how formal systems come into being starting from small set axioms rules logic time that algorithm requires complete cannot be measured not apparently related with our customary physical dimension from such uncertainties that characterize ongoing work stems unavailability definition algorithm that suits both concrete some sense abstract usage term formalization algorithms are essential way computers process data many computer programs contain algorithms that detail specific instructions computer should perform specific order carry out specified task such calculating employees' paychecks printing students' report cards thus algorithm can be considered be any sequence operations that can be simulated by turing-complete system authors who assert this thesis include minsky savage gurevich minsky but we will also maintain with turing that any procedure which could naturally be called effective can fact be realized by simple machine although this may seem extreme arguments its favor are hard refute gurevich turing's informal argument favor his thesis justifies stronger thesis every algorithm can be simulated by turing machine according savage algorithm computational process defined by turing machine typically when algorithm associated with processing information data are read from input source written output device and/or stored for further processing stored data are regarded part internal state entity performing algorithm practice state stored one more data structures for some such computational process algorithm must be rigorously defined specified way applies all possible circumstances that could arise that any conditional steps must be systematically dealt with case-by-case criteria for each case must be clear computable because algorithm precise list precise steps order computation always crucial functioning algorithm instructions are usually assumed be listed explicitly are described starting from top going down bottom idea that described more formally by flow control so far this discussion formalization algorithm has assumed premises imperative programming this most common conception attempts describe task discrete mechanical means unique this conception formalized algorithms assignment operation setting value variable derives from intuition memory scratchpad there example below such assignment for some alternate conceptions what constitutes algorithm see functional programming logic programming expressing algorithms algorithms can be expressed many kinds notation including natural languages pseudocode flowcharts drakon-charts programming languages control tables processed by interpreters natural language expressions algorithms tend be verbose ambiguous are rarely used for complex technical algorithms pseudocode flowcharts drakon-charts control tables are structured ways express algorithms that avoid many ambiguities common natural language statements programming languages are primarily intended for expressing algorithms form that can be executed by computer but are often used way define document algorithms there wide variety representations possible one can express given turing machine program sequence machine tables see more at finite state machine state transition table control table flowcharts drakon-charts see more at state diagram form rudimentary machine code assembly code called sets quadruples see more at turing machine representations algorithms can be classed into three accepted levels turing machine description high-level description prose describe algorithm ignoring implementation details at this level we do not need mention how machine manages its tape head implementation description prose used define way turing machine uses its head way that stores data on its tape at this level we do not give details states transition function formal description most detailed lowest level gives turing machine's state table for example simple algorithm add m+n described all three levels see algorithmexamples implementation logical nand algorithm implemented electronically chip most algorithms are intended be implemented computer programs however algorithms are also implemented by other means such biological neural network for example human brain implementing arithmetic insect looking for food electrical circuit mechanical device computer algorithms flowchart examples canonical böhm-jacopini structures sequence rectangles descending page while-do if-then-else three structures are made primitive conditional goto if test=true then goto step xxx diamond unconditional goto rectangle various assignment operators rectangle halt rectangle nesting these structures inside assignment-blocks result complex diagrams cf tausworthe computer systems algorithm basically instance logic written software by software developers be effective for intended target computers produce output from given perhaps null input optimal algorithm even running old hardware would produce faster results than non-optimal higher time complexity algorithm for same purpose running more efficient hardware that why algorithms like computer hardware are considered technology elegant compact programs good fast programs notion simplicity elegance appears informally knuth precisely chaitin knuth we want good algorithms some loosely defined aesthetic sense one criterion length time taken perform algorithm other criteria are adaptability algorithm computers its simplicity elegance etc chaitin program 'elegant' by which i mean that it's smallest possible program for producing output that does chaitin prefaces his definition with i'll show you can't prove that program 'elegant'—such proof would solve halting problem ibid algorithm versus function computable by algorithm for given function multiple algorithms may exist this true even without expanding available instruction set available programmer rogers observes that important distinguish between notion algorithm ie procedure notion function computable by algorithm ie mapping yielded by procedure same function may have several different algorithms unfortunately there may be tradeoff between goodness speed elegance compactness—an elegant program may take more steps complete computation than one less elegant example that uses euclid's algorithm appears below computers computors models computation computer human computor restricted type machine discrete deterministic mechanical device that blindly follows its instructions melzak's lambek's primitive models reduced this notion four elements i discrete distinguishable locations ii discrete indistinguishable counters iii agent iv list instructions that are effective relative capability agent minsky describes more congenial variation lambek's abacus model his very simple bases for computability minsky's machine proceeds sequentially through its five six depending on how one counts instructions unless either conditional if–then goto unconditional goto changes program flow out sequence besides halt minsky's machine includes three assignment replacement substitution operations zero eg contents location replaced by l ← successor eg l ← l+1 decrement eg l ← l − rarely must programmer write code with such limited instruction set but minsky shows do melzak lambek that his machine turing complete with only four general types instructions conditional goto unconditional goto assignment/replacement/substitution halt simulation algorithm computer computor language knuth advises reader that best way learn algorithm try immediately take pen paper work through example but what about simulation execution real thing programmer must translate algorithm into language that simulator/computer/computor can effectively execute stone gives example this when computing roots quadratic equation computor must know how take square root if they don't then algorithm be effective must provide set rules for extracting square root this means that programmer must know language that effective relative target computing agent computer/computor but what model should be used for simulation van emde boas observes even if we base complexity theory on abstract instead concrete machines arbitrariness choice model remains at this point that notion simulation enters when speed being measured instruction set matters for example subprogram euclid's algorithm compute remainder would execute much faster if programmer had modulus instruction available rather than just subtraction worse just minsky's decrement structured programming canonical structures per church–turing thesis any algorithm can be computed by model known be turing complete per minsky's demonstrations turing completeness requires only four instruction types—conditional goto unconditional goto assignment halt kemeny kurtz observe that while undisciplined use unconditional gotos conditional if-then gotos can result spaghetti code programmer can write structured programs using only these instructions on other hand also possible not too hard write badly structured programs structured language tausworthe augments three böhm-jacopini canonical structures sequence if-then-else while-do with two more do-while case additional benefit structured program that lends itself proofs correctness using mathematical induction canonical flowchart symbols graphical aide called flowchart offers way describe document algorithm computer program one like program flow minsky machine flowchart always starts at top page proceeds down its primary symbols are only four directed arrow showing program flow rectangle sequence goto diamond if-then-else dot or-tie böhm–jacopini canonical structures are made these primitive shapes sub-structures can nest rectangles but only if single exit occurs from superstructure symbols their use build canonical structures are shown diagram examples further information list algorithms algorithm example animation quicksort algorithm sorting array randomized values red bars mark pivot element at start animation element farthest right hand side chosen pivot one simplest algorithms find largest number list numbers random order finding solution requires looking at every number list from this follows simple algorithm which can be stated high-level description english prose high-level description if there are no numbers set then there no highest number assume first number set largest number set for each remaining number set if this number larger than current largest number consider this number be largest number set when there are no numbers left set iterate over consider current largest number be largest number set quasi-formal description written prose but much closer high-level language computer program following more formal coding algorithm pseudocode pidgin code algorithm largestnumber input list numbers l output largest number list l if lsize = return null largest ← l for each item l do if item > largest then largest ← item return largest ← shorthand for changes for instance largest ← item means that value largest changes value item return terminates algorithm outputs value that follows euclid’s algorithm further information euclid's algorithm example-diagram euclid's algorithm from tl heath with more detail added euclid does not go beyond third measuring gives no numerical examples nicomachus gives example i subtract less from greater left then again i subtract from this same for this possible left i subtract this from left from which i again subtract for this possible left but cannot be subtracted from heath comments that last phrase curious but meaning obvious enough also meaning phrase about ending 'at one same number'heath euclid’s algorithm compute greatest common divisor gcd two numbers appears proposition ii book vii elementary number theory his elements euclid poses problem thus given two numbers not prime one another find their greatest common measure he defines number multitude composed units counting number positive integer not including zero measure place shorter measuring length s successively q times along longer length l until remaining portion r less than shorter length s modern words remainder r = l − q×s q being quotient remainder r modulus integer-fractional part left over after division for euclid’s method succeed starting lengths must satisfy two requirements i lengths must not be zero ii subtraction must be “proper” ie test must guarantee that smaller two numbers subtracted from larger alternately two can be equal so their subtraction yields zero euclid's original proof adds third requirement two lengths must not be prime one another euclid stipulated this so that he could construct reductio ad absurdum proof that two numbers' common measure fact greatest while nicomachus' algorithm same euclid's when numbers are prime one another yields number for their common measure so be precise following really nicomachus' algorithm graphical expression euclid's algorithm find greatest common divisor for = 650×2 + = 299×2 + = 52×5 + = 39×1 + = 13×3 + computer language for euclid's algorithm only few instruction types are required execute euclid's algorithm—some logical tests conditional goto unconditional goto assignment replacement subtraction location symbolized by upper case letters eg s etc varying quantity number location written lower case letters usually associated with location's name for example location l at start might contain number l = inelegant program for euclid's algorithm inelegant translation knuth's version algorithm with subtraction-based remainder-loop replacing his use division modulus instruction derived from knuth 19732–4 depending on two numbers inelegant may compute gcd fewer steps than elegant following algorithm framed knuth's four-step version euclid's nicomachus' but rather than using division find remainder uses successive subtractions shorter length s from remaining length r until r less than s high-level description shown boldface adapted from knuth 19732–4 input input l s r ← l e0 if r > s then contents l larger number so skip over exchange-steps goto step else swap contents r s l ← r this first step redundant but useful for later discussion r ← s s ← l e1 until remaining length r r less than shorter length s s repeatedly subtract measuring number s s from remaining length r r if s > r then done measuring so goto else measure again r ← r − s goto e2 either i last measure was exact remainder r zero program can halt ii algorithm must continue last measure left remainder r less than measuring number s if r = then done so goto step else continue step e3 nut euclid's algorithm use remainder r measure what was previously smaller number s l serves temporary location l ← r r ← s s ← l goto output print s done halt end stop elegant program for euclid's algorithm following version euclid's algorithm requires only six core instructions do what thirteen are required do by inelegant worse inelegant requires more types instructions flowchart elegant can be found at top this article unstructured basic language steps are numbered instruction let = assignment instruction symbolized by ← rem euclid's algorithm for greatest common divisor print type two integers greater than input ab if b=0 then goto if > b then goto let b=b-a goto let a=a-b goto print end following version can be used with object oriented languages // euclid's algorithm for greatest common divisor integer euclidalgorithm int int b{ a=mathabsa b=mathabsb while b=0{ if a>b a=a-b else b=b-a } return } how elegant works place outer euclid loop elegant shifts back forth between two co-loops > b loop that computes ← − b b ≤ loop that computes b ← b − this works because when at last minuend m less than equal subtrahend s difference = minuend − subtrahend minuend can become s new measuring length subtrahend can become new r length be measured other words sense subtraction reverses testing euclid algorithms does algorithm do what its author wants do few test cases usually suffice confirm core functionality one source uses knuth suggested another interesting case two relatively prime numbers but exceptional cases must be identified tested will inelegant perform properly when r > s s > r r = s ditto for elegant b > > b = b yes all what happens when one number zero both numbers are zero inelegant computes forever all cases elegant computes forever when = what happens if negative numbers are entered fractional numbers if input numbers ie domain function computed by algorithm/program include only positive integers including zero then failures at zero indicate that algorithm program that instantiates partial function rather than total function notable failure due exceptions ariane flight rocket failure june proof program correctness by use mathematical induction knuth demonstrates application mathematical induction extended version euclid's algorithm he proposes general method applicable proving validity any algorithm tausworthe proposes that measure complexity program be length its correctness proof measuring improving euclid algorithms elegance compactness versus goodness speed with only six core instructions elegant clear winner compared inelegant at thirteen instructions however inelegant faster arrives at halt fewer steps algorithm analysis indicates why this case elegant does two conditional tests every subtraction loop whereas inelegant only does one algorithm usually requires many loop-throughs on average much time wasted doing b = test that needed only after remainder computed can algorithms be improved once programmer judges program fit effective—that computes function intended by its author—then question becomes can be improved compactness inelegant can be improved by elimination five steps but chaitin proved that compacting algorithm cannot be automated by generalized algorithm rather can only be done heuristically ie by exhaustive search examples be found at busy beaver trial error cleverness insight application inductive reasoning etc observe that steps are repeated steps comparison with elegant provides hint that these steps together with steps can be eliminated this reduces number core instructions from thirteen eight which makes more elegant than elegant at nine steps speed elegant can be improved by moving b=0 test outside two subtraction loops this change calls for addition three instructions b = = goto now elegant computes example-numbers faster whether this always case for any given b r s would require detailed analysis algorithmic analysis main article analysis algorithms frequently important know how much particular resource such time storage theoretically required for given algorithm methods have been developed for analysis algorithms obtain such quantitative answers estimates for example sorting algorithm above has time requirement on using big o notation with n length list at all times algorithm only needs remember two values largest number found so far its current position input list therefore said have space requirement o1 if space required store input numbers not counted on if counted different algorithms may complete same task with different set instructions less more time space 'effort' than others for example binary search algorithm with cost olog n outperforms sequential search cost on when used for table lookups on sorted lists arrays formal versus empirical main articles empirical algorithmics profiling computer programming program optimization analysis study algorithms discipline computer science often practiced abstractly without use specific programming language implementation this sense algorithm analysis resembles other mathematical disciplines that focuses on underlying properties algorithm not on specifics any particular implementation usually pseudocode used for analysis simplest most general representation however ultimately most algorithms are usually implemented on particular hardware / software platforms their algorithmic efficiency eventually put test using real code for solution one off problem efficiency particular algorithm may not have significant consequences unless n extremely large but for algorithms designed for fast interactive commercial long life scientific usage may be critical scaling from small n large n frequently exposes inefficient algorithms that are otherwise benign empirical testing useful because may uncover unexpected interactions that affect performance benchmarks may be used compare before/after potential improvements algorithm after program optimization execution efficiency main article algorithmic efficiency illustrate potential improvements possible even well established algorithms recent significant innovation relating fft algorithms used heavily field image processing can decrease processing time up times for applications like medical imaging general speed improvements depend on special properties problem which are very common practical applications speedups this magnitude enable computing devices that make extensive use image processing like digital cameras medical equipment consume less power classification there are various ways classify algorithms each with its own merits by implementation one way classify algorithms by implementation means recursion recursive algorithm one that invokes makes reference itself repeatedly until certain condition also known termination condition matches which method common functional programming iterative algorithms use repetitive constructs like loops sometimes additional data structures like stacks solve given problems some problems are naturally suited for one implementation other for example towers hanoi well understood using recursive implementation every recursive version has equivalent but possibly more less complex iterative version vice versa logical algorithm may be viewed controlled logical deduction this notion may be expressed algorithm = logic + control logic component expresses axioms that may be used computation control component determines way which deduction applied axioms this basis for logic programming paradigm pure logic programming languages control component fixed algorithms are specified by supplying only logic component appeal this approach elegant semantics change axioms has well-defined change algorithm serial parallel distributed algorithms are usually discussed with assumption that computers execute one instruction algorithm at time those computers are sometimes called serial computers algorithm designed for such environment called serial algorithm opposed parallel algorithms distributed algorithms parallel algorithms take advantage computer architectures where several processors can work on problem at same time whereas distributed algorithms utilize multiple machines connected with network parallel distributed algorithms divide problem into more symmetrical asymmetrical subproblems collect results back together resource consumption such algorithms not only processor cycles on each processor but also communication overhead between processors some sorting algorithms can be parallelized efficiently but their communication overhead expensive iterative algorithms are generally parallelizable some problems have no parallel algorithms are called inherently serial problems deterministic non-deterministic deterministic algorithms solve problem with exact decision at every step algorithm whereas non-deterministic algorithms solve problems via guessing although typical guesses are made more accurate through use heuristics exact approximate while many algorithms reach exact solution approximation algorithms seek approximation that close true solution approximation may use either deterministic random strategy such algorithms have practical value for many hard problems quantum algorithm they run on realistic model quantum computation term usually used for those algorithms which seem inherently quantum use some essential feature quantum computation such quantum superposition quantum entanglement by design paradigm another way classifying algorithms by their design methodology paradigm there certain number paradigms each different from other furthermore each these categories include many different types algorithms some common paradigms are brute-force exhaustive search this naive method trying every possible solution see which best divide conquer divide conquer algorithm repeatedly reduces instance problem one more smaller instances same problem usually recursively until instances are small enough solve easily one such example divide conquer merge sorting sorting can be done on each segment data after dividing data into segments sorting entire data can be obtained conquer phase by merging segments simpler variant divide conquer called decrease conquer algorithm that solves identical subproblem uses solution this subproblem solve bigger problem divide conquer divides problem into multiple subproblems so conquer stage more complex than decrease conquer algorithms example decrease conquer algorithm binary search algorithm search enumeration many problems such playing chess can be modeled problems on graphs graph exploration algorithm specifies rules for moving around graph useful for such problems this category also includes search algorithms branch bound enumeration backtracking randomized algorithm such algorithms make some choices randomly pseudo-randomly they can be very useful finding approximate solutions for problems where finding exact solutions can be impractical see heuristic method below for some these problems known that fastest approximations must involve some randomness whether randomized algorithms with polynomial time complexity can be fastest algorithms for some problems open question known p versus np problem there are two large classes such algorithms monte carlo algorithms return correct answer with high-probability eg rp subclass these that run polynomial time las vegas algorithms always return correct answer but their running time only probabilistically bound eg zpp reduction complexity this technique involves solving difficult problem by transforming into better known problem for which we have hopefully asymptotically optimal algorithms goal find reducing algorithm whose complexity not dominated by resulting reduced algorithm's for example one selection algorithm for finding median unsorted list involves first sorting list expensive portion then pulling out middle element sorted list cheap portion this technique also known transform conquer optimization problems for optimization problems there more specific classification algorithms algorithm for such problems may fall into one more general categories described above well into one following linear programming when searching for optimal solutions linear function bound linear equality inequality constraints constraints problem can be used directly producing optimal solutions there are algorithms that can solve any problem this category such popular simplex algorithm problems that can be solved with linear programming include maximum flow problem for directed graphs if problem additionally requires that one more unknowns must be integer then classified integer programming linear programming algorithm can solve such problem if can be proved that all restrictions for integer values are superficial ie solutions satisfy these restrictions anyway general case specialized algorithm algorithm that finds approximate solutions used depending on difficulty problem dynamic programming when problem shows optimal substructures — meaning optimal solution problem can be constructed from optimal solutions subproblems — overlapping subproblems meaning same subproblems are used solve many different problem instances quicker approach called dynamic programming avoids recomputing solutions that have already been computed for example floyd–warshall algorithm shortest path goal from vertex weighted graph can be found by using shortest path goal from all adjacent vertices dynamic programming memoization go together main difference between dynamic programming divide conquer that subproblems are more less independent divide conquer whereas subproblems overlap dynamic programming difference between dynamic programming straightforward recursion caching memoization recursive calls when subproblems are independent there no repetition memoization does not help hence dynamic programming not solution for all complex problems by using memoization maintaining table subproblems already solved dynamic programming reduces exponential nature many problems polynomial complexity greedy method greedy algorithm similar dynamic programming algorithm that works by examining substructures this case not problem but given solution such algorithms start with some solution which may be given have been constructed some way improve by making small modifications for some problems they can find optimal solution while for others they stop at local optima that at solutions that cannot be improved by algorithm but are not optimum most popular use greedy algorithms for finding minimal spanning tree where finding optimal solution possible with this method huffman tree kruskal prim sollin are greedy algorithms that can solve this optimization problem heuristic method optimization problems heuristic algorithms can be used find solution close optimal solution cases where finding optimal solution impractical these algorithms work by getting closer closer optimal solution they progress principle if run for infinite amount time they will find optimal solution their merit that they can find solution very close optimal solution relatively short time such algorithms include local search tabu search simulated annealing genetic algorithms some them like simulated annealing are non-deterministic algorithms while others like tabu search are deterministic when bound on error non-optimal solution known algorithm further categorized approximation algorithm by field study see also list algorithms every field science has its own problems needs efficient algorithms related problems one field are often studied together some example classes are search algorithms sorting algorithms merge algorithms numerical algorithms graph algorithms string algorithms computational geometric algorithms combinatorial algorithms medical algorithms machine learning cryptography data compression algorithms parsing techniques fields tend overlap with each other algorithm advances one field may improve those other sometimes completely unrelated fields for example dynamic programming was invented for optimization resource consumption industry but now used solving broad range problems many fields by complexity see also complexity class parameterized complexity algorithms can be classified by amount time they need complete compared their input size constant time if time needed by algorithm same regardless input size eg access array element linear time if time proportional input size eg traverse list logarithmic time if time logarithmic function input size eg binary search algorithm polynomial time if time power input size eg bubble sort algorithm has quadratic time complexity exponential time if time exponential function input size eg brute-force search some problems may have multiple algorithms differing complexity while other problems might have no algorithms no known efficient algorithms there are also mappings from some problems other problems owing this was found be more suitable classify problems themselves instead algorithms into equivalence classes based on complexity best possible algorithms for them continuous algorithms adjective continuous when applied word algorithm can mean algorithm operating on data that represents continuous quantities even though this data represented by discrete approximations—such algorithms are studied numerical analysis algorithm form differential equation that operates continuously on data running on analog computer legal issues see also software patents for general overview patentability software including computer-implemented algorithms algorithms by themselves are not usually patentable united states claim consisting solely simple manipulations abstract concepts numbers signals does not constitute processes uspto hence algorithms are not patentable gottschalk v benson however practical applications algorithms are sometimes patentable for example diamond v diehr application simple feedback algorithm aid curing synthetic rubber was deemed patentable patenting software highly controversial there are highly criticized patents involving algorithms especially data compression algorithms such unisys' lzw patent additionally some cryptographic algorithms have export restrictions see export cryptography etymology words 'algorithm' 'algorism' come from name al-khwārizmī al-khwārizmī persian خوارزمی‎‎ c 780–850 was persian mathematician astronomer geographer scholar house wisdom baghdad whose name means 'the native khwarezm' region that was part greater iran now uzbekistan about he wrote treatise arabic language which was translated into latin 12th century under title algoritmi de numero indorum this title means algoritmi on numbers indians where algoritmi was translator's latinization al-khwarizmi's name al-khwarizmi was most widely read mathematician europe late middle ages primarily through his other book algebra late medieval latin algorismus english 'algorism' corruption his name simply meant decimal number system 15th century under influence greek word ἀριθμός 'number' cf 'arithmetic' latin word was altered algorithmus corresponding english term 'algorithm' first attested 17th century modern sense was introduced 19th century history development notion algorithm ancient near east algorithms were used ancient greece two examples are sieve eratosthenes which was described introduction arithmetic by nicomachusch euclidean algorithm which was first described euclid's elements c bcch babylonian clay tablets describe employ algorithmic procedures compute time place significant astronomical events discrete distinguishable symbols tally-marks keep track their flocks their sacks grain their money ancients used tallying accumulating stones marks scratched on sticks making discrete symbols clay through babylonian egyptian use marks symbols eventually roman numerals abacus evolved dilson p 16–41 tally marks appear prominently unary numeral system arithmetic used turing machine post–turing machine computations manipulation symbols place holders for numbers algebra work ancient greek geometers euclidean algorithm indian mathematician brahmagupta islamic mathematics al-khwarizmi from whose name terms algorism algorithm are derived western european mathematicians culminated leibniz's notion calculus ratiocinator ca good century half ahead his time leibniz proposed algebra logic algebra that would specify rules for manipulating logical concepts manner that ordinary algebra specifies rules for manipulating numbers mechanical contrivances with discrete states clock bolter credits invention weight-driven clock key invention particular verge escapement that provides us with tick tock mechanical clock accurate automatic machine led immediately mechanical automata beginning 13th century finally computational machines—the difference engine analytical engines charles babbage countess ada lovelace mid-19th century lovelace credited with first creation algorithm intended for processing on computer – babbage's analytical engine first device considered real turing-complete computer instead just calculator – sometimes called history's first programmer result though full implementation babbage's second device would not be realized until decades after her lifetime logical machines 1870—stanley jevons' logical abacus logical machine technical problem was reduce boolean equations when presented form similar what are now known karnaugh maps jevons describes first simple abacus slips wood furnished with pins contrived so that any part class combinations can be picked out mechanically more recently however i have reduced system completely mechanical form have thus embodied whole indirect process inference what may be called logical machine his machine came equipped with certain moveable wooden rods at foot are keys like those piano with this machine he could analyze syllogism any other simple logical argument this machine he displayed before fellows royal society another logician john venn however his symbolic logic turned jaundiced eye this effort i have no high estimate myself interest importance what are sometimes called logical machines does not seem me that any contrivances at present known likely be discovered really deserve name logical machines see more at algorithm characterizations but not be outdone he too presented plan somewhat analogous i apprehend prof jevon's abacus gain corresponding prof jevons's logical machine following contrivance may be described i prefer call merely logical-diagram machine but i suppose that could do very completely all that can be rationally expected any logical machine jacquard loom hollerith punch cards telegraphy telephony—the electromechanical relay bell newell indicate that jacquard loom precursor hollerith cards punch cards telephone switching technologies were roots tree leading development first computers by mid-19th century telegraph precursor telephone was use throughout world its discrete distinguishable encoding letters dots dashes common sound by late 19th century ticker tape ca 1870s was use was use hollerith cards us census then came teleprinter ca with its punched-paper use baudot code on tape telephone-switching networks electromechanical relays invented was behind work george stibitz inventor digital adding device he worked bell laboratories he observed burdensome' use mechanical calculators with gears he went home one evening intending test his idea when tinkering was over stibitz had constructed binary adding device davis observes particular importance electromechanical relay with its two binary states open closed was only with development beginning 1930s electromechanical calculators using electrical relays that machines were built having scope babbage had envisioned mathematics during 19th century up mid-20th century symbols rules rapid succession mathematics george boole gottlob frege giuseppe peano 1888–1889 reduced arithmetic sequence symbols manipulated by rules peano's principles arithmetic presented by new method was first attempt at axiomatization mathematics symbolic language but heijenoort gives frege this kudos frege's perhaps most important single work ever written logic which we see 'formula language' that lingua characterica language written with special symbols for pure thought that free from rhetorical embellishments constructed from specific symbols that are manipulated according definite rules work frege was further simplified amplified by alfred north whitehead bertrand russell their principia mathematica 1910–1913 paradoxes at same time number disturbing paradoxes appeared literature particular burali-forti paradox russell paradox 1902–03 richard paradox resultant considerations led kurt gödel's paper 1931—he specifically cites paradox liar—that completely reduces rules recursion numbers effective calculability effort solve entscheidungsproblem defined precisely by hilbert mathematicians first set about define what was meant by effective method effective calculation effective calculability ie calculation that would succeed rapid succession following appeared alonzo church stephen kleene jb rosser's λ-calculus finely honed definition general recursion from work gödel acting on suggestions jacques herbrand cf gödel's princeton lectures subsequent simplifications by kleene church's proof that entscheidungsproblem was unsolvable emil post's definition effective calculability worker mindlessly following list instructions move left right through sequence rooms while there either mark erase paper observe paper make yes-no decision about next instruction alan turing's proof that entscheidungsproblem was unsolvable by use his a- machine—in effect almost identical post's formulation j barkley rosser's definition effective method terms machine s c kleene's proposal precursor church thesis that he called thesis i few years later kleene's renaming his thesis church's thesis proposing turing's thesis emil post alan turing 1936–37 here remarkable coincidence two men not knowing each other but describing process men-as-computers working on computations—and they yield virtually identical definitions emil post described actions computer human being follows two concepts are involved that symbol space which work leading from problem answer be carried out fixed unalterable set directions his symbol space would be two way infinite sequence spaces boxes problem solver worker move work this symbol space being capable being operating but one box at time box admit but two possible conditions ie being empty unmarked having single mark say vertical stroke one box be singled out called starting point specific problem be given symbolic form by finite number boxes being marked with stroke likewise answer be given symbolic form by such configuration marked boxes set directions applicable general problem sets up deterministic process when applied each specific problem this process terminates only when comes direction type c see more at post–turing machine alan turing's statue at bletchley park alan turing's work preceded that stibitz unknown whether stibitz knew work turing turing's biographer believed that turing's use typewriter-like model derived from youthful interest alan had dreamt inventing typewriters boy mrs turing had typewriter he could well have begun by asking himself what was meant by calling typewriter 'mechanical' given prevalence morse code telegraphy ticker tape machines teletypewriters we might conjecture that all were influences turing—his model computation now called turing machine—begins did post with analysis human computer that he whittles down simple set basic motions states mind but he continues step further creates machine model computation numbers computing normally done by writing certain symbols on paper we may suppose this paper divided into squares like child's arithmetic booki assume then that computation carried out on one-dimensional paper ie on tape divided into squares i shall also suppose that number symbols which may be printed finite behaviour computer at any moment determined by symbols which he observing his state mind at that moment we may suppose that there bound b number symbols squares which computer can observe at one moment if he wishes observe more he must use successive observations we will also suppose that number states mind which need be taken into account finite let us imagine that operations performed by computer be split up into 'simple operations' which are so elementary that not easy imagine them further divided turing's reduction yields following simple operations must therefore include changes symbol on one observed squares b changes one squares observed another square within l squares one previously observed squares may be that some these change necessarily invoke change state mind most general single operation must therefore be taken be one following possible change symbol together with possible change state mind b possible change b observed squares together with possible change state mind we may now construct machine do work this computer few years later turing expanded his analysis thesis definition with this forceful expression function said be effectively calculable if its values can be found by some purely mechanical process though fairly easy get intuitive grasp this idea nevertheless desirable have some more definite mathematical expressible definition we may take this statement literally understanding by purely mechanical process one which could be carried out by machine possible give mathematical description certain normal form structures these machines development these ideas leads author's definition computable function identification computability † with effective calculability † we shall use expression computable function mean function calculable by machine we let effectively calculable refer intuitive idea without particular identification with any one these definitions j b rosser s c kleene j barkley rosser defined 'effective method' following manner italicization added 'effective method' used here rather special sense method each step which precisely determined which certain produce answer finite number steps with this special meaning three different precise definitions have been given date simplest these state due post turing says essentially that effective method solving certain sets problems exists if one can build machine which will then solve any problem set with no human intervention beyond inserting question later reading answer all three definitions are equivalent so doesn't matter which one used moreover fact that all three are equivalent very strong argument for correctness any one rosser 1939225–6 rosser's footnote references work church kleene their definition λ-definability particular church's use his unsolvable problem elementary number theory herbrand gödel their use recursion particular gödel's use his famous paper on formally undecidable propositions principia mathematica related systems i post turing 1936–7 their mechanism-models computation stephen c kleene defined his now-famous thesis i known church–turing thesis but he did this following context boldface original algorithmic theories setting up complete algorithmic theory what we do describe procedure performable for each set values independent variables which procedure necessarily terminates such manner that from outcome we can read definite answer yes no question predicate value true kleene history after number efforts have been directed toward further refinement definition algorithm activity on-going because issues surrounding particular foundations mathematics especially church–turing thesis philosophy mind especially arguments about artificial intelligence for more see algorithm characterizations see also abstract machine algorithm engineering algorithm characterizations algorithmic composition algorithmic synthesis algorithmic trading garbage garbage out introduction algorithms list algorithm general topics list important publications theoretical computer science – algorithms numerical mathematics consortium theory computation o computability theory o computational complexity theory notes any classical mathematical algorithm for example can be described finite number english words rogers well defined with respect agent that executes algorithm there computing agent usually human which can react instructions carry out computations rogers algorithm procedure for computing function with respect some chosen notation for integers this limitation numerical functions results no loss generality rogers algorithm has zero more inputs ie quantities which are given initially before algorithm begins knuth procedure which has all characteristics algorithm except that possibly lacks finiteness may be called 'computational method' knuth algorithm has one more outputs ie quantities which have specified relation inputs knuth whether not process with random interior processes not including input algorithm debatable rogers opines that computation carried out discrete stepwise fashion without use continuous methods analogue devices carried forward deterministically without resort random methods devices eg dice rogers kleene davis rosser davis moschovakis yiannis n what algorithm engquist b schmid w mathematics unlimited — beyond springer pp 919–936 part ii isbn stone stone simply requires that must terminate finite number steps stone 19737–8 boolos jeffrey cf stone knuth states practice we not only want algorithms we want good algorithms one criterion goodness length time taken perform algorithm other criteria are adaptability algorithm computers its simplicity elegance etc cf stone stone 19737–8 states that there must be procedure that robot can follow order determine precisely how obey instruction stone adds finiteness process definiteness having no ambiguity instructions this definition knuth loc cit minsky p gurevich sipser knuth chaitin rogers 19871–2 his essay calculations by man machine conceptual analysis seig credits this distinction robin gandy cf wilfred seig et al reflections on foundations mathematics essays honor solomon feferman association for symbolic logic k peters ltd natick ma cf gandy robin gandy church's thesis principles for mechanisms appearing on pp 123–148 j barwise et al kleene symposium north-holland publishing company robot computer robot that performs any task that can be described sequence instructions cf stone lambek’s abacus countably infinite number locations holes wires etc together with unlimited supply counters pebbles beads etc locations are distinguishable counters are not holes have unlimited capacity standing by agent who understands able carry out list instructions lambek lambek references melzak who defines his q-machine indefinitely large number locations indefinitely large supply counters distributed among these locations program operator whose sole purpose carry out program melzak b-b-j loc cit add stipulation that holes are capable holding any number stones p both melzak lambek appear canadian mathematical bulletin vol no september if no confusion results word counters can be dropped location can be said contain single number we say that instruction effective if there procedure that robot can follow order determine precisely how obey instruction stone cf minsky chapter computer models chapter very simple bases for computability pp 255–281 particular cf knuth but always preceded by if–then avoid improper subtraction however few different assignment instructions eg decrement increment zero/clear/empty for minsky machine are also required for turing-completeness their exact specification somewhat up designer unconditional goto convenience can be constructed by initializing dedicated location zero eg instruction z ← thereafter instruction if z=0 then goto xxx unconditional knuth stone methods for extracting roots are not trivial see methods computing square roots leeuwen jan handbook theoretical computer science algorithms complexity volume elsevier p isbn 978-0-444-88071-0 john g kemeny thomas e kurtz back basic history corruption future language addison-wesley publishing company inc reading ma isbn 0-201-13433-0 tausworthe tausworthe knuth section expanded by tausworthe at pages 100ff chapter cf tausworthe heath hawking’s dover edition derives from heath 'let cd measuring bf leave fa less than itself' this neat abbreviation for saying measure along ba successive lengths equal cd until point f reached such that length fa remaining less than cd other words let bf be largest exact multiple cd contained ba heath for modern treatments using division algorithm see hardy wright knuth volume plus more discussion euclid's algorithm knuth 1969293–297 volume euclid covers this question his proposition euclid's elements book vii proposition aleph0clarkuedu retrieved may knuth 197313–18 he credits formulation algorithm-proving terms asertions induction r w floyd peter naur c r hoare h h goldstine j von neumann tausworth borrows knuth's euclid example extends knuth's method section formal proofs pages 288–298 tausworthe cf knuth vol i his more-detailed analyses on pp 1969294–313 vol ii breakdown occurs when algorithm tries compact itself success would solve halting problem gillian conahan january better math makes faster data networks discovermagazinecom haitham hassanieh piotr indyk dina katabi eric price acm-siam symposium on discrete algorithms soda kyoto january see also sfft web page kowalski carroll sue daughtrey taz july fundamental concepts for software quality engineer american society for quality pp et seq isbn 978-0-87389-720-4 for instance volume convex polytope described using membership oracle can be approximated high accuracy by randomized polynomial time algorithm but not by deterministic one see dyer martin frieze alan kannan ravi january random polynomial-time algorithm for approximating volume convex bodies j acm new york ny usa acm 1–17 doi 101145/102782102783 george b dantzig mukund n thapa linear programming theory extensions springer-verlag tsypkin adaptation learning automatic systems academic press p isbn 978-0-08-095582-7 hogendijk jan p al-khwarzimi pythagoras 4–5 archived from original on april oaks jeffrey was al-khwarizmi applied algebraist university indianapolis retrieved brezina corona al-khwarizmi inventor algebra rosen publishing group isbn 978-1-4042-0513-0 foremost mathematical texts history according carl b boyer oxford english dictionary third edition sv eratosthenes b cooke roger l history mathematics brief course john wiley & sons isbn aaboe asger episodes from early history astronomy new york springer pp 40–62 isbn 0-387-95136-9 davis bolter bolter bolter 198433–34 204–206 all quotes from w stanley jevons elementary lessons logic deductive inductive macmillan co london new york republished googlebook cf jevons 1880199–201 louis couturat algebra logic open court publishing company chicago london republished googlebook cf couturat 191475–76 gives few more details interestingly he compares this typewriter well piano jevons states that account be found at jan proceedings royal society jevons 1880199–200 all quotes from john venn symbolic logic macmillan co london republished googlebook cf venn 1881120–125 interested reader can find deeper explanation those pages bell newell diagram cf davis melina hill valley news correspondent tinkerer gets place history valley news west lebanon nh thursday march page davis van heijenoort 196781ff van heijenoort's commentary on frege's begriffsschrift formula language modeled upon that arithmetic for pure thought van heijenoort dixon cf kleene 195236–40 cf footnote alonzo church 1936a davis 1936b davis kleene 1935–6 davis 1965237ff kleene davis 1965255ff church davis 196588ff cf formulation i post davis 1965289–290 turing 1936–7 davis 1965116ff rosser davis kleene davis 1965273–274 kleene kleene turing 1936–7 davis 1965289–290 turing davis turing davis hodges p turing 1936–7116 b turing 1936–7 davis turing davis references axt p on subrecursive hierarchy primitive recursive degrees transactions american mathematical society 85–105 doi102307/1993169 jstor bell c gordon newell allen computer structures readings examples mcgraw–hill book company new york isbn 0-07-004357-4 blass andreas gurevich yuri algorithms quest for absolute definitions pdf bulletin european association for theoretical computer science includes excellent bibliography references boolos george jeffrey richard computability logic 4th ed cambridge university press london isbn 0-521-20402-x cf chapter turing machines where they discuss certain enumerable sets not effectively mechanically enumerable burgin mark super-recursive algorithms springer isbn 978-0-387-95569-8 campagnolo ml moore c costa jf analog characterization subrecursive functions proc 4th conference on real numbers computers odense university pp 91–109 church alonzo 1936a unsolvable problem elementary number theory american journal mathematics 345–363 doi 102307/2371045 jstor reprinted undecidable p 89ff first expression church's thesis see particular page undecidable where he defines notion effective calculability terms algorithm he uses word terminates etc church alonzo 1936b note on entscheidungsproblem journal symbolic logic 40–41 doi102307/2269326 jstor church alonzo correction note on entscheidungsproblem journal symbolic logic 101–102 doi102307/2269030 jstor reprinted undecidable p 110ff church shows that entscheidungsproblem unsolvable about pages text pages footnotes daffa' ali abdullah al- muslim contribution mathematics london croom helm isbn 0-85664-464-1 davis martin undecidable basic papers on undecidable propositions unsolvable problems computable functions new york raven press isbn 0-486-43228-9 davis gives commentary before each article papers gödel alonzo church turing rosser kleene emil post are included those cited article are listed here by author's name davis martin engines logic mathematicians origin computer new york w w nortion isbn 0-393-32229-7 davis offers concise biographies leibniz boole frege cantor hilbert gödel turing with von neumann show-stealing villain very brief bios joseph-marie jacquard babbage ada lovelace claude shannon howard aiken etc this article incorporates public domain material from nist document black paul e algorithm dictionary algorithms data structures dean tim evolution moral diversity baltic international yearbook cognition logic communication dennett daniel darwin's dangerous idea new york touchstone/simon & schuster isbn 0-684-80290-2 yuri gurevich sequential abstract state machines capture sequential algorithms acm transactions on computational logic vol no july pages 77–111 includes bibliography sources kleene stephen c general recursive functions natural numbers mathematische annalen 727–742 doi101007/bf01565439 presented american mathematical society september reprinted undecidable p 237ff kleene's definition general recursion known now mu-recursion was used by church his paper unsolvable problem elementary number theory that proved decision problem be undecidable ie negative result kleene stephen c recursive predicates quantifiers american mathematical society transactions 41–73 doi 102307/1990131 jstor reprinted undecidable p 255ff kleene refined his definition general recursion proceeded his chapter algorithmic theories posit thesis i p he would later repeat this thesis kleene name church's thesiskleene ie church thesis kleene stephen c introduction metamathematics tenth ed north-holland publishing company isbn 0-7204-2103-9 excellent—accessible readable—reference source for mathematical foundations knuth donald fundamental algorithms third edition reading massachusetts addison–wesley isbn 0-201-89683-4 knuth donald volume 2/seminumerical algorithms art computer programming first edition reading massachusetts addison–wesley kosovsky n k elements mathematical logic its application theory subrecursive algorithms lsu publ leningrad kowalski robert algorithm=logic+control communications acm 424–436 doi101145/359131359136 markov theory algorithms imprint moscow academy sciences ussr description p cm added tp russian translation works mathematical institute academy sciences ussr v original title teoriya algerifmov minsky marvin computation finite infinite machines first ed prentice-hall englewood cliffs nj isbn 0-13-165449-7 minsky expands his idea algorithm—an effective procedure chapter computability effective procedures algorithms infinite machines post emil finite combinatory processes formulation i journal symbolic logic 103–105 doi102307/2269031 jstor reprinted undecidable p 289ff post defines simple algorithmic-like process man writing marks erasing marks going from box box eventually halting he follows list simple instructions this cited by kleene one source his thesis i so-called church–turing thesis rogers jr hartley theory recursive functions effective computability mit press isbn 0-262-68052-1 rosser jb informal exposition proofs godel's theorem church's theorem journal symbolic logic 53–60 doi102307/2269059 jstor reprinted undecidable p 223ff herein rosser's famous definition effective method method each step which precisely predetermined which certain produce answer finite number steps machine which will then solve any problem set with no human intervention beyond inserting question later reading answer p 225–226 undecidable santos-lang christopher moral ecology approaches machine ethics van rysewyk simon pontier matthijs machine medical ethics pdf switzerland springer pp 111–127 doi101007/978-3-319-08108-38 scott michael l programming language pragmatics 3rd ed morgan kaufmann publishers/elsevier isbn 978-0-12-374514-9 sipser michael introduction theory computation pws publishing company isbn 0-534-94728-x sober elliott wilson david sloan unto others evolution psychology unselfish behavior cambridge harvard university press stone harold s introduction computer organization data structures ed mcgraw-hill new york isbn 0-07-061726-0 cf particular first chapter titled algorithms turing machines programs his succinct informal definition any sequence instructions that can be obeyed by robot called algorithm p tausworthe robert c standardized development computer software part methods englewood cliffs nj prentice–hall inc isbn 0-13-842195-1 turing alan m 1936–37 on computable numbers with application entscheidungsproblem proceedings london mathematical society series 230–265 doi 101112/plms/s2-421230 corrections ibid vol pp 544–546 reprinted undecidable p 116ff turing's famous paper completed master's dissertation while at king's college cambridge uk turing alan m systems logic based on ordinals proceedings london mathematical society 161–228 doi 101112/plms/s2-451161 reprinted undecidable p 155ff turing's paper that defined oracle was his phd thesis while at princeton usa united states patent trademark office >mathematical algorithms patentability manual patent examining procedure mpep latest revision august secondary references bolter david j turing's man western culture computer age ed university north carolina press chapel hill nc isbn 0-8078-1564-0 isbn 0-8078-4108-0 pbk dilson jesse abacus ed st martin's press ny isbn 0-312-10409-x isbn 0-312-10409-x pbk van heijenoort jean from frege gödel source book mathematical logic 1879–1931 ed harvard university press cambridge ma isbn 0-674-32449-8 3rd edition isbn 0-674-32449-8 pbk hodges andrew alan turing enigma ed simon schuster new york isbn 0-671-49207-1 isbn 0-671-49207-1 cf chapter spirit truth for history leading discussion his proof further reading jean luc chabert history algorithms from pebble microchip springer verlag isbn 978-3-540-63369-3 algorithmics spirit computing addison-wesley isbn 978-0-321-11784-7 knuth donald e selected papers on analysis algorithms stanford california center for study language information knuth donald e selected papers on design algorithms stanford california center for study language information berlinski david advent algorithm 300-year journey from idea computer harvest books isbn 978-0-15-601391-8 thomas h cormen charles e leiserson ronald l rivest clifford stein introduction algorithms third edition mit press isbn 978-0262033848 external links look up algorithm wiktionary free dictionary wikibooks has book on topic algorithms at wikiversity you can learn more teach others about algorithm at department algorithm hazewinkel michiel ed algorithm encyclopedia mathematics springer isbn 978-1-55608-010-4 algorithms at dmoz weisstein eric w algorithm mathworld dictionary algorithms data structures —national institute standards technology algorithms data structures by dr nikolai bezroukov algorithm repositories stony brook algorithm repository —state university new york at stony brook netlib repository —university tennessee oak ridge national laboratory collected algorithms acm —association for computing machinery stanford graphbase —stanford university combinatorica —university iowa state university new york at stony brook library efficient datastructures algorithms leda —previously from max-planck-institut für informatik lecture notes algorithms course materials jeff erickson university illinois authority control lccn sh85003487 gnd 4001183-5 bnf cb119358199 data ndl bne xx527980 retrieved from https//enwikipediaorg/w/indexphptitle=algorithm&oldid=751833319 categories algorithms mathematical logic theoretical computer science hidden categories pages using isbn magic links use mdy dates from june articles including recorded pronunciations articles containing persian-language text articles with dmoz links wikipedia articles with lccn identifiers wikipedia articles with gnd identifiers wikipedia articles with bnf identifiers articles with example pseudocode navigation menu personal tools not logged talk contributions create account log namespaces article talk variants views read edit view history more search navigation main page contents featured content current events random article donate wikipedia wikipedia store interaction help about wikipedia community portal recent changes contact page tools what links here related changes upload file special pages permanent link page information wikidata item cite this page print/export create book download pdf printable version other projects wikimedia commons wikibooks wikiquote languages afrikaans alemannisch አማርኛ العربية aragonés অসমীয়া asturianu azərbaycanca বাংলা bân-lâm-gú башҡортса беларуская беларуская тарашкевіца‎ български bosanski català čeština dansk deutsch eesti ελληνικά español esperanto euskara فارسی føroyskt français gaeilge galego gĩkũyũ 한국어 հայերեն हिन्दी hrvatski ido ilokano bahasa indonesia interlingua íslenska italiano עברית ქართული қазақша kurdî кыргызча ລາວ latina latviešu lëtzebuergesch lietuvių lumbaart magyar македонски മലയാളം मराठी مصرى bahasa melayu mirandés монгол မြန်မာဘာသာ nederlands नेपाली नेपाल भाषा 日本語 norsk bokmål norsk nynorsk occitan олык марий oromoo oʻzbekcha/ўзбекча ਪੰਜਾਬੀ پنجابی polski português qaraqalpaqsha română русиньскый русский саха тыла scots shqip sicilianu සිංහල simple english slovenčina slovenščina کوردیی ناوەندی српски / srpski srpskohrvatski / српскохрватски basa sunda suomi svenska tagalog தமிழ் татарча/tatarça తెలుగు ไทย тоҷикӣ türkçe українська اردو tiếng việt walon winaray ייִדיש 粵語 中文 edit links this page was last modified on november at text available under creative commons attribution-sharealike license additional terms may apply by using this site you agree terms use privacy policy wikipedia® registered trademark wikimedia foundation inc non-profit organization privacy policy about wikipedia disclaimers contact wikipedia developers cookie statement mobile view 