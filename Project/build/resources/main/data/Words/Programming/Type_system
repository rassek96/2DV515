type system from wikipedia free encyclopedia jump navigation search this article about type systems from point-of-view computer programming for theoretical formulation see type theory this article has multiple issues please help improve discuss these issues on talk page learn how when remove these template messages this article includes list references but its sources remain unclear because has insufficient inline citations please help improve this article by introducing more precise citations october learn how when remove this template message this article written like personal reflection opinion essay that states wikipedia editor's personal feelings about topic please help improve by rewriting encyclopedic style july learn how when remove this template message learn how when remove this template message type systems general concepts type safety major categories static vs dynamic manifest vs inferred nominal vs structural duck typing minor categories dependent flow-sensitive gradual latent substructural unique see also strong weak typing programming languages type system collection rules that assign property called type various constructs computer program consists such variables expressions functions modules main purpose type system reduce possibilities for bugs computer programs by defining interfaces between different parts computer program then checking that parts have been connected consistent way this checking can happen statically at compile time dynamically at run time combination static dynamic checking type systems have other purposes well such enabling certain compiler optimizations allowing for multiple dispatch providing form documentation etc type system associates type with each computed value by examining flow these values attempts ensure prove that no type errors can occur particular type system question determines exactly what constitutes type error but general aim prevent operations expecting certain kind value from being used with values for which that operation does not make sense logic errors memory errors will also be prevented type systems are often specified part programming languages built into interpreters compilers for them although type system language can be extended by optional tools that perform additional kinds checks using language's original type syntax grammar contents usage overview fundamentals type checking o static type checking o dynamic type checking runtime type information o combining static dynamic type checking o static dynamic type checking practice o strong weak type systems o type safety memory safety o variable levels type checking o optional type systems polymorphism types o duck typing specialized type systems o dependent types o linear types o intersection types o union types o existential types o gradual typing explicit implicit declaration inference unified type system compatibility equivalence subtyping notes see also references further reading external links usage overview example simple type system that c language portions c program are function definitions one function invoked by another function interface function states name function list values that are passed function's code code invoking function states name invoked along with names variables that hold values pass during execution values are placed into temporary storage then execution jumps code invoked function invoked function's code accesses values makes use them if instructions inside function are written with assumption receiving integer value but calling code passed floating-point value then wrong result will be computed by invoked function c compiler checks type declared for each variable sent against type declared for each variable interface invoked function if types do not match compiler throws compile-time error compiler may also use static type value optimize storage needs choice algorithms for operations on value many c compilers float data type for example represented bits accord with ieee specification for single-precision floating point numbers they will thus use floating-point-specific microprocessor operations on those values floating-point addition multiplication etc depth type constraints manner their evaluation affect typing language programming language may further associate operation with varying concrete algorithms on each type case type polymorphism type theory study type systems although concrete type systems programming languages originate from practical issues computer architecture compiler implementation language design fundamentals formally type theory studies type systems programming language must have occurrence type check using type system whether at compile time runtime manually annotated automatically inferred mark manasse concisely put fundamental problem addressed by type theory ensure that programs have meaning fundamental problem caused by type theory that meaningful programs may not have meanings ascribed them quest for richer type systems results from this tension assigning data type— typing— gives meaning sequences bits such value memory some object such variable hardware general purpose computer unable discriminate between for example memory address instruction code between character integer floating-point number because makes no intrinsic distinction between any possible values that sequence bits might mean associating sequence bits with type conveys that meaning programmable hardware form symbolic system composed that hardware some program program associates each value with at least one particular type but also can occur that one value associated with many subtypes other entities such objects modules communication channels dependencies can become associated with type even type can become associated with type implementation type system could theory associate identifications called data type type value class type object kind type type metatype these are abstractions that typing can go through on hierarchy levels contained system when programming language evolves more elaborate type system gains more finely grained rule set than basic type checking but this comes at price when type inferences other properties become undecidable when more attention must be paid by programmer annotate code consider computer-related operations functioning challenging find sufficiently expressive type system that satisfies all programming practices type safe manner more type restrictions that are imposed by compiler more strongly typed programming language strongly typed languages often require programmer make explicit conversions contexts where implicit conversion would cause no harm pascal's type system has been described too strong because for example size array string part its type making some programming tasks difficult haskell also strongly typed but its types are automatically inferred so that explicit conversions are often but not always unnecessary programming language compiler can also implement dependent type effect system which enables even more program specifications be verified by type checker beyond simple value-type pairs virtual region code associated with effect component describing what being done with what enabling for example throw error report thus symbolic system may be type effect system which endows with more safety checking than type checking alone whether automated by compiler specified by programmer type system makes program behavior illegal that outside type-system rules advantages provided by programmer-specified type systems include abstraction modularity – types enable programmers think at higher level than bit byte not bothering with low-level implementation for example programmers can begin think string collection character values instead mere array bytes higher still types enable programmers think about express interfaces between two any-sized subsystems this enables more levels localization so that definitions required for interoperability subsystems remain consistent when those two subsystems communicate documentation – more expressive type systems types can serve form documentation clarifying intent programmer for instance if programmer declares function returning timestamp type this documents function when timestamp type can be explicitly declared deeper code be integer type advantages provided by compiler-specified type systems include optimization – static type-checking may provide useful compile-time information for example if type requires that value must align memory at multiple four bytes compiler may be able use more efficient machine instructions safety – type system enables compiler detect meaningless probably invalid code for example we can identify expression / hello world invalid when rules do not specify how divide integer by string strong typing offers more safety but cannot guarantee complete type safety type safety contributes program correctness but can only guarantee correctness at expense making type checking itself undecidable problem type system with automated type checking program may prove run incorrectly yet be safely typed produce no compiler errors division by zero unsafe incorrect operation but type checker running only at compile time doesn't scan for division by zero most programming languages then left runtime error prove absence these more-general-than-types defects other kinds formal methods collectively known program analyses are common use alternatively sufficiently expressive type system such dependently typed languages can prevent these kinds errors for example expressing type non-zero numbers addition software testing empirical method for finding errors that type checker cannot detect type checking process verifying enforcing constraints types—type checking—may occur either at compile-time static check at run-time if language specification requires its typing rules strongly ie more less allowing only those automatic type conversions that do not lose information one can refer process strongly typed if not weakly typed terms are not usually used strict sense static type checking static type checking process verifying type safety program based on analysis program's text source code if program passes static type checker then program guaranteed satisfy some set type safety properties for all possible inputs because static type checking operates on program's text allows many bugs be caught early development cycle static type checking can be thought limited form program verification see type safety type-safe language static type checking can also be thought optimization if compiler can prove that program well-typed then does not need emit dynamic safety checks allowing resulting compiled binary run faster static type checking for turing-complete languages inherently conservative that if type system both sound meaning that rejects all incorrect programs decidable meaning that possible write algorithm that determines whether program well-typed then will always be possible define program that well-typed but that does not satisfy type checker for example consider program containing code if then else even if expression always evaluates true at run-time most type checkers will reject program ill-typed because difficult if not impossible for static analyzer determine that else branch will not be taken conversely static type checker will quickly detect type errors rarely used code paths without static type checking even code coverage tests with 100% coverage may be unable find such type errors tests may fail detect such type errors because combination all places where values are created all places where certain value used must be taken into account number useful common programming language features cannot be checked statically such downcasting therefore many languages will have both static dynamic type checking static type checker verifies what can dynamic checks verify rest many languages with static type checking provide way bypass type checker some languages allow programmers choose between static dynamic type safety for example c distinguishes between statically-typed dynamically-typed variables uses former are checked statically whereas uses latter are checked dynamically other languages allow users write code that not type-safe for example c programmers can freely cast value between any two types that have same size for list languages with static type checking see category for statically typed languages dynamic type checking runtime type information dynamic type checking process verifying type safety program at runtime implementations dynamically type-checked languages generally associate each runtime object with type tag ie reference type containing its type information this runtime type information rtti can also be used implement dynamic dispatch late binding downcasting reflection similar features most type-safe languages include some form dynamic type checking even if they also have static type checker reason for this that many useful features properties are difficult impossible verify statically for example suppose that program defines two types b where b subtype if program tries convert value type type b which known downcasting then operation legal only if value being converted actually value type b therefore dynamic check needed verify that operation safe this requirement one criticisms downcasting by definition dynamic type checking may cause program fail at runtime some programming languages possible anticipate recover from these failures others type-checking errors are considered fatal programming languages that include dynamic type checking but not static type checking are often called dynamically typed programming languages for list such languages see category for dynamically typed programming languages combining static dynamic type checking some languages allow both static dynamic typing type checking sometimes called soft typing for example java some other ostensibly statically typed languages support downcasting types their subtypes querying object discover its dynamic type other type operations that depend on runtime type information more generally most programming languages include mechanisms for dispatching over different 'kinds' data such disjoint unions subtype polymorphism variant types even when not interacting with type annotations type checking such mechanisms are materially similar dynamic typing implementations see programming language for more discussion interactions between static dynamic typing objects object oriented languages are usually accessed by reference whose static target type manifest type equal either object's run-time type its latent type supertype thereof this conformant with liskov substitution principle which states that all operations performed on instance given type can also be performed on instance subtype this concept also known subsumption some languages subtypes may also possess covariant contravariant return types argument types respectively certain languages for example clojure common lisp cython are dynamically type-checked by default but allow programs opt into static type checking by providing optional annotations one reason use such hints would be optimize performance critical sections program this formalized by gradual typing programming environment drscheme pedagogic environment based on lisp precursor language racket was also soft-typed conversely version c language provides way indicate that variable should not be statically type-checked variable whose type dynamic will not be subject static type checking instead program relies on runtime type information determine how variable may be used static dynamic type checking practice choice between static dynamic typing requires certain trade-offs static typing can find type errors reliably at compile time which should increase reliability delivered program however programmers disagree over how commonly type errors occur resulting further disagreements over proportion those bugs that are coded that would be caught by appropriately representing designed types code static typing advocates believe programs are more reliable when they have been well type-checked whereas dynamic-typing advocates point distributed code that has proven reliable small bug databases value static typing then presumably increases strength type system increased advocates dependently typed languages such dependent ml epigram have suggested that almost all bugs can be considered type errors if types used program are properly declared by programmer correctly inferred by compiler static typing usually results compiled code that executes more quickly when compiler knows exact data types that are use can produce optimized machine code further compilers for statically typed languages can find assembler shortcuts more easily some dynamically typed languages such common lisp allow optional type declarations for optimization for this very reason static typing makes this pervasive by contrast dynamic typing may allow compilers run more quickly allow interpreters dynamically load new code because changes source code dynamically typed languages may result less checking perform less code revisit this too may reduce edit-compile-test-debug cycle statically typed languages that lack type inference such c java require that programmers declare types they intend method function use this can serve additional documentation for program which compiler will not permit programmer ignore permit drift out synchronization however language can be statically typed without requiring type declarations examples include haskell scala ocaml f lesser extent c c++ so explicit type declaration not necessary requirement for static typing all languages dynamic typing allows constructs that some static type checking would reject illegal for example eval functions which execute arbitrary data code become possible eval function possible with static typing but requires advanced uses algebraic data types furthermore dynamic typing better accommodates transitional code prototyping such allowing placeholder data structure mock object be transparently used place full-fledged data structure usually for purposes experimentation testing dynamic typing typically allows duck typing which enables easier code reuse many languages with static typing also feature duck typing other mechanisms like generic programming that also enable easier code reuse dynamic typing typically makes metaprogramming easier use for example c++ templates are typically more cumbersome write than equivalent ruby python code since c++ has stronger rules regarding type definitions regards both functions variables this forces developer write more boilerplate code for template than python developer would need more advanced run-time constructs such metaclasses introspection are often more difficult use statically typed languages some languages such features may also be used eg generate new types behaviors on fly based on run-time data such advanced constructs are often provided by dynamic programming languages many these are dynamically typed although dynamic typing need not be related dynamic programming languages strong weak type systems main article strong weak typing languages are often colloquially referred strongly typed weakly typed fact there no universally accepted definition what these terms mean general there are more precise terms represent differences between type systems that lead people call them strong weak type safety memory safety main article type safety third way categorizing type system programming language uses safety typed operations conversions computer scientists consider language type-safe if does not allow operations conversions that violate rules type system some observers use term memory-safe language just safe language describe languages that do not allow programs access memory that has not been assigned for their use for example memory-safe language will check array bounds else statically guarantee ie at compile time before execution that array accesses out array boundaries will cause compile-time perhaps runtime errors consider following program language that both type-safe memory-safe var x = var y = var z = x + y this example variable z will have value although this may not be what programmer anticipated well-defined result if y were different string one that could not be converted number eg hello world result would be well-defined well note that program can be type-safe memory-safe still crash on invalid operation fact if program encounters operation that not type-safe terminating program often only option now consider similar example c int x = char y = char z = x + y this example z will point memory address five characters beyond y equivalent three characters after terminating zero character string pointed by y this memory that program not expected access may contain garbage data certainly doesn't contain anything useful this example shows c neither memory-safe nor type-safe language general type-safety memory-safety go hand hand for example language that supports pointer arithmetic number-to-pointer conversions like c neither memory-safe nor type-safe because allows arbitrary memory be accessed if were valid memory any type for more information see memory safety variable levels type checking some languages allow different levels checking apply different regions code examples include use strict directive javascript perl applies stronger checking @ operator php suppresses some error messages option strict on vbnet allows compiler require conversion between objects additional tools such lint ibm rational purify can also be used achieve higher level strictness optional type systems has been proposed chiefly by gilad bracha that choice type system be made independent choice language that type system should be module that can be plugged into language required he believes this advantageous because what he calls mandatory type systems make languages less expressive code more fragile requirement that types do not affect semantics language difficult fulfill for instance class-based inheritance becomes impossible optional typing related gradual typing but still distinct from polymorphism types main article polymorphism computer science term polymorphism refers ability code particular methods classes act on values multiple types ability different instances same data structure contain elements different types type systems that allow polymorphism generally do so order improve potential for code re-use language with polymorphism programmers need only implement data structure such list associative array once rather than once for each type element with which they plan use for this reason computer scientists sometimes call use certain forms polymorphism generic programming type-theoretic foundations polymorphism are closely related those abstraction modularity some cases subtyping duck typing main article duck typing duck typing statement calling method m on object does not rely on declared type object only that object whatever type must supply implementation method called when called at run-time duck typing differs from structural typing that if part whole module structure needed for given local computation present at runtime duck type system satisfied its type identity analysis on other hand structural type system would require analysis whole module structure at compile time determine type identity type dependence duck typing differs from nominative type system number aspects most prominent ones are that for duck typing type information determined at runtime contrasted compile time name type irrelevant determine type identity type dependence only partial structure information required for that for given point program execution duck typing uses premise that referring value if walks like duck quacks like duck then duck this reference duck test that attributed james whitcomb riley term may have been coined by alex martelli message complangpython newsgroup see python while one controlled experiment showed increase developer productivity for duck typing single developer projects other controlled experiments on api usability show opposite specialized type systems many type systems have been created that are specialized for use certain environments with certain types data for out-of-band static program analysis frequently these are based on ideas from formal type theory are only available part prototype research systems dependent types dependent types are based on idea using scalars values more precisely describe type some other value for example m t r i x {\displaystyle \mathrm {matrix} 33} might be type 3×3 matrix we can then define typing rules such following rule for matrix multiplication m t r i x m u l t i p l y m t r i x k m × m t r i x m n → m t r i x k n {\displaystyle \mathrm {matrix} {\mathrm {multiply} }\mathrm {matrix} km\times \mathrm {matrix} mn\to \mathrm {matrix} kn} where k {\displaystyle k} m {\displaystyle m} n {\displaystyle n} are arbitrary positive integer values variant ml called dependent ml has been created based on this type system but because type checking for conventional dependent types undecidable not all programs using them can be type-checked without some kind limits dependent ml limits sort equality can decide presburger arithmetic other languages such epigram make value all expressions language decidable so that type checking can be decidable however general proof decidability undecidable so many programs require hand-written annotations that may be very non-trivial this impedes development process many language implementations provide easy way out form option disable this condition this however comes at cost making type-checker run infinite loop when fed programs that do not type-check causing compilation fail linear types linear types based on theory linear logic closely related uniqueness types are types assigned values having property that they have one only one reference them at all times these are valuable for describing large immutable values such files strings so on because any operation that simultaneously destroys linear object creates similar object such 'str = str + a' can be optimized under hood into in-place mutation normally this not possible such mutations could cause side effects on parts program holding other references object violating referential transparency they are also used prototype operating system singularity for interprocess communication statically ensuring that processes cannot share objects shared memory order prevent race conditions clean language haskell-like language uses this type system order gain lot speed compared performing deep copy while remaining safe intersection types intersection types are types describing values that belong both two other given types with overlapping value sets for example most implementations c signed char has range unsigned char has range so intersection type these two types would have range such intersection type could be safely passed into functions expecting either signed unsigned chars because compatible with both types intersection types are useful for describing overloaded function types for example if int → int type functions taking integer argument returning integer float → float type functions taking float argument returning float then intersection these two types can be used describe functions that do one other based on what type input they are given such function could be passed into another function expecting int → int function safely simply would not use float → float functionality subclassing hierarchy intersection type ancestor type such its parent most derived type intersection sibling types empty forsythe language includes general implementation intersection types restricted form refinement types union types union types are types describing values that belong either two types for example c signed char has range unsigned char has range so union these two types would have overall virtual range that may be used partially depending on which union member accessed any function handling this union type would have deal with integers this complete range more generally only valid operations on union type are operations that are valid on both types being unioned c's union concept similar union types but not typesafe permits operations that are valid on either type rather than both union types are important program analysis where they are used represent symbolic values whose exact nature eg value type not known subclassing hierarchy union type ancestor type such its parent ancestor type union sibling types subtype their common ancestor that all operations permitted on their common ancestor are permitted on union type but they may also have other valid operations common existential types existential types are frequently used connection with record types represent modules abstract data types due their ability separate implementation from interface for example type t = ∃x { x f x → int } describes module interface that has data member named type x function named f that takes parameter same type x returns integer this could be implemented different ways for example intt = { int f int → int } floatt = { float f float → int } these types are both subtypes more general existential type t correspond concrete implementation types so any value one these types value type t given value t type t we know that tfta well-typed regardless what abstract type x this gives flexibility for choosing types suited particular implementation while clients that use only values interface type—the existential type—are isolated from these choices general it's impossible for typechecker infer which existential type given module belongs above example intt { int f int → int } could also have type ∃x { x f int → int } simplest solution annotate every module with its intended type eg intt = { int f int → int } ∃x { x f x → int } although abstract data types modules had been implemented programming languages for quite some time wasn't until that john c mitchell gordon plotkin established formal theory under slogan abstract types have existential type theory second-order typed lambda calculus similar system f but with existential instead universal quantification gradual typing gradual typing type system which variables may be typed either at compile-time which static typing at run-time which dynamic typing allowing software developers choose either type paradigm appropriate from within single language particular gradual typing uses special type named dynamic represent statically-unknown types gradual typing replaces notion type equality with new relation called consistency that relates dynamic type every other type consistency relation symmetric but not transitive explicit implicit declaration inference for more details on this topic see type inference many static type systems such those c java require type declarations programmer must explicitly associate each variable with particular type others such haskell's perform type inference compiler draws conclusions about types variables based on how programmers use those variables for example given function fx y that adds x y together compiler can infer that x y must be numbers – since addition only defined for numbers therefore any call f elsewhere program that specifies non-numeric type such string list argument would signal error numerical string constants expressions code can often do imply type particular context for example expression might imply type floating-point while might imply list integers – typically array type inference general possible if decidable type theory question moreover even if inference undecidable general for given type theory inference often possible for large subset real-world programs haskell's type system version hindley-milner restriction system fω so-called rank-1 polymorphic types which type inference decidable most haskell compilers allow arbitrary-rank polymorphism extension but this makes type inference undecidable type checking decidable however rank-1 programs still have type inference higher rank polymorphic programs are rejected unless given explicit type annotations unified type system some languages like perl c have unified type system this means that all c types including primitive types inherit from single root object every type c inherits from object class java has several primitive types that are not objects java provides wrapper object types that exist together with primitive types so developers can use either wrapper object types simpler non-object primitive types compatibility equivalence subtyping type-checker for statically typed language must verify that type any expression consistent with type expected by context which that expression appears for instance assignment statement form x = e inferred type expression e must be consistent with declared inferred type variable x this notion consistency called compatibility specific each programming language if type e type x are same assignment allowed for that type then this valid expression simplest type systems therefore question whether two types are compatible reduces that whether they are equal equivalent different languages however have different criteria for when two type expressions are understood denote same type these different equational theories types vary widely two extreme cases being structural type systems which any two types that describe values with same structure are equivalent nominative type systems which no two syntactically distinct type expressions denote same type ie types must have same name order be equal languages with subtyping compatibility relation more complex particular if subtype b then value type can be used context where one type b expected even if reverse not true like equivalence subtype relation defined differently for each programming language with many variations possible presence parametric ad hoc polymorphism language may also have implications for type compatibility notes burroughs algol computer line determined memory location's contents by its flag bits flag bits specify contents memory location instruction data type functions are specified by bit code addition its bit contents only mcp master control program could write flag code bits see also computer programming portal comparison type systems covariance contravariance computer science polymorphism object-oriented programming type rules type signature type theory references pierce p type system tractable syntactic method for proving absence certain program behaviors by classifying phrases according kinds values they compute cardelli p fundamental purpose type system prevent occurrence execution errors during running program pierce p infoworld april brian kernighan why pascal not my favorite language r´emy didier type systems for programming languages pdf retrieved may pierce dynamic c reference msdn library microsoft retrieved january meijer erik drayton peter static typing where possible dynamic typing when needed end cold war between programming languages pdf microsoft corporation laucher amanda snively paul types vs tests infoq xi hongwei scott dana dependent types practical programming proceedings acm sigplan symposium on principles programming languages acm press 214–227 citeseerx visual basic example language that both type-safe memory-safe standard ecma-262 ecma-internationalorg retrieved on strict mode - javascript | mdn developermozillaorg retrieved on strict mode javascript msdnmicrosoftcom retrieved on bracha g pluggable types rozsnyai s schiefer j schatten concepts models for typing events for event-based systems proceedings inaugural international conference on distributed event-based systems - debs '07 p doi101145/12668941266904 isbn martelli alex july re polymorphism was re type checking python usenet 8lmvn6017l@news1newsguycom stefan hanenberg ”an experiment about static dynamic type systems doubts about positive impact static type systems on development time“ oopsla kleinschmager hanenberg robbes tanter stefik do static type systems improve maintainability software systems empirical study icpc hanenberg kleinschmager srobbes rtanter stefik empirical study on impact static typing on software maintainability ese mitchell john c plotkin gordon d abstract types have existential type acm transactions on programming languages systems vol no july pp 470–502 siek jeremy what gradual typing siek jeremy taha walid september gradual typing for functional languages pdf scheme functional programming university chicago pp 81–92 standard ecma-334 type system unification further reading cardelli luca wegner peter december on understanding types data abstraction polymorphism pdf acm computing surveys new york ny usa acm 471–523 doi 101145/60416042 issn 0360-0300 pierce benjamin c types programming languages mit press isbn 978-0-262-16209-8 cardelli luca type systems allen b tucker crc handbook computer science engineering pdf 2nd ed crc press isbn 158488360x tratt laurence dynamically typed languages advances computers vol pp 149–184 july external links wikibook ada programming has page on topic types wikibook haskell has page on topic class declarations smith chris what know before debating type systems v t e data types uninterpreted bit byte trit tryte word bit array numeric arbitrary-precision bignum complex decimal fixed point floating point o double precision o extended precision o half precision o long double o minifloat o octuple precision o quadruple precision o single precision integer o signedness interval rational text character string o null-terminated pointer address o physical o virtual reference composite algebraic data type o generalized array associative array class dependent equality inductive list object o metaobject option type product record set union o tagged other boolean bottom type collection enumerated type exception function type opaque data type recursive data type semaphore stream top type type class unit type void related topics abstract data type data structure generic kind o metaclass parametric polymorphism primitive data type protocol o interface subtyping type constructor type conversion type system see also platform-dependent independent units information retrieved from https//enwikipediaorg/w/indexphptitle=typesystem&oldid=750547201 categories type systems data types program analysis type theory hidden categories articles lacking in-text citations from october all articles lacking in-text citations wikipedia articles needing style editing from july all articles needing style editing all articles with unsourced statements articles with unsourced statements from june articles with unsourced statements from july all articles with specifically marked weasel-worded phrases articles with specifically marked weasel-worded phrases from november articles with unsourced statements from november all wikipedia articles needing clarification wikipedia articles needing clarification from july wikipedia articles needing clarification from november articles with unsourced statements from march all articles lacking reliable references articles lacking reliable references from march articles with unsourced statements from january articles with example java code navigation menu personal tools not logged talk contributions create account log namespaces article talk variants views read edit view history more search navigation main page contents featured content current events random article donate wikipedia wikipedia store interaction help about wikipedia community portal recent changes contact page tools what links here related changes upload file special pages permanent link page information wikidata item cite this page print/export create book download pdf printable version languages العربية বাংলা български bosanski čeština deutsch ελληνικά español 한국어 italiano עברית кыргызча bahasa melayu nederlands 日本語 олык марий polski português русский српски / srpski suomi svenska ไทย українська 中文 edit links this page was last modified on november at text available under creative commons attribution-sharealike license additional terms may apply by using this site you agree terms use privacy policy wikipedia® registered trademark wikimedia foundation inc non-profit organization privacy policy about wikipedia disclaimers contact wikipedia developers cookie statement mobile view 