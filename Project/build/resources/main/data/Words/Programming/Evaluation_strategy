evaluation strategy from wikipedia free encyclopedia jump navigation search evaluation strategies eager evaluation lazy evaluation partial evaluation remote evaluation short-circuit evaluation v t e programming language uses evaluation strategy determine when evaluate arguments function call for function also read operation method relation what kind value pass function for example call by value/call by reference specifies that function application evaluates argument before proceeds evaluation function's body that passes two capabilities function namely ability look up current value argument modify via assignment statement notion reduction strategy lambda calculus similar but distinct practical terms many modern programming languages have converged on call-by-value/call-by-reference evaluation strategy for function calls c java some languages especially lower-level languages such c++ combine several notions parameter passing historically call by value call by name date back algol language designed late 1950s call by reference used by pl/i some fortran systems purely functional languages like haskell well non-purely functional languages like r use call by need evaluation strategy specified by programming language definition not function any specific implementation contents strict evaluation o applicative order o call by value + implicit limitations o call by reference o call by sharing o call by copy-restore o partial evaluation non-strict evaluation o normal order o call by name o call by need o call by macro expansion nondeterministic strategies o full β-reduction o call by future o optimistic evaluation see also notes references strict evaluation main article eager evaluation strict evaluation arguments function are always evaluated completely before function applied under church encoding eager evaluation operators maps strict evaluation functions for this reason strict evaluation sometimes called eager most existing programming languages use strict evaluation for functions applicative order applicative order leftmost innermost evaluation refers evaluation strategy which arguments function are evaluated from left right post-order traversal reducible expressions redexes applicative order call-by-value evaluation call by value call by value also referred pass by value most common evaluation strategy used languages different c scheme call by value argument expression evaluated resulting value bound corresponding variable function frequently by copying value into new memory region if function procedure able assign values its parameters only its local copy assigned—that anything passed into function call unchanged caller's scope when function returns call by value not single evaluation strategy but rather family evaluation strategies which function's argument evaluated before being passed function while many programming languages such common lisp eiffel java that use call by value evaluate function arguments left-to-right some evaluate functions their arguments right-to-left others such scheme ocaml c leave order unspecified implicit limitations some cases term call by value problematic value which passed not value variable understood by ordinary meaning value but implementation-specific reference value effect that what syntactically looks like call by value may end up rather behaving like call by reference call by sharing often depending on very subtle aspects language semantics reason for passing reference often that language technically does not provide value representation complicated data but instead represents them data structure while preserving some semblance value appearance source code exactly where boundary drawn between proper values data structures masquerading such often hard predict c array which strings are special cases data structure thus treated reference memory area but struct value even if has fields that are vectors maple vector special case table therefore data structure but list which gets rendered can be indexed exactly same way value tcl values are dual-ported such that value representation used at script level language itself manages corresponding data structure if one required modifications made via data structure are reflected back value representation vice versa description call by value where value reference common but should not be understood being call by reference another term call by sharing thus behaviour call by value java visual basic call by value c pascal are significantly different c pascal calling function with large structure argument will cause entire structure be copied except if it's actually reference structure potentially causing serious performance degradation mutations structure are invisible caller however java visual basic only reference structure copied which fast mutations structure are visible caller call by reference call by reference also referred pass by reference evaluation strategy where function receives implicit reference variable used argument rather than copy its value this typically means that function can modify ie assign variable used argument—something that will be seen by its caller call by reference can therefore be used provide additional channel communication between called function calling function call-by-reference language makes more difficult for programmer track effects function call may introduce subtle bugs many languages support call by reference some form another but comparatively few use default fortran ii early example call-by-reference language few languages such c++ php visual basic net c realbasic default call by value but offer special syntax for call-by-reference parameters c++ additionally offers call by reference const call by reference can be simulated languages that use call by value don't exactly support call by reference by making use references objects that refer other objects such pointers objects representing memory addresses other objects languages such c ml use this technique not separate evaluation strategy—the language calls by value—but sometimes referred call by address also referred pass by address unsafe language like c this may cause memory safety errors such null pointer dereferences also may be confusing ml references are type- memory- safe similar effect achieved by call by sharing passing object which can then be mutated used languages like java python ruby purely functional languages there typically no semantic difference between two strategies since their data structures are immutable so there no possibility for function modify any its arguments so they are typically described call by value even though implementations frequently use call by reference internally for efficiency benefits example that demonstrates call by reference e def modifyvar p &q { p = passed by value only local parameter modified q = passed by reference variable used call modified } var = value var b = value modifya &b value b value example call by address that simulates call by reference c void modifyint p int q int r { p = // passed by value only local parameter modified q = // passed by value reference check call site determine which r = // passed by value reference check call site determine which } int main { int = int b = int x = int c = &x modifya &b c // passed by value b passed by reference by creating pointer // c pointer passed by value // b x are changed return } call by sharing call by sharing also referred call by object call by object-sharing evaluation strategy first named by barbara liskov et al for language clu used by languages such python iota java for object references ruby javascript scheme ocaml applescript many others however term call by sharing not common use terminology inconsistent across different sources for example java community they say that java call by value call by sharing implies that values language are based on objects rather than primitive types ie that all values are boxed semantics call by sharing differ from call by reference that assignments function arguments within function aren't visible caller unlike by reference semantics so eg if variable was passed not possible simulate assignment on that variable caller's scope however since function has access same object caller no copy made mutations those objects if objects are mutable within function are visible caller which may appear differ from call by value semantics mutations mutable object within function are visible caller because object not copied cloned — shared for example python lists are mutable so def fl lappend1 m = fm printm outputs because append method modifies object on which called assignments within function are not noticeable caller because these languages assignment binds variable different object rather than mutating object since rebound variable only exists within scope function counterpart caller retains its original binding compare python mutation above with this code that binds formal argument new object def fl l = m = fm printm outputs because statement l = reassigns new list variable rather than location references for immutable objects there no real difference between call by sharing call by value except if object identity visible language use call by sharing with mutable objects alternative input/output parameters parameter not assigned argument not overwritten object identity not changed but object argument mutated although this term has widespread usage python community identical semantics other languages such java visual basic are often described call by value where value implied be reference object call by copy-restore call by copy-restore also referred copy-in copy-out call by value result call by value return—as termed fortran community special case call by reference where provided reference unique caller this variant has gained attention multiprocessing contexts remote procedure call if parameter function call reference that might be accessible by another thread execution its contents may be copied new reference that not when function call returns updated contents this new reference are copied back original reference restored semantics call by copy-restore also differ from those call by reference where two more function arguments alias one another that point same variable caller's environment under call by reference writing one will affect other call by copy-restore avoids this by giving function distinct copies but leaves result caller's environment undefined depending on which aliased arguments copied back first—will copies be made left-to-right order both on entry on return when reference passed callee uninitialized this evaluation strategy may be called call by result partial evaluation main article partial evaluation partial evaluation evaluation may continue into body function that has not been applied any sub-expressions that do not contain unbound variables are evaluated function applications whose argument values are known may be reduced presence side-effects complete partial evaluation may produce unintended results for this reason systems that support partial evaluation tend do so only for pure expressions expressions without side-effects within functions non-strict evaluation this section does not cite any sources please help improve this section by adding citations reliable sources unsourced material may be challenged removed june learn how when remove this template message non-strict evaluation arguments function are not evaluated unless they are actually used evaluation function body under church encoding lazy evaluation operators maps non-strict evaluation functions for this reason non-strict evaluation often referred lazy boolean expressions many languages use form non-strict evaluation called short-circuit evaluation where evaluation returns soon can be determined that unambiguous boolean will result—for example disjunctive expression where true encountered conjunctive expression where false encountered so forth conditional expressions also usually use lazy evaluation where evaluation returns soon unambiguous branch will result normal order normal-order leftmost outermost evaluation evaluation strategy where outermost redex always reduced applying functions before evaluating function arguments contrast call by name does not evaluate inside body unapplied function call by name call by name evaluation strategy where arguments function are not evaluated before function called—rather they are substituted directly into function body using capture-avoiding substitution then left be evaluated whenever they appear function if argument not used function body argument never evaluated if used several times re-evaluated each time appears see jensen's device call-by-name evaluation occasionally preferable call-by-value evaluation if function's argument not used function call by name will save time by not evaluating argument whereas call by value will evaluate regardless if argument non-terminating computation advantage enormous however when function argument used call by name often slower requiring mechanism such thunk early use was algol today's net languages can simulate call by name using delegates expression parameters latter results abstract syntax tree being given function eiffel provides agents which represent operation be evaluated when needed seed7 provides call by name with function parameters call by need main article lazy evaluation call by need memoized version call by name where if function argument evaluated that value stored for subsequent uses pure effect-free setting this produces same results call by name when function argument used two more times call by need almost always faster because evaluation expressions may happen arbitrarily far into computation languages using call by need generally do not support computational effects such mutation except through use monads uniqueness types this eliminates any unexpected behavior from variables whose values change prior their delayed evaluation lazy evaluation most commonly used implementation strategy for call-by-need semantics but variations exist—for instance optimistic evaluation haskell best-known language that uses call-by-need evaluation r also uses form call by need net languages can simulate call by need using type lazy call by macro expansion call by macro expansion similar call by name but uses textual substitution rather than capture-avoiding substitution with uncautious use macro substitution may result variable capture lead undesired behavior hygienic macros avoid this problem by checking for replacing shadowed variables that are not parameters nondeterministic strategies full β-reduction under full β-reduction any function application may be reduced substituting function's argument into function using capture-avoiding substitution at any time this may be done even within body unapplied function call by future see also futures promises call by future also referred parallel call by name concurrent evaluation strategy where value future expression computed concurrently with flow rest program by one more promises when value future needed main program blocks until future has value promise one promises finishes computing if has not already completed by then this strategy non-deterministic evaluation can occur at any time between creation future ie when expression given use future's value similar call by need that value only computed once computation may be deferred until value needed but may be started before further if value future not needed such if local variable function that returns computation may be terminated part-way through if implemented with processes threads creating future will spawn one more new processes threads for promises accessing value will synchronize these with main thread terminating computation future corresponds killing promises computing its value if implemented with coroutine net async/await creating future calls coroutine async function which may yield caller turn be yielded back when value used cooperatively multitasking optimistic evaluation optimistic evaluation another variant call by need which function's argument partially evaluated for some amount time which may be adjusted at runtime after which evaluation aborted function applied using call by need this approach avoids some runtime expense call by need while still retaining desired termination characteristics see also beta normal form comparison programming languages lambda calculus parameter computer science eval notes essentials programming languages by daniel p friedman mitchell wand mit press 1989–2006 some fortran systems use call by copy-restore lambda calculus pdf csuiowaedu retrieved applicative order reduction definition applicative order reduction free online encyclopedia encyclopedia2thefreedictionarycom retrieved liskov barbara atkinson russ bloom toby moss eliot schaffert craig scheifler craig snyder alan october clu reference manual pdf laboratory for computer science massachusetts institute technology retrieved lundh fredrik call by object effbotorg retrieved iota language definition cs 412/413 introduction compilers cornell university retrieved ca1021 avoid out parameters microsoft ennals robert jones simon peyton august optimistic evaluation fast evaluation strategy for non-strict programs references this article includes list references but its sources remain unclear because has insufficient inline citations please help improve this article by introducing more precise citations april learn how when remove this template message abelson harold sussman gerald jay structure interpretation computer programs second ed cambridge massachusetts mit press isbn 978-0-262-01153-2 baker-finch clem king david hall jon trinder phil operational semantics for parallel call-by-need ps research report faculty mathematics & computing open university ennals robert peyton jones simon optimistic evaluation fast evaluation strategy for non-strict programs pdf international conference on functional programming acm press ludäscher bertram cse lecture notes cse programming languages principles & paradigms pierce benjamin c types programming languages mit press isbn 0-262-16209-1 sestoft peter mogensen t schmidt d sudborough i h eds demonstrating lambda calculus reduction pdf essence computation complexity analysis transformation essays dedicated neil d jones lecture notes computer science springer-verlag pp 420–435 isbn 3-540-00326-6 call by value call by reference c programming call by value call by reference c programming explained retrieved from https//enwikipediaorg/w/indexphptitle=evaluationstrategy&oldid=751636557 categories evaluation strategy hidden categories all articles with unsourced statements articles with unsourced statements from october articles with unsourced statements from june articles with unsourced statements from august articles needing additional references from june all articles needing additional references articles lacking in-text citations from april all articles lacking in-text citations navigation menu personal tools not logged talk contributions create account log namespaces article talk variants views read edit view history more search navigation main page contents featured content current events random article donate wikipedia wikipedia store interaction help about wikipedia community portal recent changes contact page tools what links here related changes upload file special pages permanent link page information wikidata item cite this page print/export create book download pdf printable version languages čeština deutsch français 한국어 nederlands 日本語 português русский slovenčina українська 中文 edit links this page was last modified on november at text available under creative commons attribution-sharealike license additional terms may apply by using this site you agree terms use privacy policy wikipedia® registered trademark wikimedia foundation inc non-profit organization privacy policy about wikipedia disclaimers contact wikipedia developers cookie statement mobile view 