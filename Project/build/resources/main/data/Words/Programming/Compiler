compiler from wikipedia free encyclopedia jump navigation search this article about computing term for anime see compiler anime compile compiling redirect here for software company see compile publisher for other uses see compilation this article has multiple issues please help improve discuss these issues on talk page learn how when remove these template messages this article has unclear citation style references used may be made clearer with different consistent style citation footnoting external linking january learn how when remove this template message this article includes list references but its sources remain unclear because has insufficient inline citations please help improve this article by introducing more precise citations january learn how when remove this template message learn how when remove this template message program execution general concepts runtime system runtime library executable compiler interpreter virtual machine intermediate representation ir source code object code bytecode machine code compilation strategies just-in-time jit o tracing just-in-time ahead-of-time aot transcompilation recompilation notable runtimes android runtime art common language runtime clr crt0 java virtual machine jvm nodejs zend engine notable compilers & toolchains llvm gnu compiler collection gcc v t e compiler computer program set programs that transforms source code written programming language source language into another computer language target language with latter often having binary form known object code most common reason for converting source code create executable program name compiler primarily used for programs that translate source code from high-level programming language lower level language eg assembly language machine code if compiled program can run on computer whose cpu operating system different from one on which compiler runs compiler known cross-compiler more generally compilers are specific type translator while all programs that take set programming specifications translate them ie create means execute those specifications are technically compilers term generally means program that produces separate executable from compiler that may require run time library subsystem operate compiler that merely executes original specifications usually referred interpreter although because differing methods analyzing what represents compilation what represents interpretation there some overlap between two terms program that translates from low level language higher level one decompiler program that translates between high-level languages usually called source-to-source compiler transpiler language rewriter usually program that translates form expressions without change language term compiler-compiler sometimes used refer parser generator tool often used help create lexer parser compiler likely perform many all following operations lexical analysis preprocessing parsing semantic analysis syntax-directed translation code generation code optimization program faults caused by incorrect compiler behavior can be very difficult track down work around therefore compiler implementors invest significant effort ensure compiler correctness contents history o compilation o compilers education compiler output o compiled versus interpreted languages o special type compilers compiler construction o one-pass versus multi-pass compilers o three phases compiler structure o front end o back end o compiler correctness conferences organizations related techniques see also notes references external links history main article history compiler construction diagram operation typical multi-language multi-target compiler software for early computers was primarily written assembly language although first high level language nearly old first computer limited memory capacity early computers led substantial technical challenges when first compilers were designed first high-level programming language plankalkül was proposed by konrad zuse first compiler was written by grace hopper for a-0 programming language a-0 functioned more loader linker than modern notion compiler first autocode its compiler were developed by alick glennie for mark computer at university manchester considered by some be first compiled programming language fortran team led by john backus at ibm generally credited having introduced first complete compiler cobol was early language be compiled on multiple architectures many application domains idea using higher level language quickly caught on because expanding functionality supported by newer programming languages increasing complexity computer architectures compilers have become more complex early compilers were written assembly language first self-hosting compiler – capable compiling its own source code high-level language – was created for lisp by tim hart mike levin at mit since 1970s has become common practice implement compiler language compiles although both pascal c have been popular choices for implementation language building self-hosting compiler bootstrapping problem—the first such compiler for language must be compiled either by hand by compiler written different language hart levin's lisp compiler compiled by running compiler interpreter compilation compilers enabled development programs that are machine-independent before development fortran first high-level language 1950s machine-dependent assembly language was widely used while assembly language produces more abstraction than machine code on same architecture just with machine code has be modified rewritten if program be executed on different computer hardware architecture with advent high-level programming languages that followed fortran such cobol c basic programmers could write machine-independent source programs compiler translates high-level source programs into target programs machine languages for specific hardware once target program generated user can execute program compilers education compiler construction compiler optimization are taught at universities schools part computer science curriculum such courses are usually supplemented with implementation compiler for educational programming language well-documented example niklaus wirth's pl/0 compiler which wirth used teach compiler construction 1970s spite its simplicity pl/0 compiler introduced several influential concepts field program development by stepwise refinement also title paper by wirth use recursive descent parser use extended backus–naur form ebnf specify syntax language code generator producing portable p-code use tombstone diagrams formal description bootstrapping problem compiler output this section does not cite any sources please help improve this section by adding citations reliable sources unsourced material may be challenged removed may learn how when remove this template message one classification compilers by platform on which their generated code executes this known target platform native hosted compiler one which output intended directly run on same type computer operating system that compiler itself runs on output cross compiler designed run on different platform cross compilers are often used when developing software for embedded systems that are not intended support software development environment output compiler that produces code for virtual machine vm may may not be executed on same platform compiler that produced for this reason such compilers are not usually classified native cross compilers lower level language that target compiler may itself be high-level programming language c often viewed some sort portable assembler can also be target language compiler eg cfront original compiler for c++ used c target language c created by such compiler usually not intended be read maintained by humans so indent style pretty c intermediate code are irrelevant some features c turn into good target language eg c code with line directives can be generated support debugging original source compiled versus interpreted languages higher-level programming languages usually appear with type translation mind either designed compiled language interpreted language however practice there rarely anything about language that requires be exclusively compiled exclusively interpreted although possible design languages that rely on re-interpretation at run time categorization usually reflects most popular widespread implementations language — for instance basic sometimes called interpreted language c compiled one despite existence basic compilers c interpreters interpretation does not replace compilation completely only hides from user makes gradual even though interpreter can itself be interpreted directly executed program needed somewhere at bottom stack see machine language modern trends toward just-in-time compilation bytecode interpretation at times blur traditional categorizations compilers interpreters some language specifications spell out that implementations must include compilation facility for example common lisp however there nothing inherent definition common lisp that stops from being interpreted other languages have features that are very easy implement interpreter but make writing compiler much harder for example apl snobol4 many scripting languages allow programs construct arbitrary source code at runtime with regular string operations then execute that code by passing special evaluation function implement these features compiled language programs must usually be shipped with runtime library that includes version compiler itself special type compilers while typical compiler outputs machine code there are several other types source-to-source compiler type compiler that takes high level language its input outputs high level language for example automatic parallelizing compiler will frequently take high level language program input then transform code annotate with parallel code annotations eg openmp language constructs eg fortran's doall statements bytecode compilers that compile assembly language theoretical machine like some prolog implementations o this prolog machine also known warren abstract machine wam o bytecode compilers for java python are also examples this category just-in-time compiler jit compiler last part multi-pass compiler chain which some compilation stages are deferred run-time examples are implemented smalltalk java microsoft net's common intermediate language cil systems o applications are first compiled using bytecode compiler delivered machine-independent intermediate representation this bytecode then compiled using jit compiler native machine code just when execution program required hardware compilers also known syntheses tools are compilers whose output description hardware configuration instead sequence instructions o output these compilers target computer hardware at very low level for example field-programmable gate array fpga structured application-specific integrated circuit asic such compilers are said be hardware compilers because source code they compile effectively controls final configuration hardware how operates output compilation only interconnection transistors lookup tables o example hardware compiler xst xilinx synthesis tool used for configuring fpgas similar tools are available from altera synplicity synopsys other hardware vendors compiler construction this section does not cite any sources please help improve this section by adding citations reliable sources unsourced material may be challenged removed september learn how when remove this template message compilers bridge source programs high-level languages with underlying hardware compiler verifies code syntax generates efficient object code performs run-time organization formats output according assembler linker conventions early days approach taken compiler design used be directly affected by complexity processing experience persons designing resources available compiler for relatively simple language written by one person might be single monolithic piece software when source language large complex high quality output required design may be split into number relatively independent phases having separate phases means development can be parceled up into small parts given different people also becomes much easier replace single phase by improved one insert new phases later eg additional optimizations division compilation processes into phases was championed by production quality compiler-compiler project pqcc at carnegie mellon university this project introduced terms front end middle end back end all but smallest compilers have more than two phases point at which these ends meet not always clearly defined one-pass versus multi-pass compilers classifying compilers by number passes has its background hardware resource limitations computers compiling involves performing lots work early computers did not have enough memory contain one program that did all this work so compilers were split up into smaller programs which each made pass over source some representation performing some required analysis translations ability compile single pass has classically been seen benefit because simplifies job writing compiler one-pass compilers generally perform compilations faster than multi-pass compilers thus partly driven by resource limitations early systems many early languages were specifically designed so that they could be compiled single pass eg pascal some cases design language feature may require compiler perform more than one pass over source for instance consider declaration appearing on line source which affects translation statement appearing on line this case first pass needs gather information about declarations appearing after statements that they affect with actual translation happening during subsequent pass disadvantage compiling single pass that not possible perform many sophisticated optimizations needed generate high quality code can be difficult count exactly how many passes optimizing compiler makes for instance different phases optimization may analyse one expression many times but only analyse another expression once splitting compiler up into small programs technique used by researchers interested producing provably correct compilers proving correctness set small programs often requires less effort than proving correctness larger single equivalent program three phases compiler structure regardless exact number stages which compiler built common practice classify them into three phases these phases are named after production quality compiler-compiler project phases mentioned before compiler design front end verifies syntax semantics according specific source language performs type checking by collecting type information generates errors warnings if any highlighting them on source code aspects front end include lexical analysis syntax analysis semantic analysis eventually generates intermediate representation ir source code for processing by middle-end this ir usually lower level representation program with respect source code middle end performs optimizations on form other than source code machine code this source code/machine code independence intended enable generic optimizations be shared between versions compiler supporting different languages target processors examples middle end optimizations are removal useless unreachable code discovery propagation constant values relocation computation less frequently executed place eg out loop specialization computation based on context eventually may generate another ir for be used back end back end takes output from middle end may perform more analysis transformations optimizations that are for particular computer generates target-dependent assembly code performing register allocation process performs optimizations target code utilization hardware like figuring out how keep parallel execution units busy by filling delay slots although most algorithms for optimization are np-hard heuristic techniques are well-developed currently implemented production-quality compilers typically output back end machine code specialized for particular processor operating system this front/middle/back-end approach makes possible combine front ends for different languages with back ends for different cpus practical examples this approach are gnu compiler collection llvm amsterdam compiler kit which have multiple front-ends shared analysis multiple back-ends front end lexer parser example for c starting from sequence characters ifnet>00total+=net10+tax/1000 scanner composes sequence tokens categorizes each them for example identifier reserved word number literal operator latter sequence transformed by parser into syntax tree which then treated by remaining compiler phases scanner parser handles regular properly context-free parts grammar for c respectively compiler frontend analyzes source code build internal representation program called intermediate representation ir also manages symbol table data structure mapping each symbol source code associated information such location type scope while frontend can be single monolithic function program scannerless parser more commonly implemented analyzed several phases which may execute sequentially concurrently this method favored due its modularity separation concerns most commonly today frontend broken into three phases lexical analysis also known lexing syntax analysis also known parsing semantic analysis lexical analysis parsing comprise syntactic analysis word syntax phrase syntax respectively simple cases these modules lexer parser can be automatically generated from grammar for language though more complex cases these require manual modification lexical grammar phrase grammar are usually context-free grammars which simplifies analysis significantly with context-sensitivity handled at semantic analysis phase semantic analysis phase generally more complex written by hand but can be partially fully automated using attribute grammars these phases themselves can be further broken down – lexing scanning evaluating parsing first building concrete syntax tree cst parse tree then transforming into abstract syntax tree ast syntax tree some cases additional phases are used notably line reconstruction preprocessing but these are rare detailed list possible phases includes line reconstruction languages which strop their keywords allow arbitrary spaces within identifiers require phase before parsing which converts input character sequence canonical form ready for parser top-down recursive-descent table-driven parsers used 1960s typically read source one character at time did not require separate tokenizing phase atlas autocode imp some implementations algol coral are examples stropped languages which compilers would have line reconstruction phase lexical analysis breaks source code text into small pieces called tokens each token single atomic unit language for instance keyword identifier symbol name token syntax typically regular language so finite state automaton constructed from regular expression can be used recognize this phase also called lexing scanning software doing lexical analysis called lexical analyzer scanner this may not be separate step – can be combined with parsing step scannerless parsing which case parsing done at character level not token level preprocessing some languages eg c require preprocessing phase which supports macro substitution conditional compilation typically preprocessing phase occurs before syntactic semantic analysis eg case c preprocessor manipulates lexical tokens rather than syntactic forms however some languages such scheme support macro substitutions based on syntactic forms syntax analysis involves parsing token sequence identify syntactic structure program this phase typically builds parse tree which replaces linear sequence tokens with tree structure built according rules formal grammar which define language's syntax parse tree often analyzed augmented transformed by later phases compiler semantic analysis phase which compiler adds semantic information parse tree builds symbol table this phase performs semantic checks such type checking checking for type errors object binding associating variable function references with their definitions definite assignment requiring all local variables be initialized before use rejecting incorrect programs issuing warnings semantic analysis usually requires complete parse tree meaning that this phase logically follows parsing phase logically precedes code generation phase though often possible fold multiple phases into one pass over code compiler implementation back end term back end sometimes confused with code generator because overlapped functionality generating assembly code some literature uses middle end distinguish generic analysis optimization phases back end from machine-dependent code generators main phases back end include following analysis this gathering program information from intermediate representation derived from input data-flow analysis used build use-define chains together with dependence analysis alias analysis pointer analysis escape analysis etc accurate analysis basis for any compiler optimization call graph control flow graph are usually also built during analysis phase optimization intermediate language representation transformed into functionally equivalent but faster smaller forms popular optimizations are inline expansion dead code elimination constant propagation loop transformation register allocation even automatic parallelization code generation transformed intermediate language translated into output language usually native machine language system this involves resource storage decisions such deciding which variables fit into registers memory selection scheduling appropriate machine instructions along with their associated addressing modes see also sethi-ullman algorithm debug data may also need be generated facilitate debugging compiler analysis prerequisite for any compiler optimization they tightly work together for example dependence analysis crucial for loop transformation addition scope compiler analysis optimizations vary greatly from small basic block procedure/function level even over whole program interprocedural optimization obviously compiler can potentially do better job using broader view but that broad view not free large scope analysis optimizations are very costly terms compilation time memory space this especially true for interprocedural analysis optimizations interprocedural analysis optimizations are common modern commercial compilers from hp ibm sgi intel microsoft sun microsystems open source gcc was criticized for long time for lacking powerful interprocedural optimizations but changing this respect another open source compiler with full analysis optimization infrastructure open64 which used by many organizations for research commercial purposes due extra time space needed for compiler analysis optimizations some compilers skip them by default users have use compilation options explicitly tell compiler which optimizations should be enabled compiler correctness main article compiler correctness compiler correctness branch software engineering that deals with trying show that compiler behaves according its language specification techniques include developing compiler using formal methods using rigorous testing often called compiler validation on existing compiler conferences organizations number conferences field programming languages present advances compiler construction one their main topics acm sigplan supports number conferences including programming language design implementation pldi principles programming languages popl object-oriented programming systems languages applications oopsla international conference on functional programming icfp european joint conferences on theory practice software etaps sponsors international conference on compiler construction with papers from both academic industrial sectors asian symposium on programming languages systems aplas organized by asian association for foundation software aafs related techniques main article translator computing has been suggested that translator computing be merged into this section discuss proposed since july assembly language type low-level language program that compiles more commonly known assembler with inverse program known disassembler program that translates from low level language higher level one decompiler program that translates between high-level languages usually called language translator source source translator language converter language rewriter last term usually applied translations that do not involve change language program that translates into object code format that not supported on compilation machine called cross compiler commonly used prepare code for embedded applications see also computer programming portal book compiler construction abstract interpretation binary recompiler bottom-up parsing compile go loader compile farm list compilers list important publications computer science § compilers metacompilation notes definition ofcompiler pc magazine knuth d e & pardo l t early development programming languages history computing twentieth century 197-273 ip world's first cobol compilers interesting-peopleorg june archived from original on february t hart m levin new compiler aim-39 - csail digital archive - artificial intelligence laboratory series pdf publicationsaimitedu sheridan peter b arithmetic translator-compiler ibm fortran automatic coding system communications acm acm 9–21 doi101145/368280368289 chakraborty p saxena p c katti c p pahwa g taneja s new practicum compiler construction computer applications engineering education press pl/0 compiler/interpreter acm digital library aycock john june brief history just-in-time acm comput surv new york ny usa 93–113 doi 101145/857076857077 swartz jordan s betz vaugh rose jonathan fast routability-driven router for fpgas pdf department electrical computer engineering university toronto lysaght patrick blodget brandon mason jeff young jay bridgford brendan invited paper enhanced architectures design methodologies cad tools for dynamic reconfiguration xilinx fpgas international conference on field programmable logic applications ieee xilinx® inc xst synthesis overview xilinxcom xilinx® inc retrieved june altera corporation spectra-q™ engine alteracom altera corporation retrieved june llvm community llvm target-independent code generator llvm documentation retrieved june lattner chris llvm brown amy wilson greg architecture open source applications ed chlipala adam syntactic proofs compositional compiler correctness pdf harvard university cambridge massachusetts usa etaps - european joint conferences on theory practice software cf cc compiler construction subsection references compiler textbook references collection references mainstream compiler construction textbooks aho alfred v sethi ravi ullman jeffrey d compilers principles techniques tools 1st ed addison-wesley isbn allen frances e september history language processor technology ibm pdf ibm journal research development ibm doi 101147/rd2550535 subscription required help allen randy kennedy ken optimizing compilers for modern architectures morgan kaufmann publishers isbn 1-55860-286-0 appel andrew wilson modern compiler implementation java 2nd ed cambridge university press isbn 0-521-82060-x appel andrew wilson modern compiler implementation ml cambridge university press isbn 0-521-58274-1 bornat richard understanding writing compilers do yourself guide pdf macmillan publishing isbn 0-333-21732-2 cooper keith d torczon linda engineering compiler morgan kaufmann isbn 1-55860-699-8 leverett bruce w cattell r g g newcomer joseph m hobbs so reiner ah schatz br wulf wa august overview production – quality compiler – compiler project computer carnegie-mellon university 38–49 doi 101109/mc19801653748 issn 0018-9162 subscription required help mckeeman william marshall horning james j wortman david b compiler generator englewood cliffs nj prentice-hall isbn 0-13-155077-2 muchnick steven advanced compiler design implementation morgan kaufmann publishers isbn 1-55860-320-4 scott michael lee programming language pragmatics 2nd ed morgan kaufmann isbn 0-12-633951-1 srikant y n shankar priti compiler design handbook optimizations machine code generation crc press isbn 0-8493-1240-x terry patrick d compilers compiler generators introduction with c++ international thomson computer press isbn 1-85032-298-8 wirth niklaus compiler construction pdf addison-wesley isbn 0-201-40353-6 external links look up compiler wiktionary free dictionary wikibooks has book on topic compiler construction compilers at dmoz incremental approach compiler construction – pdf tutorial compile-howto basics compiler design by torben ægidius mogensen short animation on youtube explaining key conceptual difference between compilers interpreters syntax analysis & ll1 parsing on youtube let's build compiler by jack crenshaw forum about compiler development authority control lccn sh86007588 gnd 4148248-7 bnf cb120631538 data ndl bne xx532454 retrieved from https//enwikipediaorg/w/indexphptitle=compiler&oldid=752045025 categories american inventions compilers compiler construction computer libraries programming language implementation utility software types hidden categories wikipedia references cleanup from january all articles needing references cleanup articles covered by wikiproject wikify from january all articles covered by wikiproject wikify articles lacking in-text citations from january all articles lacking in-text citations use dmy dates from july articles needing additional references from may all articles needing additional references articles needing additional references from september wikipedia articles needing clarification from november articles be merged from july all articles be merged pages containing links subscription-only content articles with dmoz links wikipedia articles with lccn identifiers wikipedia articles with gnd identifiers wikipedia articles with bnf identifiers navigation menu personal tools not logged talk contributions create account log namespaces article talk variants views read edit view history more search navigation main page contents featured content current events random article donate wikipedia wikipedia store interaction help about wikipedia community portal recent changes contact page tools what links here related changes upload file special pages permanent link page information wikidata item cite this page print/export create book download pdf printable version languages afrikaans العربية aragonés asturianu azərbaycanca বাংলা беларуская беларуская тарашкевіца‎ български bosanski català čeština dansk deutsch eesti ελληνικά español esperanto euskara فارسی français gaeilge galego 한국어 հայերեն हिन्दी hornjoserbsce hrvatski ilokano bahasa indonesia interlingua íslenska italiano עברית ქართული қазақша кыргызча latina latviešu lëtzebuergesch lietuvių magyar македонски മലയാളം bahasa melayu mirandés မြန်မာဘာသာ nederlands नेपाली 日本語 norsk bokmål олык марий ਪੰਜਾਬੀ پنجابی polski português română русский scots simple english slovenčina slovenščina کوردیی ناوەندی српски / srpski srpskohrvatski / српскохрватски suomi svenska tagalog தமிழ் తెలుగు ไทย türkçe українська اردو tiếng việt winaray ייִדיש zazaki 中文 edit links this page was last modified on november at text available under creative commons attribution-sharealike license additional terms may apply by using this site you agree terms use privacy policy wikipedia® registered trademark wikimedia foundation inc non-profit organization privacy policy about wikipedia disclaimers contact wikipedia developers cookie statement mobile view 