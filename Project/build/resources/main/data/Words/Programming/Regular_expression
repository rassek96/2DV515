regular expression from wikipedia free encyclopedia jump navigation search this article may be too technical for most readers understand please help improve this article make understandable non-experts without removing technical details talk page may contain suggestions september learn how when remove this template message match results pattern @\^`{|}~-] punctuation characters \s \s whitespace characters \s \s non-whitespace characters \u uppercase letters \x hexadecimal digits posix character classes can only be used within bracket expressions for example ab] matches uppercase letters lowercase b additional non-posix class understood by some tools which usually defined plus underscore this reflects fact that many programming languages these are characters that may be used identifiers editor vim further distinguishes word word-head classes using notation \w \h since many programming languages characters that can begin identifier are not same those that can occur other positions note that what posix regex standards call character classes are commonly referred posix character classes other regex flavors which support them with most other regex flavors term character class used describe what posix calls bracket expressions perl because its expressive power relative ease reading many other utilities programming languages have adopted syntax similar perl's—for example java javascript python ruby microsoft's net framework xml schema some languages tools such boost php support multiple regex flavors perl-derivative regex implementations are not identical usually implement subset features found perl released perl sometimes does incorporate features initially found other languages for example perl implements syntactic extensions originally developed pcre python lazy matching three common quantifiers + are greedy by default because they match many characters possible regex applied string ganymede he continued largest moon solar system matches entire sentence instead matching only ganymede within first pair quotations aforementioned quantifiers may therefore be made lazy minimal matching few characters possible by appending question mark matches only ganymede within first pair quotations patterns for non-regular languages many features found virtually all modern regular expression libraries provide expressive power that far exceeds regular languages for example many implementations allow grouping subexpressions with parentheses recalling value they match same expression backreferences this means that among other things pattern can match strings repeated words like papa wikiwiki called squares formal language theory pattern for these strings +\1 language squares not regular nor context-free due pumping lemma however pattern matching with unbounded number backreferences supported by numerous modern tools still context sensitive however many tools libraries engines that provide such constructions still use term regular expression for their patterns this has led nomenclature where term regular expression has different meanings formal language theory pattern matching for this reason some people have taken using term regex regexp simply pattern describe latter larry wall author perl programming language writes essay about design perl regular expressions are only marginally related real regular expressions nevertheless term has grown with capabilities our pattern matching engines so i'm not going try fight linguistic necessity here i will however generally call them regexes regexen when i'm anglo-saxon mood fuzzy regexes this section does not cite any sources please help improve this section by adding citations reliable sources unsourced material may be challenged removed september learn how when remove this template message variants regexes can be used for working with text natural language when necessary take into account possible typos spelling variants for example text julius caesar might be fuzzy match for gaius julius caesar yulius cesar g juliy caezar such cases mechanism implements some fuzzy string matching algorithm possibly some algorithm for finding similarity between text fragment pattern this task closely related both full text search named entity recognition some software libraries work with fuzzy regexes tre – well-developed portable free project c which uses syntax similar posix frej – open source project java with non-standard syntax which utilizes prefix lisp-like notation targeted allow easy use substitutions inner matched fragments outer blocks but lacks many features standard regexes agrep – open source command-line utility implementations running times there are at least three different algorithms that decide whether how given regex matches string oldest fastest relies on result formal language theory that allows every nondeterministic finite automaton nfa be transformed into deterministic finite automaton dfa dfa can be constructed explicitly then run on resulting input string one symbol at time constructing dfa for regular expression size m has time memory cost o2m but can be run on string size n time on alternative approach simulate nfa directly essentially building each dfa state on demand then discarding at next step this keeps dfa implicit avoids exponential construction cost but running cost rises omn explicit approach called dfa algorithm implicit approach nfa algorithm adding caching nfa algorithm often called lazy dfa algorithm just dfa algorithm without making distinction these algorithms are fast but using them for recalling grouped subexpressions lazy quantification similar features tricky third algorithm match pattern against input string by backtracking this algorithm commonly called nfa but this terminology can be confusing its running time can be exponential which simple implementations exhibit when matching against expressions like a|aab that contain both alternation unbounded quantification force algorithm consider exponentially increasing number sub-cases this behavior can cause security problem called regular expression denial service although backtracking implementations only give exponential guarantee worst case they provide much greater flexibility expressive power for example any implementation which allows use backreferences implements various extensions introduced by perl must include some kind backtracking some implementations try provide best both algorithms by first running fast dfa algorithm revert potentially slower backtracking algorithm only when backreference encountered during match unicode theoretical terms any token set can be matched by regular expressions long pre-defined terms historical implementations regexes were originally written use ascii characters their token set though regex libraries have supported numerous other character sets many modern regex engines offer at least some support for unicode most respects makes no difference what character set but some issues do arise when extending regexes support unicode supported encoding some regex libraries expect work on some particular encoding instead on abstract unicode characters many these require utf-8 encoding while others might expect utf-16 utf-32 contrast perl java are agnostic on encodings instead operating on decoded characters internally supported unicode range many regex engines support only basic multilingual plane that characters which can be encoded with only bits currently only few regex engines eg perl's java's can handle full 21-bit unicode range extending ascii-oriented constructs unicode for example ascii-based implementations character ranges form are valid wherever x y have code points range codepointx ≤ codepointy natural extension such character ranges unicode would simply change requirement that endpoints lie requirement that they lie however practice this often not case some implementations such that gawk do not allow character ranges cross unicode blocks range like valid since both endpoints fall within basic latin block since both endpoints fall within armenian block but range like invalid since includes multiple unicode blocks other engines such that vim editor allow block-crossing but character values must not be more than apart case insensitivity some case-insensitivity flags affect only ascii characters other flags affect all characters some engines have two different flags one for ascii other for unicode exactly which characters belong posix classes also varies cousins case insensitivity ascii has case distinction case insensitivity became logical feature text searching unicode introduced alphabetic scripts without case like devanagari for these case sensitivity not applicable for scripts like chinese another distinction seems logical between traditional simplified arabic scripts insensitivity initial medial final isolated position may be desired japanese insensitivity between hiragana katakana sometimes useful normalization unicode has combining characters like old typewriters plain letters can be followed by one more non-spacing symbols usually diacritics like accent marks form single printing character but also provides precomposed characters ie characters that already include one more combining characters sequence character + combining character should be matched with identical single precomposed character process standardizing sequences characters + combining characters called normalization new control codes unicode introduced amongst others byte order marks text direction markers these codes might have be dealt with special way introduction character classes for unicode blocks scripts numerous other character properties block properties are much less useful than script properties because block can have code points from several different scripts script can have code points from several different blocks perl javautilregex library properties form \p{inx} \p{block=x} match characters block x \p{inx} \p{block=x} matches code points not that block similarly \p{armenian} \p{isarmenian} \p{script=armenian} matches any character armenian script general \p{x} matches any character with either binary property x general category x for example \p{lu} \p{uppercaseletter} \p{gc=lu} matches any upper-case letter binary properties that are not general categories include \p{whitespace} \p{alphabetic} \p{math} \p{dash} examples non-binary properties are \p{bidiclass=righttoleft} \p{wordbreak=aletter} \p{numericvalue=10} uses regexes are useful wide variety text processing tasks more generally string processing where data need not be textual common applications include data validation data scraping especially web scraping data wrangling simple parsing production syntax highlighting systems many other tasks while regexes would be useful on internet search engines processing them across entire database could consume excessive computer resources depending on complexity design regex although many cases system administrators can run regex-based queries internally most search engines do not offer regex support public notable exceptions google code search exalead however google code search has been shut down march examples specific syntax rules vary depending on specific implementation programming language library use additionally functionality regex implementations can vary between versions because regexes can be difficult both explain understand without examples interactive web sites for testing regexes are useful resource for learning regexes by experimentation this section provides basic description some properties regexes by way illustration following conventions are used examples metacharacters metacharacters column specifies regex syntax being demonstrated =~ m// indicates regex match operation perl =~ s/// indicates regex substitution operation perl also worth noting that these regexes are all perl-like syntax standard posix regular expressions are different unless otherwise indicated following examples conform perl programming language release january this means that other implementations may lack support for some parts syntax shown here eg basic vs extended regex \ \ vs lack \d instead posix syntax conventions used these examples coincide with that other programming environments well meta- characters description example normally matches any character except newline within square brackets dot literal $string1 = hello world\n if $string1 =~ m// { print $string1 has length >= 5\n } output hello world has length >= groups series pattern elements single element when you match pattern within parentheses you can use any $1 $2 … later refer previously matched pattern $string1 = hello world\n if $string1 =~ m/ho/ { print we matched '$1' '$2'\n } output we matched 'hel' 'o w' + matches preceding pattern element one more times $string1 = hello world\n if $string1 =~ m/l+/ { print there are one more consecutive letter \l\'s $string1\n } output there are one more consecutive letter l's hello world matches preceding pattern element zero one time $string1 = hello world\n if $string1 =~ m/he/ { print there 'h' 'e' separated by print 0-1 characters eg he hue hee\n } output there 'h' 'e' separated by 0-1 characters eg he hue hee modifies + {mn}'d regex that comes before match few times possible $string1 = hello world\n if $string1 =~ m/l+o/ { print non-greedy match with 'l' followed by one or\n print more characters 'llo' rather than 'llo wo'\n } output non-greedy match with 'l' followed by one more characters 'llo' rather than 'llo wo' matches preceding pattern element zero more times $string1 = hello world\n if $string1 =~ m/elo/ { print there 'e' followed by zero many print 'l' followed by 'o' eg eo elo ello elllo\n } output there 'e' followed by zero many 'l' followed by 'o' eg eo elo ello elllo {mn} denotes minimum m maximum n match count n can be omitted m can be {m} matches exactly m times {m} matches at least m times {0n} matches at most n times x y+ z thus equivalent x{0} y{1} z{01} $string1 = hello world\n if $string1 =~ m/l{12}/ { print there exists substring with at least print at most l's $string1\n } output there exists substring with at least at most l's hello world denotes set possible character matches $string1 = hello world\n if $string1 =~ m/+/ { print $string1 contains one more vowels\n } output hello world contains one more vowels | separates alternate possibilities $string1 = hello world\n if $string1 =~ m/hello|hi|pogo/ { print $string1 contains at least one hello hi pogo } output hello world contains at least one hello hi pogo \b matches zero-width boundary between word-class character see next either non-word class character edge same ^\w|\w$|\w\w|\w\w $string1 = hello world\n if $string1 =~ m/llo\b/ { print there word that ends with 'llo'\n } output there word that ends with 'llo' \w matches alphanumeric character including same ascii unicode where alphabetic property contains more than latin letters decimalnumber property contains more than arab digits $string1 = hello world\n if $string1 =~ m/\w/ { print there at least one alphanumeric print character $string1 a-z a-z 0-9 \n } output there at least one alphanumeric character hello world a-z a-z 0-9 \w matches non-alphanumeric character excluding same ascii unicode $string1 = hello world\n if $string1 =~ m/\w/ { print space between hello print world not alphanumeric\n } output space between hello world not alphanumeric \s matches whitespace character which ascii are tab line feed form feed carriage return space unicode also matches no-break spaces next line variable- width spaces amongst others $string1 = hello world\n if $string1 =~ m/\s\s/ { print $string1 there are two whitespace characters which may print be separated by other characters\n } output hello world there are two whitespace characters which may be separated by other characters \s matches anything but whitespace $string1 = hello world\n if $string1 =~ m/\s\s/ { print $string1 there are two non-whitespace characters which print may be separated by other characters\n } output hello world there are two non-whitespace characters which may be separated by other characters \d matches digit same ascii unicode same \p{digit} \p{gc=decimalnumber} property which itself same \p{numerictype=decimal} property $string1 = bottles beer on wall if $string1 =~ m/\d+/ { print $1 first number '$string1'\n } output first number '99 bottles beer on wall' \d matches non-digit same ascii \p{digit} unicode $string1 = hello world\n if $string1 =~ m/\d/ { print there at least one character $string1 print that not digit\n } output there at least one character hello world that not digit matches beginning line string $string1 = hello world\n if $string1 =~ m/^he/ { print $string1 starts with characters 'he'\n } output hello world starts with characters 'he' $ matches end line string $string1 = hello world\n if $string1 =~ m/rld$/ { print $string1 line string print that ends with 'rld'\n } output hello world line string that ends with 'rld' \a matches beginning string but not internal line $string1 = hello\nworld\n if $string1 =~ m/\ah/ { print $string1 string print that starts with 'h'\n } output hello world string that starts with 'h' \z matches end string but not internal line $string1 = hello\nworld\n if $string1 =~ m/d\n\z/ { print $string1 string print that ends with 'd\\n'\n } output hello world string that ends with 'd\n' matches every character except ones inside brackets $string1 = hello world\n if $string1 =~ m// { print $string1 contains character other than print b c\n } output hello world contains character other than b c induction main article induction regular languages regular expressions can often be created induced learned based on set example strings this known induction regular languages part general problem grammar induction computational learning theory formally given examples strings regular language perhaps also given examples strings not that regular language possible induce grammar for language ie regular expression that generates that language not all regular languages can be induced this way see language identification limit but many can for example set examples {1 100} negative set counterexamples {11 0} can be used induce regular expression 1⋅0 followed by zero more 0s see also comparison regular expression engines extended backus–naur form regular tree grammar thompson's construction algorithm – converts regular expression into equivalent nondeterministic finite automaton nfa notes what regular expressions are exactly - terminology ruslan mitkov oxford handbook computational linguistics oxford university press p isbn 978-0-19-927634-9 mark v lawson september finite automata crc press pp 98–100 isbn 978-1-58488-255-8 kleene b thompson b johnson et al kernighan brian regular expressions matcher beautiful code o'reilly media pp 1–2 isbn 978-0-596-51004-6 retrieved ritchie dennis m incomplete history qed text editor retrieved october b aho & ullman bibliographic notes for chapter p aycock jit compilation techniques genesis p raymond eric s citing dennis ritchie jargon file grep new regular expression features tcl retrieved friedl jeffrey mechanics expression processing mastering regular expressions o'reilly media p isbn 0-596-52812-4 postgresql documentation pattern matching retrieved wall larry perl development team perlre perl regular expressions unicode localisation support retrieved russ cox regular expression matching can be simple fast but slow java perl php python ruby … retrieved b wall b c grep1 man page b hopcroft motwani & ullman sipser gelade & neven gruber & holzer kozen iso/iec 9945-21993 information technology – portable operating system interface posix – part shell utilities successively revised iso/iec 9945-22002 information technology – portable operating system interface posix – part system interfaces iso/iec 9945-22003 currently iso/iec/ieee information technology – portable operating system interface posix® base specifications issue single unix specification version perl regular expression documentation perldocperlorg retrieved january b regular expression syntax python documentation python software foundation retrieved october cezar câmpeanu kai salomaa sheng yu dec formal study practical regular expressions international journal foundations computer science 1007–1018 theorem p9 cox laurikari vim documentation pattern vimdocsourceforgenet retrieved b uts18 on unicode regular expressions annex character blocks retrieved replacement for google code search character 'm' not always required specify perl match operation for example m// could also be rendered // 'm' only necessary if user wishes specify match operation without using forward-slash regex delimiter sometimes useful specify alternate regex delimiter order avoid delimiter collision see 'perldoc perlre ' for more details eg see java nutshell p python scripting for computational science p programming php p note that all if statements return true value conway damian regular expressions end string perl best practices o'reilly p isbn 978-0-596-00173-5 references aho alfred v van leeuwen jan ed algorithms for finding patterns strings handbook theoretical computer science volume algorithms complexity mit press pp 255–300 aho alfred v ullman jeffrey d chapter patterns automata regular expressions pdf foundations computer science regular expressions single unix ® specification version open group chapter regular expressions open group base specifications issue ieee std edition open group cox russ regular expression matching can be simple fast forta ben sams teach yourself regular expressions minutes sams isbn 0-672-32566-7 friedl jeffrey mastering regular expressions o'reilly isbn 0-596-00289-0 gelade wouter neven frank succinctness complement intersection regular expressions proceedings 25th international symposium on theoretical aspects computer science stacs pp 325–336 goyvaerts jan levithan steven regular expressions cookbook isbn 978-0-596-52068-7 gruber hermann holzer markus finite automata digraph connectivity regular expression size pdf proceedings 35th international colloquium on automata languages programming icalp pp 39–50 doi 101007/978-3-540-70583-34 habibi mehran real world regular expressions with java springer isbn 1-59059-107-0 hopcroft john e motwani rajeev ullman jeffrey d introduction automata theory languages computation 2nd ed addison-wesley johnson w l porter j h ackley s i ross d t automatic generation efficient lexical processors using finite state techniques communications acm 805–813 doi 101145/364175364185 kleene stephen c shannon claude e mccarthy john eds representation events nerve nets finite automata automata studies princeton university press pp 3–42 kozen dexter completeness theorem for kleene algebras algebra regular events proceedings 6th annual ieee symposium on logic computer science lics 214–225 laurikari ville tre library liger francois craig mcqueen paul wilton visual basic net text manipulation handbook wrox press isbn 1-86100-730-2 sipser michael chapter regular languages introduction theory computation pws publishing pp 31–90 isbn 0-534-94728-x stubblebine tony regular expression pocket reference o'reilly isbn 0-596-00415-x thompson k programming techniques regular expression search algorithm communications acm 419–422 doi 101145/363347363387 wall larry apocalypse pattern matching external links wikibooks has book on topic regular expressions wikibook r programming has page on topic text processing regular expressions at dmoz iso/iec 9945-21993 information technology – portable operating system interface posix – part shell utilities iso/iec 9945-22002 information technology – portable operating system interface posix – part system interfaces iso/iec 9945-22003 information technology – portable operating system interface posix – part system interfaces iso/iec/ieee information technology – portable operating system interface posix® base specifications issue v t e automata theory formal languages formal grammars chomsky hierarchy grammars languages abstract machines type-0 — type-1 — — — — — type-2 — — type-3 — — unrestricted no common name context-sensitive positive range concatenation indexed — linear context-free rewriting systems tree-adjoining context-free deterministic context-free visibly pushdown regular — non-recursive recursively enumerable decidable context-sensitive positive range concatenation indexed — linear context-free rewriting language tree-adjoining context-free deterministic context-free visibly pushdown regular star-free finite turing machine decider linear-bounded ptime turing machine nested stack thread automaton restricted tree stack automaton embedded pushdown nondeterministic pushdown deterministic pushdown visibly pushdown finite counter-free with aperiodic finite monoid acyclic finite each category languages except those marked by proper subset category directly above any language each category generated by grammar by automaton category same line v t e strings string metric approximate string matching bitap algorithm damerau–levenshtein distance edit distance hamming distance jaro–winkler distance lee distance levenshtein automaton levenshtein distance wagner–fischer algorithm string searching algorithm apostolico–giancarlo algorithm boyer–moore string search algorithm boyer–moore–horspool algorithm knuth–morris–pratt algorithm rabin–karp string search algorithm multiple string searching aho–corasick commentz-walter algorithm rabin–karp regular expression comparison regular expression engines regular tree grammar thompson's construction nondeterministic finite automaton sequence alignment hirschberg's algorithm needleman–wunsch algorithm smith–waterman algorithm data structures dafsa suffix array suffix automaton suffix tree generalized suffix tree rope ternary search tree trie other parsing pattern matching compressed pattern matching longest common subsequence longest common substring sequential pattern mining sorting authority control gnd 4506116-6 ndl retrieved from https//enwikipediaorg/w/indexphptitle=regularexpression&oldid=751820026 categories automata computation formal languages pattern matching programming constructs regular expressions hidden categories wikipedia articles needing page number citations from february wikipedia articles that are too technical from september all articles that are too technical articles needing expert attention from september all articles needing expert attention wikipedia articles needing clarification from february articles needing additional references from september all articles needing additional references all articles with specifically marked weasel-worded phrases articles with specifically marked weasel-worded phrases from june all articles lacking reliable references articles lacking reliable references from september articles with dmoz links wikipedia articles with gnd identifiers articles with example code navigation menu personal tools not logged talk contributions create account log namespaces article talk variants views read edit view history more search navigation main page contents featured content current events random article donate wikipedia wikipedia store interaction help about wikipedia community portal recent changes contact page tools what links here related changes upload file special pages permanent link page information wikidata item cite this page print/export create book download pdf printable version other projects wikimedia commons wikibooks languages العربية български català čeština dansk deutsch ελληνικά español esperanto euskara فارسی français galego 한국어 հայերեն हिन्दी hrvatski íslenska italiano עברית ქართული кыргызча latviešu magyar македонски mirandés nederlands 日本語 norsk bokmål polski português română русский shqip simple english slovenčina српски / srpski suomi svenska தமிழ் ไทย türkçe українська اردو tiếng việt walon 中文 edit links this page was last modified on november at text available under creative commons attribution-sharealike license additional terms may apply by using this site you agree terms use privacy policy wikipedia® registered trademark wikimedia foundation inc non-profit organization privacy policy about wikipedia disclaimers contact wikipedia developers cookie statement mobile view 