assembly language from wikipedia free encyclopedia   redirected from assembler computing jump navigation search assembly language motorola mc6800 assembly listing showing original assembly language assembled form paradigm imperative unstructured first appeared years ago assembly assembler language often abbreviated asm low-level programming language for computer other programmable device which there very strong generally one-to-one correspondence between language architecture's machine code instructions each assembly language specific particular computer architecture contrast most high-level programming languages are generally portable across multiple architectures but require interpreting compiling assembly language may also be called symbolic machine code assembly language converted into executable machine code by utility program referred assembler conversion process referred assembly assembling source code assembly time computational step where assembler run assembly language uses mnemonic represent each low-level machine instruction operation typically also each architectural register flag etc many operations require one more operands order form complete instruction most assemblers can take expressions numbers named constants well registers labels operands freeing programmer from tedious repetitive calculations depending on architecture these elements may also be combined for specific instructions addressing modes using offsets other data well fixed addresses many assemblers offer additional mechanisms facilitate program development control assembly process aid debugging contents terminology key concepts o assembler + number passes + high-level assemblers o assembly language language design o basic elements + opcode mnemonics extended mnemonics + data directives + assembly directives o macros o support for structured programming use assembly language o historical perspective o current usage o typical applications list assemblers for different computer architectures further details see also references further reading external links terminology macro assembler includes macroinstruction facility so that parameterized assembly language text can be represented by name that name can be used insert expanded text into other code cross assembler see also cross compiler assembler that run on computer operating system host system different type from system on which resulting code run target system cross-assembling facilitates development programs for systems that do not have resources support software development such embedded system such case resulting object code must be transferred target system either via read-only memory rom eprom etc data link using exact bit-by-bit copy object code text-based representation that code such motorola s-record intel hex high-level assembler program that provides language abstractions more often associated with high-level languages such advanced control structures if/then/else do case etc high-level abstract data types including structures/records unions classes sets microassembler program that helps prepare microprogram called firmware control low level operation computer meta-assembler term used some circles for program that accepts syntactic semantic description assembly language generates assembler for that language key concepts assembler assembler program creates object code by translating combinations mnemonics syntax for operations addressing modes into their numerical equivalents this representation typically includes operation code opcode well other control bits data assembler also calculates constant expressions resolves symbolic names for memory locations other entities use symbolic references key feature assemblers saving tedious calculations manual address updates after program modifications most assemblers also include macro facilities for performing textual substitution – eg generate common short sequences instructions inline instead called subroutines some assemblers may also be able perform some simple types instruction set-specific optimizations one concrete example this may be ubiquitous x86 assemblers from various vendors most them are able perform jump-instruction replacements long jumps replaced by short relative jumps any number passes on request others may even do simple rearrangement insertion instructions such some assemblers for risc architectures that can help optimize sensible instruction scheduling exploit cpu pipeline efficiently possible like early programming languages such fortran algol cobol lisp assemblers have been available since 1950s first generations text based computer interfaces however assemblers came first they are far simpler write than compilers for high-level languages this because each mnemonic along with addressing modes operands instruction translates rather directly into numeric representations that particular instruction without much context analysis there have also been several classes translators semi automatic code generators with properties similar both assembly high level languages with speedcode perhaps one better known examples there may be several assemblers with different syntax for particular cpu instruction set architecture for instance instruction add memory data register x86-family processor might be add eax original intel syntax whereas this would be written addl %ebx%eax at&t syntax used by gnu assembler despite different appearances different syntactic forms generally generate same numeric machine code see further below single assembler may also have different modes order support variations syntactic forms well their exact semantic interpretations such fasm-syntax tasm-syntax ideal mode etc special case x86 assembly programming number passes there are two types assemblers based on how many passes through source are needed how many times assembler reads source produce executable program one-pass assemblers go through source code once any symbol used before defined will require errata at end object code at least no earlier than point where symbol defined telling linker loader go back overwrite placeholder which had been left where yet undefined symbol was used multi-pass assemblers create table with all symbols their values first passes then use table later passes generate code both cases assembler must be able determine size each instruction on initial passes order calculate addresses subsequent symbols this means that if size operation referring operand defined later depends on type distance operand assembler will make pessimistic estimate when first encountering operation if necessary pad with one more no-operation instructions later pass errata assembler with peephole optimization addresses may be recalculated between passes allow replacing pessimistic code with code tailored exact distance from target original reason for use one-pass assemblers was speed assembly – often second pass would require rewinding rereading program source on tape rereading deck cards punched paper tape with modern computers this has ceased be issue advantage multi-pass assembler that absence errata makes linking process program load if assembler directly produces executable code faster example following code snippet one-pass assembler would be able determine address backward reference bkwd when assembling statement s2 but would not be able determine address forward reference fwd when assembling branch statement s1 indeed fwd may be undefined two-pass assembler would determine both addresses pass so they would be known when generating code pass s1 b fwd fwd equ bkwd equ s2 b bkwd high-level assemblers more sophisticated high-level assemblers provide language abstractions such high-level procedure/function declarations invocations advanced control structures high-level abstract data types including structures/records unions classes sets sophisticated macro processing although available on ordinary assemblers since late 1950s for ibm series since 1960s for ibm/360 amongst other machines object-oriented programming features such classes objects abstraction polymorphism inheritance see language design below for more details assembly language program written assembly language consists series mnemonic processor instructions meta-statements known variously directives pseudo-instructions pseudo-ops comments data assembly language instructions usually consist opcode mnemonic followed by list data arguments parameters these are translated by assembler into machine language instructions that can be loaded into memory executed for example instruction below tells x86/ia-32 processor move immediate 8-bit value into register binary code for this instruction followed by 3-bit identifier for which register use identifier for al register so following machine code loads al register with data this binary computer code can be made more human-readable by expressing hexadecimal follows b0 here b0 means 'move copy following value into al' hexadecimal representation value which decimal assembly language for family provides mnemonic mov abbreviation move for instructions such this so machine code above can be written follows assembly language complete with explanatory comment if required after semicolon this much easier read remember mov al 61h load al with decimal hex some assembly languages same mnemonic such mov may be used for family related instructions for loading copying moving data whether these are immediate values values registers memory locations pointed by values registers other assemblers may use separate opcode mnemonics such l for move memory register st for move register memory lr for move register register mvi for move immediate operand memory etc x86 opcode b0 copies 8-bit value into al register while b1 moves into cl b2 does so into dl assembly language examples for these follow mov al 1h load al with immediate value mov cl 2h load cl with immediate value mov dl 3h load dl with immediate value syntax mov can also be more complex following examples show mov eax move bytes memory at address contained ebx into eax mov cl move contents cl into byte at address esi+eax each case mov mnemonic translated directly into opcode ranges 88-8e a0-a3 b0-b8 c6 c7 by assembler programmer does not have know remember which transforming assembly language into machine code job assembler reverse can at least partially be achieved by disassembler unlike high-level languages there usually one-to-one correspondence between simple assembly statements machine language instructions however some cases assembler may provide pseudoinstructions essentially macros which expand into several machine language instructions provide commonly needed functionality for example for machine that lacks branch if greater equal instruction assembler may provide pseudoinstruction that expands machine's set if less than branch if zero on result set instruction most full-featured assemblers also provide rich macro language discussed below which used by vendors programmers generate more complex code data sequences each computer architecture has its own machine language computers differ number type operations they support different sizes numbers registers representations data storage while most general-purpose computers are able carry out essentially same functionality ways they do so differ corresponding assembly languages reflect these differences multiple sets mnemonics assembly-language syntax may exist for single instruction set typically instantiated different assembler programs these cases most popular one usually that supplied by manufacturer used its documentation language design basic elements there large degree diversity way authors assemblers categorize statements nomenclature that they use particular some describe anything other than machine mnemonic extended mnemonic pseudo-operation pseudo-op typical assembly language consists types instruction statements that are used define program operations opcode mnemonics data definitions assembly directives opcode mnemonics extended mnemonics instructions statements assembly language are generally very simple unlike those high-level languages generally mnemonic symbolic name for single executable machine language instruction opcode there at least one opcode mnemonic defined for each machine language instruction each instruction typically consists operation opcode plus zero more operands most instructions refer single value pair values operands can be immediate value coded instruction itself registers specified instruction implied addresses data located elsewhere storage this determined by underlying processor architecture assembler merely reflects how this architecture works extended mnemonics are often used specify combination opcode with specific operand eg system/360 assemblers use b extended mnemonic for bc with mask nop no operation – do nothing for one step for bc with mask extended mnemonics are often used support specialized uses instructions often for purposes not obvious from instruction name for example many cpu's do not have explicit nop instruction but do have instructions that can be used for purpose cpus instruction xchg axax used for nop with nop being pseudo-opcode encode instruction xchg axax some disassemblers recognize this will decode xchg axax instruction nop similarly ibm assemblers for system/360 system/370 use extended mnemonics nop nopr for bc bcr with zero masks for sparc architecture these are known synthetic instructions some assemblers also support simple built-in macro-instructions that generate two more machine instructions for instance with some z80 assemblers instruction ld hlbc recognized generate ld lc followed by ld hb these are sometimes known pseudo-opcodes mnemonics are arbitrary symbols ieee published standard for uniform set mnemonics be used by all assemblers standard has since been withdrawn data directives there are instructions used define data elements hold data variables they define type data length alignment data these instructions can also define whether data available outside programs programs assembled separately only program which data section defined some assemblers classify these pseudo-ops assembly directives assembly directives also called pseudo-opcodes pseudo-operations pseudo-ops are commands given assembler directing perform operations other than assembling instructions directives affect how assembler operates may affect object code symbol table listing file values internal assembler parameters sometimes term pseudo-opcode reserved for directives that generate object code such those that generate data names pseudo-ops often start with dot distinguish them from machine instructions pseudo-ops can make assembly program dependent on parameters input by programmer so that one program can be assembled different ways perhaps for different applications pseudo-op can be used manipulate presentation program make easier read maintain another common use pseudo-ops reserve storage areas for run-time data optionally initialize their contents known values symbolic assemblers let programmers associate arbitrary names labels symbols with memory locations various constants usually every constant variable given name so instructions can reference those locations by name thus promoting self-documenting code executable code name each subroutine associated with its entry point so any calls subroutine can use its name inside subroutines goto destinations are given labels some assemblers support local symbols which are lexically distinct from normal symbols eg use 10$ goto destination some assemblers such nasm provide flexible symbol management letting programmers manage different namespaces automatically calculate offsets within data structures assign labels that refer literal values result simple computations performed by assembler labels can also be used initialize constants variables with relocatable addresses assembly languages like most other computer languages allow comments be added program source code that will be ignored during assembly judicious commenting essential assembly language programs meaning purpose sequence binary machine instructions can be difficult determine raw uncommented assembly language generated by compilers disassemblers quite difficult read when changes must be made macros many assemblers support predefined macros others support programmer-defined repeatedly re-definable macros involving sequences text lines which variables constants are embedded this sequence text lines may include opcodes directives once macro has been defined its name may be used place mnemonic when assembler processes such statement replaces statement with text lines associated with that macro then processes them if they existed source code file including some assemblers expansion any macros existing replacement text macros this sense date ibm autocoders 1950s assembly language term macro represents more comprehensive concept than does some other contexts such c programming language where its define directive typically used create short single line macros assembler macro instructions like macros pl/i some other languages can be lengthy programs by themselves executed by interpretation by assembler during assembly since macros can have 'short' names but expand several indeed many lines code they can be used make assembly language programs appear be far shorter requiring fewer lines source code with higher level languages they can also be used add higher levels structure assembly programs optionally introduce embedded debugging code via parameters other similar features macro assemblers often allow macros take parameters some assemblers include quite sophisticated macro languages incorporating such high-level language elements optional parameters symbolic variables conditionals string manipulation arithmetic operations all usable during execution given macro allowing macros save context exchange information thus macro might generate numerous assembly language instructions data definitions based on macro arguments this could be used generate record-style data structures unrolled loops for example could generate entire algorithms based on complex parameters organization using assembly language that has been heavily extended using such macro suite can be considered be working higher-level language since such programmers are not working with computer's lowest-level conceptual elements underlining this point macros were used implement early virtual machine snobol4 which was written snobol implementation language sil assembly language for virtual machine which was then targeted physical machines by transpiled native assembler via macro assembler this allowed high degree portability for time macros were used customize large scale software systems for specific customers mainframe era were also used by customer personnel satisfy their employers' needs by making specific versions manufacturer operating systems this was done for example by systems programmers working with ibm's conversational monitor system / virtual machine vm/cms with ibm's real time transaction processing add-ons customer information control system cics acp/tpf airline/financial system that began 1970s still runs many large computer reservations systems crs credit card systems today also possible use solely macro processing abilities assembler generate code written completely different languages for example generate version program cobol using pure macro assembler program containing lines cobol code inside assembly time operators instructing assembler generate arbitrary code ibm os/360 uses macros perform system generation user specifies options by coding series assembler macros assembling these macros generates job stream build system including job control language utility control statements this because was realized 1960s concept macro processing independent concept assembly former being modern terms more word processing text processing than generating object code concept macro processing appeared appears c programming language which supports preprocessor instructions set variables make conditional tests on their values note that unlike certain previous macro processors inside assemblers c preprocessor not turing-complete because lacks ability either loop go latter allowing programs loop despite power macro processing fell into disuse many high level languages major exceptions being c/c++ pl/i while remaining perennial for assemblers macro parameter substitution strictly by name at macro processing time value parameter textually substituted for its name most famous class bugs resulting was use parameter that itself was expression not simple name when macro writer expected name macro foo macro load ab intention was that caller would provide name variable global variable constant b would be used multiply if foo called with parameter a-c macro expansion load a-cb occurs avoid any possible ambiguity users macro processors can parenthesize formal parameters inside macro definitions callers can parenthesize input parameters support for structured programming some assemblers have incorporated structured programming elements encode execution flow earliest example this approach was concept-14 macro set originally proposed by dr harlan mills march implemented by marvin kessler at ibm's federal systems division which extended s/360 macro assembler with if/else/endif similar control flow blocks this was way reduce eliminate use goto operations assembly code one main factors causing spaghetti code assembly language this approach was widely accepted early '80s latter days large-scale assembly language use curious design was a-natural stream-oriented assembler for 8080/z80 processors from whitesmiths ltd developers unix -like idris operating system what was reported be first commercial c compiler language was classified assembler because worked with raw machine elements such opcodes registers memory references but incorporated expression syntax indicate execution order parentheses other special symbols along with block-oriented structured programming constructs controlled sequence generated instructions a-natural was built object language c compiler rather than for hand-coding but its logical syntax won some fans there has been little apparent demand for more sophisticated assemblers since decline large-scale assembly language development spite that they are still being developed applied cases where resource constraints peculiarities target system's architecture prevent effective use higher-level languages assemblers with strong macro engine allow structured programming via macros such switch macro provided with masm32 package note this code complete program include \masm32\include\masm32rtinc use masm32 library code demomain repeat switch rvnrandom generate number between mov ecx case print case case ecx contrast most other programming languages print case masm32 switch allows variable cases case if eax==1 print case elseif eax==2 print case else print cases other endif case print cases default mov ebx print stars repeat print dec ebx until sign loop until sign flag set endsw print chr$13 endm exit end demomain use assembly language historical perspective assembly languages use word assembly date introduction stored-program computer electronic delay storage automatic calculator edsac had assembler called initial orders featuring one-letter mnemonics soap symbolic optimal assembly program was assembly language for ibm computer written by stan poley assembly languages eliminate much error-prone tedious time-consuming first-generation programming needed with earliest computers freeing programmers from tedium such remembering numeric codes calculating addresses they were once widely used for all sorts programming however by 1980s 1990s on microcomputers their use had largely been supplanted by higher-level languages search for improved programming productivity today assembly language still used for direct hardware manipulation access specialized processor instructions address critical performance issues typical uses are device drivers low-level embedded systems real-time systems historically numerous programs have been written entirely assembly language operating systems were entirely written assembly language until introduction burroughs mcp which was written executive systems problem oriented language espol algol dialect many commercial applications were written assembly language well including large amount ibm mainframe software written by large corporations cobol fortran some pl/i eventually displaced much this work although number large organizations retained assembly-language application infrastructures well into 1990s most early microcomputers relied on hand-coded assembly language including most operating systems large applications this was because these systems had severe resource constraints imposed idiosyncratic memory display architectures provided limited buggy system services perhaps more important was lack first-class high-level language compilers suitable for microcomputer use psychological factor may have also played role first generation microcomputer programmers retained hobbyist wires pliers attitude more commercial context biggest reasons for using assembly language were minimal bloat size minimal overhead greater speed reliability typical examples large assembly language programs from this time are ibm pc dos operating systems early applications such spreadsheet program lotus 1-2-3 even into 1990s most console video games were written assembly including most games for mega drive/genesis super nintendo entertainment system according some industry insiders assembly language was best computer language use get best performance out sega saturn console that was notoriously challenging develop program games for arcade game nba jam another example assembly language has long been primary development language for many popular home computers 1980s 1990s such msx sinclair zx spectrum commodore commodore amiga atari st this was large part because interpreted basic dialects on these systems offered insufficient execution speed well insufficient facilities take full advantage available hardware on these systems some systems even have integrated development environment ide with highly advanced debugging macro facilities current usage there have always been debates over usefulness performance assembly language relative high-level languages assembly language has specific niche uses where important see below tiobe index programming language popularity currently november at rank ahead for example swift ruby assembler can be used optimize for speed optimize for size case speed optimization modern optimizing compilers are claimed render high-level languages into code that can run fast hand-written assembly despite counter-examples that can be found complexity modern processors memory sub-systems makes effective optimization increasingly difficult for compilers well assembly programmers moreover increasing processor performance has meant that most cpus sit idle most time with delays caused by predictable bottlenecks such cache misses i/o operations paging this has made raw code execution speed non-issue for many programmers there are some situations which developers might choose use assembly language stand-alone executable compact size required that must execute without recourse run-time components libraries associated with high-level language this perhaps most common situation for example firmware for telephones automobile fuel ignition systems air-conditioning control systems security systems sensors code that must interact directly with hardware for example device drivers interrupt handlers embedded processor dsp high-repetition interrupts require shortest number cycles per interrupt such interrupt that occurs times second programs that need use processor-specific instructions not implemented compiler common example bitwise rotation instruction at core many encryption algorithms well querying parity byte 4-bit carry addition programs that create vectorized functions for programs higher-level languages such c higher-level language this sometimes aided by compiler intrinsic functions which map directly simd mnemonics but nevertheless result one-to-one assembly conversion specific for given vector processor programs requiring extreme optimization for example inner loop processor-intensive algorithm game programmers take advantage abilities hardware features systems enabling games run faster also large scientific simulations require highly optimized algorithms eg linear algebra with blas discrete cosine transformation eg simd assembly version from x264 situations where no high-level language exists on new specialized processor for example programs that need precise timing such o real-time programs such simulations flight navigation systems medical equipment for example fly-by-wire system telemetry must be interpreted acted upon within strict time constraints such systems must eliminate sources unpredictable delays which may be created by some interpreted languages automatic garbage collection paging operations preemptive multitasking however some higher-level languages incorporate run-time components operating system interfaces that can introduce such delays choosing assembly lower-level languages for such systems gives programmers greater visibility control over processing details o cryptographic algorithms that must always take strictly same time execute preventing timing attacks modify extend legacy code written for ibm mainframe computers situations where complete control over environment required extremely high security situations where nothing can be taken for granted computer viruses bootloaders certain device drivers other items very close hardware low-level operating system instruction set simulators for monitoring tracing debugging where additional overhead kept minimum reverse-engineering modifying program files such o existing binaries that may may not have originally been written high-level language for example when trying recreate programs for which source code not available has been lost cracking copy protection proprietary software o video games also termed rom hacking which possible via several methods most widely employed method altering program code at assembly language level self-modifying code which assembly language lends itself well games other software for graphing calculators assembly language still taught most computer science electronic engineering programs although few programmers today regularly work with assembly language tool underlying concepts remain very important such fundamental topics binary arithmetic memory allocation stack processing character set encoding interrupt processing compiler design would be hard study detail without grasp how computer operates at hardware level since computer's behavior fundamentally defined by its instruction set logical way learn such concepts study assembly language most modern computers have similar instruction sets therefore studying single assembly language sufficient learn i basic concepts ii recognize situations where use assembly language might be appropriate iii see how efficient executable code can be created from high-level languages this analogous children needing learn basic arithmetic operations eg long division although calculators are widely used for all except most trivial calculations typical applications assembly language typically used system's boot code low-level code that initializes tests system hardware prior booting operating system often stored rom bios on ibm-compatible pc systems cp/m example some compilers translate high-level languages into assembly first before fully compiling allowing assembly code be viewed for debugging optimization purposes relatively low-level languages such c allow programmer embed assembly language directly source code programs using such facilities such linux kernel can then construct abstractions using different assembly language on each hardware platform system's portable code can then use these processor-specific components through uniform interface assembly language useful reverse engineering many programs are distributed only machine code form which straightforward translate into assembly language but more difficult translate into higher-level language tools such interactive disassembler make extensive use disassembly for such purpose this technique used by hackers crack commercial software competitors produce software with similar results from competing companies assembly language used enhance speed execution especially early personal computers with limited processing power ram assemblers can be used generate blocks data with no high-level language overhead from formatted commented source code be used by other code list assemblers for different computer architectures main article list assemblers further details for any given personal computer mainframe embedded system game console both past present at least one – possibly dozens – assemblers have been written for some examples see list assemblers on unix systems assembler traditionally called although not single body code being typically written anew for each port number unix variants use gnu assembler called gas which cross-assembler for many host systems many targets within processor groups each assembler has its own dialect sometimes some assemblers can read another assembler's dialect for example tasm can read old masm code but not reverse fasm nasm have similar syntax but each support different macros that could make them difficult translate each other basics are all same but advanced features will differ also assembly can sometimes be portable across different operating systems on same type cpu calling conventions between operating systems often differ slightly not at all with care possible gain some portability assembly language usually by linking with c library that does not change between operating systems instruction set simulator can process object code/ binary any assembler achieve portability even across platforms with overhead no greater than typical bytecode interpreter this similar use microcode achieve compatibility across processor family some higher level computer languages such c borland pascal support inline assembly where sections assembly code practice usually brief can be embedded into high level language code forth language commonly contains assembler used code words emulator can be used debug assembly-language programs see also computer programming portal computer science portal compiler disassembler data segment hexadecimal nibble high level assembly instruction set spaghetti code little man computer – educational computer model with base-10 assembly language typed assembly language references assembler language ibm knowledge center saxon james plette william programming ibm prentice-hall loc 62-20615 missing empty |url= help john daintith ed dictionary computing meta-assembler b david salomon assemblers loaders beck leland l system software introduction systems programming addison wesley hyde randall chapter – classes objects art assembly language 2nd edition no starch press © intel architecture software developer's manual volume instruction set reference pdf intel corporation retrieved november b c intel architecture software developer's manual volume instruction set reference pdf intel corporation pp retrieved november evans david x86 assembly guide university virginia retrieved november sparc architecture manual version pdf sparc international z80 op codes for zint z80de retrieved on microsoft corporation masm directives & pseudo-opcodes pdf retrieved march griswold ralph e macro implementation snobol4 san francisco ca w h freeman company isbn 0-7167-0447-1 chapter macros c/c++ msdn library for visual studio microsoft corp retrieved concept macros mvs software retrieved may answerscom assembly language definition much more from answerscom retrieved provinciano brian neshla high level open source assembler for nintendo entertainment system salomon assemblers loaders pdf p retrieved ibm magnetic drum calculator retrieved eidolon's inn segabase saturn tiobe index for november retrieved rusling david linux kernel retrieved mar b writing fastest code by hand for fun human computer keeps speeding up chips new york times john markoff retrieved bit-field-badness hardwarebugorg archived from original on february retrieved gcc makes mess hardwarebugorg archived from original on march retrieved randall hyde great debate archived from original on june retrieved code sourcery fails again hardwarebugorg archived from original on april retrieved click cliff crash course modern hardware retrieved may blas benchmark-august2008 eigentuxfamilyorg retrieved x264git/common/x86/dct-32asm gitvideolanorg retrieved chapter – why study assembly language wwwedwardbosworthcom retrieved 68k programming fargo ii archived from original on july retrieved hyde randall foreword why would anyone learn this stuff op cit archived from original on march retrieved randall hyde which assembler best archived from original on october retrieved further reading yurichev dennis introduction reverse engineering for beginners online book asm community book online book full helpful asm info tutorials code examples by asm community archived at internet archive jonathan bartlett programming from ground up bartlett publishing isbn 0-9752838-4-7 also available online pdf robert britton mips assembly language programming prentice hall isbn 0-13-142044-5 paul carter pc assembly language free ebook website jeff duntemann assembly language step-by-step wiley isbn 0-471-37523-3 randall hyde art assembly language no starch press isbn 1-886411-97-2 draft versions available online pdf html charles w kann introduction mips assembly language programming peter norton john socha peter norton's assembly language book for ibm pc brady books ny michael singer pdp-11 assembler language programming machine organization john wiley & sons ny dominic sweetman see mips run morgan kaufmann publishers isbn 1-55860-410-3 john waldron introduction risc assembly language programming addison wesley isbn 0-201-39828-1 external links find more aboutassembly languageat wikipedia's sister projects definitions from wiktionary media from commons news from wikinews textbooks from wikibooks learning resources from wikiversity unix assembly language programming linux assembly ppr learning assembly language nasm – netwide assembler popular assembly language assembly language programming examples authoring windows applications assembly language assembly optimization tips by mark larson } } art assembly language by randall hyde v t e types programming languages actor-based array aspect-oriented class-based concatenative concurrent data-structured dataflow declarative domain-specific dynamic esoteric event-driven extensible functional imperative logic macro metaprogramming+multi-paradigm object-based object-oriented pipeline procedural prototype-based reflective rule-based scripting synchronous templating assembly compiled interpreted machine low-level high-level very high-level first generation second generation third generation fourth generation fifth generation non-english-based visual v t e programming languages comparison timeline history assembly basic c c++ c cobol fortran go haskell java javascript js lisp lua objective-c pascal perl php python ruby shell smalltalk swift visual basic net vbnet more category comparison lists o alphabetical o categorical o generational o non-english-based authority control lccn sh85008765 gnd 4003255-3 bnf cb11961749m data retrieved from https//enwikipediaorg/w/indexphptitle=assemblylanguage&oldid=751477607assembler categories assembly languages programming language implementation programming languages created software computer-related introductions hidden categories pages using web citations with no url pages using isbn magic links all articles with unsourced statements articles with unsourced statements from november articles with unsourced statements from december articles with unsourced statements from january articles with unsourced statements from february all articles with specifically marked weasel-worded phrases articles with specifically marked weasel-worded phrases from november articles with unsourced statements from march wikipedia articles with lccn identifiers wikipedia articles with gnd identifiers wikipedia articles with bnf identifiers navigation menu personal tools not logged talk contributions create account log namespaces article talk variants views read edit view history more search navigation main page contents featured content current events random article donate wikipedia wikipedia store interaction help about wikipedia community portal recent changes contact page tools what links here related changes upload file special pages permanent link page information wikidata item cite this page print/export create book download pdf printable version other projects wikimedia commons wikibooks wikiversity languages العربية azərbaycanca বাংলা беларуская тарашкевіца‎ български bosanski català čeština dansk deutsch eesti ελληνικά español esperanto euskara فارسی français gaeilge galego 한국어 հայերեն हिन्दी hrvatski bahasa indonesia íslenska italiano עברית ქართული қазақша kurdî latviešu lietuvių lumbaart magyar മലയാളം bahasa melayu mirandés монгол nederlands 日本語 norsk bokmål ਪੰਜਾਬੀ polski português română русский scots shqip සිංහල simple english slovenčina slovenščina српски / srpski srpskohrvatski / српскохрватски suomi svenska ไทย türkçe українська tiếng việt 中文 edit links this page was last modified on november at text available under creative commons attribution-sharealike license additional terms may apply by using this site you agree terms use privacy policy wikipedia® registered trademark wikimedia foundation inc non-profit organization privacy policy about wikipedia disclaimers contact wikipedia developers cookie statement mobile view 