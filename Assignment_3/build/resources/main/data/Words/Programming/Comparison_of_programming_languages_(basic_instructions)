comparison programming languages basic instructions from wikipedia free encyclopedia jump navigation search this article needs additional citations for verification please help improve this article by adding citations reliable sources unsourced material may be challenged removed february learn how when remove this template message programming language comparisons general comparison basic syntax basic instructions exception handling enumerated types anonymous functions conditional expressions functional instructions arrays associative arrays string operations string functions list comprehension object-oriented programming object-oriented constructors while loops for loops evaluation strategy list hello world programs languages with dependent types comparison type systems ------------------------------------------------------------------------ comparison individual languages algol 58's influence on algol algol comparisons with other languages comparison algol c++ algol comparisons with other languages compatibility c c++ comparison pascal borland delphi comparison object pascal c comparison pascal c comparison java c++ comparison c java comparison c visual basic net comparison visual basic visual basic net v t e comparison programming languages common topic discussion among software engineers basic instructions several programming languages are compared here contents conventions this article type identifiers o integers o floating point o complex numbers o other variable types derived types o array o other types variable constant declarations control flow o conditional statements o loop statements o exceptions o other control flow statements functions type conversions standard stream i/o reading command-line arguments execution commands references conventions this article bold literal code non-bold interpreted by reader statements guillemets « … » are optional tab ↹ indicates necessary indent with whitespace type identifiers integers bit byte bit short integer bit bit long integer word size arbitrarily precise bignum signed unsigned signed unsigned signed unsigned signed unsigned signed unsigned ada range - range - mod range - range - mod range - range - mod range - mod integer range 2integer'size - mod integer'size n/a algol variable-width short short int n/a short int n/a int n/a long int n/a int n/a long long int bytes & bits c c99 fixed-width int8t uint8t int16t uint16t int32t uint32t int64t uint64t int unsigned int n/a c++ c++11 fixed-width c c99 variable-width signed char unsigned char short unsigned short long unsigned long long long unsigned long long c++ c++11 variable-width objective-c cocoa signed char int8t unsigned char uint8t short int16t unsigned short uint16t int int32t unsigned int uint32t long long int64t unsigned long long uint64t nsinteger long nsuinteger unsigned long c sbyte byte short ushort int uint long ulong intptr uintptr systemnumericsbiginteger net java byte n/a char n/a n/a n/a n/a javamathbiginteger go int8 uint8 byte int16 uint16 int32 uint32 int64 uint64 int uint bigint swift int8 uint8 int16 uint16 int32 uint32 int64 uint64 int uint d byte ubyte short ushort int uint long ulong n/a n/a bigint common lisp integer integer integer integer integer integer integer integer bignum scheme islisp bignum pascal fpc shortint byte smallint word longint longword int64 qword integer cardinal n/a visual basic n/a byte integer n/a long n/a n/a n/a n/a visual basic net sbyte short ushort integer uinteger long ulong systemnumericsbiginteger net freebasic byte integer ubyte uinteger short integer ushort uinteger long integer ulong uinteger longint integer ulongint uinteger integer uinteger n/a python 2x n/a n/a n/a n/a int n/a long python 3x n/a n/a n/a n/a n/a int s-lang n/a n/a n/a n/a n/a n/a fortran integerkind = n n/a integerkind = n n/a integer kind = n n/a integerkind = n n/a php n/a n/a int n/a int n/a n/a perl n/a n/a n/a n/a n/a mathbigint perl int8 uint8 int16 uint16 int32 uint32 int64 uint64 int n/a ruby n/a n/a n/a n/a fixnum n/a bignum erlang n/a n/a n/a n/a integer n/a integer scala byte n/a short char int n/a long n/a n/a n/a scalamathbigint seed7 n/a n/a n/a n/a n/a n/a integer n/a n/a n/a biginteger smalltalk n/a n/a n/a n/a smallinteger n/a largeinteger windows powershell n/a n/a n/a n/a n/a n/a ocaml n/a n/a int32 n/a int64 n/a int nativeint open bigint bigint f sbyte byte int16 uint16 int32 int uint32 uint64 nativeint unativeint bigint standard ml n/a word8word n/a int32int word32word int64int word64word int word largeintint intinfint haskell ghc «import int» int8 «import word» word8 «import int» int16 «import word» word16 «import int» int32 «import word» word32 «import int» int64 «import word» word64 int «import word» word integer eiffel integer8 natural8 integer16 natural16 integer32 natural32 integer64 natural64 integer natural n/a cobol binary-char «signed» binary-char unsigned binary-short «signed» binary-short unsigned binary-long «signed» binary-long unsigned binary-double «signed» binary-double unsigned n/a n/a n/a mathematica n/a n/a n/a n/a n/a integer wolfram language n/a n/a n/a n/a n/a integer ^a standard constants int shorts int lengths can be used determine how many 'short's 'long's can be usefully prefixed 'short int' 'long int' actually size 'short int' 'int' 'long int' available constants short max int max int long max int etc ^b commonly used for characters ^c algol c c++ languages do not specify exact width integer types short int long c99 c++11 long long so they are implementation-dependent c c++ short long long long types are required be at least bits wide respectively but can be more int type required be at least wide short at most wide long typically width word size on processor machine ie on 32-bit machine often bits wide on 64-bit machines often bits wide c99 c++11 also define intnt exact-width types stdinth header seec syntaxintegral types for more information ^d perl does not have distinct types integers floating point numbers strings etc are all considered scalars ^e php has two arbitrary-precision libraries bcmath library just uses strings datatype gmp library uses internal resource type ^f value n provided by selectedintkind intrinsic function ^g algol 68g's run time option --precision number can set precision for long long ints required number significant digits standard constants long long int width long long max int can be used determine actual precision ^h cobol allows specification required precision will automatically select available type capable representing specified precision pic s9999 for example would required signed variable four decimal digits precision if specified binary field this would select bit signed type on most platforms ^i smalltalk automatically chooses appropriate representation for integral numbers typically two representations are present one for integers fitting native word size minus any tag bit smallinteger one supporting arbitrary sized integers largeinteger arithmetic operations support polymorphic arguments return result most appropriate compact representation ^j ada range types are checked for boundary violations at run-time well at compile-time for static expressions run time boundary violations raise constraint error exception ranges are not restricted powers two commonly predefined integer subtypes are positive range integer'last natural range integer'last shortshortinteger bit shortinteger bit longinteger bit are also commonly predefined but not required by ada standard run time checks can be disabled if performance more important than integrity checks ^k ada modulo types implement modulo arithmetic all operations ie no range violations are possible modulos are not restricted powers two ^l commonly used for characters like java's char ^m int php has same width long type c has on that system ^n erlang dynamically typed type identifiers are usually used specify types record fields argument return types functions ^o when exceeds word floating point single precision double precision other precision processor dependent ada float longfloat n/a algol real long real short real long long real etc c float double long double c++ stl objective-c cocoa cgfloat c float n/a java go float32 float64 swift float float32 double float64 float80 cgfloat d float double real common lisp float short-float single-float double-float long-float scheme islisp pascal free pascal single double real visual basic single double n/a visual basic net xojo python n/a float javascript number n/a s-lang fortran realkind = n php float perl perl num32 num64 num ruby n/a float n/a scala float double seed7 n/a float smalltalk float double windows powershell ocaml n/a float n/a f float32 standard ml n/a real haskell ghc float double eiffel real32 real64 cobol float-binary-7 float-binary-34 float-short float-long float-extended mathematica n/a n/a real ^a standard constants real shorts real lengths can be used determine how many 'short's 'long's can be usefully prefixed 'short real' 'long real' actually size 'short real' 'real' ' long real' available constants short max real max real long max real etc with constants short small real small real long small real available for each type's machine epsilon ^b declarations single precision often are not honored ^c value n provided by selectedrealkind intrinsic function ^d algol 68g's run time option --precision number can set precision for long long reals required number significant digits standard constants long long real width 'long long max real can be used determine actual precision ^e these ieee floating-point types will be introduced next cobol standard ^f same size 'double' on many implementations ^g swift supports 80-bit extended precision floating point type equivalent long double c languages complex numbers integer single precision double precision half quadruple precision etc ada n/a complex complex complex algol n/a compl long compl etc short compl etc & long long compl etc c c99 n/a float complex double complex n/a c++ stl n/a stdcomplex stdcomplex c n/a n/a systemnumericscomplex net java n/a n/a n/a go n/a complex64 complex128 d n/a cfloat cdouble objective-c n/a n/a n/a common lisp complex integer complex single-float complex double-float complex scheme n/a pascal n/a n/a visual basic n/a n/a visual basic net n/a n/a systemnumericscomplex net perl mathcomplex perl complex64 complex128 complex python complex n/a javascript n/a n/a s-lang n/a n/a fortran complexkind = n ruby complex n/a complex scala n/a n/a n/a seed7 n/a n/a complex smalltalk complex complex complex windows powershell n/a n/a ocaml n/a n/a complext f systemnumericscomplex net standard ml n/a n/a n/a haskell ghc n/a complexcomplex float complexcomplex double eiffel n/a n/a n/a cobol n/a n/a n/a mathematica complex n/a n/a complex ^a value n provided by selectedrealkind intrinsic function ^b generic type which can be instantiated with any base floating point type other variable types text boolean enumeration object/universal character string ada character string & boundedstring & unboundedstring boolean item1 item2 tagged null record algol char string & bytes bool & bits n/a - user defined n/a c c99 char wchart n/a bool enum «name» {item1 item2 } void c++ stl «std»string objective-c unichar nsstring bool id c char string bool enum name {item1 item2 } object java string boolean object go byte rune string bool const item1 = iota item2 interface{} swift character string bool enum name { case item1 item2 } any d char string bool enum name {item1 item2 } stdvariantvariant common lisp scheme islisp pascal iso char n/a boolean item1 item2 n/a object pascal delphi string variant visual basic n/a string boolean enum name item1 item2 end enum variant visual basic net char object xojo n/a object variant python n/a str bool object javascript n/a string boolean object s-lang fortran characterlen = characterlen = allocatable logicalkind = n class php n/a string bool type declaration omitted perl n/a universal perl char str bool enum name enum name > mu ruby n/a string object object scala char string boolean object name extends enumeration { val item1 item2 = value } any seed7 char string boolean const type name new enum item1 item2 end enum windows powershell ocaml char string bool n/a n/a f type name = item1 = value | item2 = value | obj standard ml n/a n/a haskell ghc char string bool n/a n/a eiffel character string boolean n/a any cobol pic x pic xstring length pic x«x» pic 1«number digits » pic 1«1» n/a object reference mathematica n/a string n/a ^a specifically strings arbitrary length automatically managed ^b this language represents boolean integer where false represented value zero true by non-zero value ^c all values evaluate either true false everything trueclass evaluates true everything falseclass evaluates false ^d this language does not have separate character type characters are represented strings length ^e enumerations this language are algebraic types with only nullary constructors ^f value n provided by selectedintkind intrinsic function derived types array further information comparison programming languages array fixed size array dynamic size array one-dimensional array multi-dimensional array one-dimensional array multi-dimensional array ada array array array array array range array range range algol «modename» simply «modename» «modename» «modename» etc flex«modename» simply flex«modename» flex«modename» flexflex«modename» etc c c99 type name type name type name within block int n = type name c++ stl «std»arrayc++11 «std»vector c type type systemcollectionsarraylist systemcollectionsgenericlist java type type arraylist arraylist d type type type go type type type type swift array ] array> objective-c nsarray nsmutablearray javascript n/a n/a array common lisp scheme islisp pascal array type array array type array type n/a n/a object pascal delphi array type array array type visual basic visual basic net systemcollectionsarraylist systemcollectionsgenericlistof type python list s-lang fortran type namesize type namesize1 size2 type allocatable name type allocatable name php array perl perl array array type ruby array scala array array]] arraybuffer seed7 array type array type array array type array array type array type array type array array type array array type smalltalk array orderedcollection windows powershell type type ocaml type array type array array f type type array type systemcollectionsarraylist systemcollectionsgenericlist standard ml type vector type array haskell ghc cobol level-number type occurs size «times» one-dimensional array definition level-number type occurs min-size max-size «times» depending «on» size n/a ^a most expressions except sizeof & operators values array types c are automatically converted pointer its first argument see c syntaxarrays for further details syntax pointer operations ^b c-like type x works java however type x preferred form array declaration ^c subranges are used define bounds array ^d javascript's array are special kind object ^e depending on clause cobol does not create 'true' variable length array will always allocate maximum size array other types simple composite types algebraic data types unions records tuple expression ada type identifier «abstract» «tagged» «limited» n/a any combination records unions enumerations well references those enabling recursive types type identifier variation discretetype record case variation when choicelist1 => fieldname1 type when choicelist2 => fieldname2 type end case end record algol struct modename «fieldname» required types operators can be user defined union modename c c99 struct «name» {type name} n/a n/a union {type name} objective-c c++ struct «name» {type name} «std»tuple c struct name {type name} n/a java n/a javascript n/a d struct name {type name} stdvariantalgebraictype union { type name} go struct { «name» type } swift struct name { var name « type» } «name1» val1 «name2» val2 «name3» val3 enum name { case foo«types» case bar «types» } common lisp cons val1 val2 scheme n/a islisp pascal record name type end n/a n/a record case type value types end visual basic visual basic net structure name dim name type end structure python n/a «»val1 val2 val3 «» n/a s-lang struct {name } fortran type name type name end type php n/a perl n/a n/a perl n/a ruby openstructnew{name => value} scala case class name«var» name type val1 val2 val3 abstract class name case class foo«parameters» extends name case class bar«parameters» extends name abstract class name case object foo extends name case object bar extends name combination case classes case objects windows powershell ocaml type name = {«mutable» name type} «»val1 val2 val3 « » type name = foo «of type» | bar «of type» | n/a f standard ml type name = {name type} val1 val2 val3 datatype name = foo «of type» | bar «of type» | haskell data name = constr {name type} data name = foo «types» | bar «types» | cobol level-number name type clauses level-number+n name type clauses n/a n/a name redefines variable type ^a only classes are supported ^b structs c++ are actually classes but have default public visibility are also pod objects c++11 extended this further make classes act identically pod objects many more cases ^c pair only ^d although perl doesn't have records because perl's type system allows different data types be array hashes associative arrays that don't have variable index would effectively be same records ^e enumerations this language are algebraic types with only nullary constructors variable constant declarations variable constant type synonym ada identifier type «= initialvalue» identifier constant type = finalvalue subtype identifier type algol modename name «= initialvalue» modename name = value mode synonym = modename c c99 type name «= initialvalue» enum{ name = value } typedef type synonym objective-c c++ const type name = value c type name «= initialvalue» var name = value const type name = value readonly type name = value using synonym = type d type name «= initialvalue» auto name = value const type name = value immutable type name = value alias type synonym java type name «= initialvalue» final type name = value n/a javascript var name «= initialvalue» const name = value go var name type «= initialvalue» name = initialvalue const name «type» = value type synonym type swift var name « type» «= initialvalue» let name « type» = value typealias synonym = type common lisp defparameter name initialvalue defvar name initialvalue setf symbol-value 'symbol initialvalue defconstant name value deftype synonym 'type scheme define name initialvalue islisp defglobal name initialvalue defdynamic name initialvalue defconstant name value n/a pascal name type «= initialvalue» name = value synonym = type visual basic dim name type const name type = value visual basic net dim name type«= initialvalue» imports synonym = type xojo dim name type«= initialvalue» n/a python name = initialvalue n/a synonym = type coffeescript n/a s-lang name = initialvalue typedef struct {} typename fortran type name type parameter name = value php $name = initialvalue definename value const name = value 53+ n/a perl «my» $name «= initialvalue» use constant name => value perl «my «type»» $name «= initialvalue» «my «type»» constant name = value synonym = type ruby name = initialvalue name = value synonym = type scala var name« type» = initialvalue val name« type» = value type synonym = type windows powershell «» $name = initialvalue n/a n/a bash shell name=initialvalue n/a n/a ocaml let name « type ref» = ref value let name « type» = value type synonym = type f let mutable name « type» = value standard ml val name « type ref» = ref value val name « type» = value haskell «nametype» name = value type synonym = type forth variable name some systems use value variable name instead value constant name cobol level-number name type clauses «0»1 name constant «as» value level-number name type clauses «is» typedef mathematica name=initialvalue n/a n/a ^a pascal has declaration blocks see comparison programming languages basic instructionsfunctions ^b types are just regular objects so you can just assign them ^c perl my keyword scopes variable into block ^d technically this does not declare name be mutable variable—in ml all names can only be bound once rather declares name point reference data structure which simple mutable cell data structure can then be read written using = operators respectively if no initial value given invalid value automatically assigned which will trigger run-time exception if used before valid value has been assigned while this behaviour can be suppressed recommended interest predictability if no invalid value can be found for type for example case unconstraint integer type valid yet predictable value chosen instead control flow conditional statements if else if select case conditional expression ada if condition then statements «else statements» end if if condition1 then statements elsif condition2 then statements «else statements» end if case expression when valuelist1 => statements when valuelist2 => statements «when others => statements» end case if condition1 then expression1 «elsif condition2 then expression2» else expressionn case expression when valuelist1 => expression1 when valuelist2 => expression2 «when others => expressionn» seed7 case expression when set1 statements «otherwise statements» end case modula-2 if condition then statements «else statements» end if condition1 then statements elsif condition2 then statements «else statements» end case expression caselabellist statements | «else statements» end algol & brief form if condition then statements «else statements» fi if condition then statements elif condition then statements fi case switch statements statements« out statements» esac condition | valueiftrue | valueiffalse condition | statements «| statements» condition | statements | condition | statements variable | statements «| statements» c c99 if condition {instructions} «else {instructions}» if condition {instructions} else if condition {instructions} «else {instructions}» switch variable { case case1 instructions «break» «default instructions» } condition valueiftrue valueiffalse objective-c c++ stl d java javascript php c switch variable { case case1 instructions «jump statement» «default instructions «jump statement»» } windows powershell if condition { instructions } elseif condition { instructions } «else { instructions }» switch variable { case1 { instructions «break» } «default { instructions }»} go if condition {instructions} «else {instructions}» if condition {instructions} else if condition {instructions} «else {instructions}» switch { case condition instructions «default instructions» } switch variable { case case1 instructions «default instructions» } swift if condition {instructions} «else {instructions}» if condition {instructions} else if condition {instructions} «else {instructions}» switch variable { case case1 instructions «default instructions» } perl if condition {instructions} «else {instructions}» unless notcondition {instructions} «else {instructions}» if condition {instructions} elsif condition {instructions} «else {instructions}» unless notcondition {instructions} elsif condition {instructions} «else {instructions}» use feature switch given variable { when case1 { instructions } «default { instructions }» } condition valueiftrue valueiffalse perl if condition {instructions} «else {instructions}» unless notcondition {instructions} if condition {instructions} elsif condition {instructions} «else {instructions} given variable { when case1 { instructions } «default { instructions }» } condition valueiftrue valueiffalse ruby if condition instructions «else instructions» if condition instructions elsif condition instructions «else instructions» end case variable when case1 instructions «else instructions» end condition valueiftrue valueiffalse scala if condition {instructions} «else {instructions}» if condition {instructions} else if condition {instructions} «else {instructions}» expression match { case pattern1 => expression case pattern2 => expression «case => expression» } if condition valueiftrue else valueiffalse smalltalk condition iftrue trueblock «iffalse falseblock» end condition iftrue trueblock iffalse falseblock common lisp when condition instructions unless condition instructions if condition progn instructions «progn instructions» cond condition1 instructions condition2 instructions «t instructions» case expression case1 instructions case2 instructions «otherwise instructions» if condition valueiftrue valueiffalse scheme when conditioninstructions if condition begin instructions «begin instructions» cond condition1 instructions condition2 instructions «else instructions » case variable case1 instructions case2 instructions « else instructions» islisp if condition progn instructions «progn instructions» cond condition1 instructions condition2 instructions «t instructions» case expression case1 instructions case2 instructions «t instructions» if condition valueiftrue valueiffalse pascal if condition then begin instructions end «else begin instructions end» if condition then begin instructions end else if condition then begin instructions end «else begin instructions end» case variable case1 instructions «else instructions» end visual basic if condition then instructions «else instructions» end if if condition then instructions elseif condition then instructions «else instructions» end if select case variable case case1 instructions «case else instructions» end select iifcondition valueiftrue valueiffalse visual basic net ifcondition valueiftrue valueiffalse xojo python if condition tab ↹ instructions «else tab ↹ instructions» if condition tab ↹ instructions elif condition tab ↹ instructions «else tab ↹ instructions» valueiftrue if condition else valueiffalse python 25+ s-lang if condition { instructions } «else { instructions }» if condition { instructions } else if condition { instructions } «else { instructions }» switch variable { case case1 instructions } { case case2 instructions } fortran if condition then instructions else instructions endif if condition then instructions elseif condition then instructions else instructions endif select casevariable case case1 instructions case default instructions end select forth condition if instructions « else instructions» then condition if instructions else condition if instructions then then value case case instructions endof case instructions endof default instructions endcase condition if valueiftrue else valueiffalse then ocaml if condition then begin instructions end «else begin instructions end» if condition then begin instructions end else if condition then begin instructions end «else begin instructions end» match value with pattern1 -> expression | pattern2 -> expression «| -> expression» if condition then valueiftrue else valueiffalse f if condition then tab ↹ instructions «else tab ↹ instructions» if condition then tab ↹ instructions elif condition then tab ↹ instructions «else tab ↹ instructions» standard ml if condition then «»instructions «» else «» instructions «» if condition then «»instructions «» else if condition then «» instructions «» else «» instructions «» case value pattern1 => expression | pattern2 => expression «| => expression» haskell ghc if condition then expression else expression when condition do instructions unless notcondition do instructions result | condition = expression | condition = expression | otherwise = expression case value { pattern1 -> expression pattern2 ->expression « -> expression» } bash shell if condition-command then expression «else expression» fi if condition-command then expression elif condition-command then expression «else expression» fi case $variable $condition1 command $condition2 command esac coffeescript if condition then expression «else expression» if condition then expression else if condition then expression «else expression» switch expression when condition then expression else expression all conditions are expressions if condition expression «else expression» if condition expression else if condition expression «else expression» expression if condition unless condition expression else unless condition expression «else expression» switch expression when condition expression «else expression» unless condition expression «else expression» expression unless condition cobol if condition «then» expression «else expression» evaluate expression «also expression» when case-or-condition «also case-or-condition» expression «when other expression» end-evaluate if else if select case conditional expression ^a single instruction can be written on same line following colon multiple instructions are grouped together block which starts on newline indentation required conditional expression syntax does not follow this rule ^b this pattern matching similar select case but not same usually used deconstruct algebraic data types ^c languages pascal family semicolon not part statement separator between statements not terminator ^d end-if may be used instead period at end loop statements while do while for i = first last foreach ada while condition loop statements end loop loop statements exit when not condition end loop for index «reverse» loop statements end loop for item «reverse» iterator loop statements end loop for => predicate algol «for index» «from first» «by increment» «to last» «while condition» do statements od for key «to upb list» do «typename val=list» statements od «while condition» do statements od «while statements condition» do statements od «for index» «from first» «by increment» «to last» do statements od c c99 while condition { instructions } do { instructions } while condition for «type» i = first i item { instructions } windows powershell for $i = first $i -le last $i++ { instructions } foreach item set { instructions using item } d foreach i first last { instructions } foreach «type» item set { instructions } go for condition { instructions } for i = first i $i { instructions } loop $i = first $i $item» { instructions } ruby while condition instructions end until notcondition instructions end begin instructions end while condition begin instructions end until notcondition for i firstlast instructions end for i firstlast+1 instructions end firstuptolast { |i| instructions } for item set instructions end seteach { |item| instructions } bash shell while condition do instructions done until notcondition do instructions done n/a for i = first i { instructions } for item { instructions } smalltalk conditionblock whiletrue loopblock loopblock dowhile conditionblock first last do loopblock collection do loopblock common lisp loop while condition do instructions do notcondition instructions loop do instructions while condition loop for i from first last «by 1» do instructions dotimes i n instructions do i first 1+ i >= i last instructions loop for item list do instructions loop for item across vector do instructions dolist item list instructions mapc function list map 'type function sequence scheme do notcondition instructions let loop if condition begin instructions loop let loop instructions if condition loop do i first + i >= i last instructions let loop i first if = i last instructions mapc lambda item instructions list pascal while condition do begin instructions end repeat instructions until notcondition for i = first «step 1» last do begin instructions end for item set do visual basic do while condition instructions loop do until notcondition instructions loop do instructions loop while condition do instructions loop until notcondition for i = first last «step 1» instructions next i for each item set instructions next item visual basic net for i «as type» = first last «step 1» instructions next i for each item type set instructions next item xojo while condition instructions wend do until notcondition instructions loop do instructions loop until notcondition python while condition tab ↹ instructions «else tab ↹ instructions» n/a for i rangefirst last+1 tab ↹ instructions «else tab ↹ instructions»python 3x for i xrangefirst last+1 tab ↹ instructions «else tab ↹instructions»python 2x for item set tab ↹ instructions «else tab ↹ instructions» s-lang while condition { instructions } «then optional-block» do { instructions } while condition «then optional-block» for i = first i instructions array listiter fun item -> instructions list f while condition do tab ↹ instructions n/a for i = first last do tab ↹ instructions for item set do tab ↹ instructions seqiter fun item -> instructions set standard ml while condition do instructions n/a arrayapp fn item => instructions array app fn item => instructions list haskell ghc n/a controlmonadform \i -> do instructions controlmonadform list \item -> do instructions eiffel from setup until condition loop instructions end coffeescript while condition expression n/a for i expression for item set expression expression while condition while condition then expression until condition expression expression until condition for i then expression for item set then expression until condition then expression expression for i expression for item set cobol perform procedure-1 «through procedure-2» ««with» test before» until condition perform procedure-1 «through procedure-2» «with» test after until condition perform procedure-1 «through procedure-2» varying i from first by increment until i > last n/a perform ««with» test before» until condition expression end-perform perform «with» test after until condition expression end-perform perform varying i from first by increment until i > last expression end-perform ^a step n used change loop interval if step omitted then loop interval ^b this implements universal quantifier for all ∀ well existential quantifier there exists ∃ ^c thru may be used instead through ^d «is» greater «than» may be used instead > exceptions further information exception handling syntax throw handler assertion ada raise exceptionname «with stringexpression» begin statements exception when exceptionlist1 => statements when exceptionlist2 => statements «when others => statements» end pragma assert «check =>» booleanexpression ««message =>» stringexpression» with pre => booleanexpression post => booleanexpression anytype with typeinvariant => booleanexpression c c99 longjmpstate exception switch setjmpstate { case instructions break case exception instructions } assertcondition c++ throw exception try { instructions } catch «exception» { instructions } c try { instructions } catch «exception» { instructions } «finally { instructions }» debugassertcondition java try { instructions } catch exception { instructions } «finally { instructions }» assert condition « description» javascript try { instructions } catch exception { instructions } « finally { instructions }» d try { instructions } catch exception { instructions } «finally { instructions }» assertcondition php try { instructions } catch exception { instructions } «finally { instructions }» assertcondition s-lang try { instructions } catch «exception» { instructions } « finally { instructions }» windows powershell trap «» { instructions } instructions try { instructions } catch «» { instructions } «finally { instructions }» assertcondition objective-c @throw exception @try { instructions } @catch exception { instructions } «@finally { instructions }» nsassertcondition description swift throw exception 2x do { try expression instructions } catch exception { instructions } 2x assertcondition« description» perl die exception eval { instructions } if $@ { instructions } perl try { instructions catch { when exception { instructions } }} ruby raise exception begin instructions rescue exception instructions «else instructions» «ensure instructions» end smalltalk exception raise instructionblock on exception do handlerblock assert conditionblock common lisp error exception error type arguments error make-condition type arguments handler-case progn instructions exception instructions handler-bind condition lambda instructions «invoke-restart restart args» assert condition assert condition «place «error»» check-type var type scheme r6rs raise exception guard con condition instructions instructions islisp error error-string objects signal-condition condition continuable with-handler handler form pascal raise exceptioncreate try except on e exception do begin instructions end end visual basic errraise errornumber with new try on error resume next oneinstruction catch on error goto select case number case errornumber instructions end select end with ' try class private mstrdescription string private mlngnumber long public sub catch mstrdescription = errdescription mlngnumber = errnumber end sub public property get number long number = mlngnumber end property public property get description string description = mstrdescription end property debugassert condition visual basic net throw exception try instructions catch «exception» «when condition» instructions «finally instructions» end try debugassertcondition xojo raise exception try instructions catch «exception» instructions «finally instructions» end try n/a python raise exception try tab ↹ instructions except «exception» tab ↹ instructions «else tab ↹ instructions» «finally tab ↹ instructions» assert condition fortran n/a forth code throw xt catch code n/a ocaml raise exception try expression with pattern -> expression assert condition f try expression with pattern -> expression try expression finally expression standard ml raise exception «arg» expression handle pattern => expression haskell ghc throw exception throwerror expression catch tryexpression catchexpression catcherror tryexpression catchexpression assert condition expression cobol raise «exception» exception use «after» exception object class-name use «after» eo class-name use «after» exception condition exception-name «file file-name» use «after» ec exception-name «file file-name» n/a ^a common lisp allows with-simple-restart restart-case restart-bind define restarts for use with invoke-restart unhandled conditions may cause implementation show restarts menu user before unwinding stack ^b uncaught exceptions are propagated innermost dynamically enclosing execution exceptions are not propagated across tasks unless these tasks are currently synchronised rendezvous other control flow statements exit blockbreak continue label branch goto return value from generator ada exit «loopname» «when condition» n/a label goto label n/a algol value exit do statements skip exit label statements od label go label goto label label yieldvalue callback c c99 break continue label goto label n/a objective-c c++ stl d c yield return value java break «label» continue «label» n/a javascript yield value«» php break «levels» continue «levels» goto label yield «key =>» value perl last «label» next «label» perl go break «label» continue «label» goto label swift break «label» continue «label» n/a bash shell break «levels» continue «levels» n/a n/a n/a common lisp return return-from block loop-finish tagbody tag tag go tag scheme islisp return-from block tagbody tag tag go tag pascaliso n/a label goto label n/a pascalfpc break continue visual basic exit block n/a label goto label visual basic net continue block xojo python break continue n/a yield value rpg iv leave iter s-lang break continue fortran exit cycle label goto label n/a ruby break next windows powershell break «label» continue ocaml n/a f standard ml haskell ghc cobol exit perform exit paragraph exit section exit exit perform cycle label «section» go label n/a ya break «from where» fe break for switch continue «to where» fe continue for switch label goto label n/a ^a pascal has declaration blocks see comparison programming languages basic instructionsfunctions ^b label must be number between functions see reflection for calling declaring functions by strings calling function basic/void function value-returning function required main function ada foo «parameters» procedure foo «parameters» begin statements end foo function foo «parameters» return type begin statements end foo n/a algol foo«parameters» proc foo = «parameters» void instructions proc foo = «parameters» rettype instructions retvalue n/a c c99 foo«parameters» void foo«parameters» { instructions } type foo«parameters» { instructions return value } «global declarations» int main«int argc char argv» { instructions } objective-c c++ stl c static void main«string args» { instructions } static int main«string args» { instructions } java public static void mainstring args { instructions } public static void mainstring args { instructions } d int main«char args» { instructions} int main«string args» { instructions} void main«char args» { instructions} void main«string args» { instructions} javascript function foo«parameters» { instructions } var foo = function «parameters» {instructions } var foo = new function «parameter last parameter» instructions function foo«parameters» { instructions return value } n/a go func foo«parameters» { instructions } func foo«parameters» type { instructions return value } func main { instructions } swift func foo«parameters» { instructions } func foo«parameters» -> type { instructions return value } n/a common lisp foo «parameters» defun foo «parameters» instructions setf symbol-function 'symbol lambda defun foo «parameters» value n/a scheme define foo parameters instructions define foo lambda parameters instructions define foo parameters instructions returnvalue define foo lambda parameters instructions returnvalue islisp defun foo «parameters» instructions defun foo «parameters» value pascal foo«parameters» procedure foo«parameters» «forward» «label label declarations» «const constant declarations» «type type declarations» «var variable declarations» «local function declarations» begin instructions end function foo«parameters» type «forward» «label label declarations» «const constant declarations» «type type declarations» «var variable declarations» «local function declarations» begin instructions foo = value end program name «label label declarations» «const constant declarations» «type type declarations» «var variable declarations» «function declarations» begin instructions end visual basic foo«parameters» sub foo«parameters» instructions end sub function foo«parameters» type instructions foo = value end function sub main instructions end sub visual basic net function foo«parameters» type instructions return value end function sub main«byval cmdargs string» instructions end sub function main«byval cmdargs string» integer instructions end function xojo python foo«parameters» def foo«parameters» tab ↹ instructions def foo«parameters» tab ↹ instructions tab ↹ return value n/a s-lang foo«parameters» «qualifiers» define foo «parameters» { instructions } define foo «parameters» { instructions return value } public define slshmain { instructions } fortran foo «arguments» call subfoo «arguments» subroutine subfoo «arguments» instructions end subroutine type function foo «arguments» instructions foo = value end function program main instructions end program forth «parameters» foo foo « stack effect comment before -- » instructions foo « stack effect comment before -- after » instructions n/a php foo«parameters» function foo«parameters» { instructions } function foo«parameters» { instructions return value } n/a perl foo«parameters» &foo«parameters» sub foo { «my parameters = @» instructions } sub foo { «my parameters = @» instructions «return» value } perl foo«parameters» &foo«parameters» «multi »sub fooparameters { instructions } «our «type» »«multi »sub fooparameters { instructions «return» value } ruby foo«parameters» def foo«parameters» instructions end def foo«parameters» instructions «return» value end scala def foo«parameters»« unit =» { instructions } def foo« parameters»« type» = { instructions «return» value } def mainargs array { instructions } windows powershell foo «parameters» function foo { instructions } function foo { «paramparameters» instructions } function foo « parameters» { instructions … return value } function foo { «paramparameters» instructions … return value } n/a bash shell foo «parameters» function foo { instructions } foo { instructions } function foo { instructions return «exitcode» } foo { instructions return «exitcode» } parameters o $n $1 $2 $3 o $@ all parameters o $ number parameters o $0 this function name ocaml foo parameters let «rec» foo parameters = instructions let «rec» foo parameters = instructions returnvalue f let main args = instructions standard ml fun foo parameters = instructions fun foo parameters = instructions returnvalue haskell foo parameters = do tab ↹ instructions foo parameters = returnvalue foo parameters = do tab ↹ instructions tab ↹ return value «main io » main = do instructions eiffel foo «parameters» foo «parameters» require preconditions do instructions ensure postconditions end foo «parameters» type require preconditions do instructions result = value ensure postconditions end coffeescript foo foo = -> foo = -> value n/a foo parameters foo = -> foo = parameters -> value cobol call foo «using parameters» «exception-handling» «end-call» «identification division» program-id foo «other divisions» procedure division «using parameters» instructions «identification division» program-id/function-id foo «other divisions» data division «other sections» linkage section «parameter definitions» variable-to-return definition «other sections» procedure division «using parameters» returning variable-to-return instructions n/a «function» foo««parameters»» n/a ^a pascal requires forward for forward declarations ^b eiffel allows specification application's root class feature ^c fortran function/subroutine parameters are called arguments since parameter language keyword call keyword required for subroutines ^d instead using foo string variable may be used instead containing same value type conversions where string signed decimal number string integer string long integer string floating point integer string floating point string ada integer'value stringexpression longinteger'value stringexpression float'value stringexpression integer'image integerexpression float'image floatexpression algol with general then specific formats with prior declarations association string buf = file proxy associateproxy buf getproxy ivar getproxy livar getproxy rvar putproxy ival putproxy rval getfproxy $g$ ivar orv getfproxy $dddd$ ivar getfproxy $g$ livar getfproxy $8d$ livar getfproxy $g$ rvar getfproxy $8d4de2d$ rvar putfproxy $g$ ival putfproxy $4d$ ival putfproxy $gwidth places exp$ rval putfproxy $8d4de2d$ rval etc c c99 integer = atoistring long = atolstring float = atof string sprintfstring %i integer sprintfstring %f float objective-c integer = long = float = string = string = c++ stl «std»istringstreamstring >> number «std»ostringstream o o number string define string number->string number islisp setf integer convert string setf float convert string setf string convert number pascal integer = strtointstring float = strtofloatstring string = inttostrinteger string = floattostrfloat visual basic integer = cintstring long = clngstring float = csng string double = cdblstring string = cstrnumber visual basic net xojo integer = valstring long = valstring double = valstring double = cdblstring string = cstrnumber string = strnumber python integer = intstring long = longstring float = floatstring string = strnumber s-lang integer = atoistring long = atolstring float = atofstring string = stringnumber fortran readstringformat number writestringformat number php integer = intvalstring integer = intstring float = floatvalstring float = floatstring string = number string = strvalnumber string = stringnumber perl number = + string string = number perl number = +string string = ~number ruby integer = stringtoi integer = integerstring float = stringtof float = floatstring string = numbertos scala integer = stringtoint long = stringtolong float = string tofloat double = stringtodouble string = numbertostring smalltalk integer = integer readfrom string float = float readfrom string string = number asstring windows powershell integer = string long = string float = string string = number string = number string = numbertostring ocaml let integer = intofstring string let float = floatofstring string let string = stringofint integer let string = stringoffloat float f let integer = int string let integer = int64 string let float = float string let string = string number standard ml val integer = intfromstring string val float = real fromstring string val string = inttostring integer val string = real tostring float haskell ghc number = read string string = show number cobol move «function» numvalstring number move number numeric-edited ^a javascript only uses floating point numbers so there are some technicalities ^b perl doesn't have separate types strings numbers are interchangeable ^c numval-c numval-f may be used instead numval standard stream i/o read from write stdin stdout stderr ada get x put x put standarderror x algol readf$format$ x getfstand $format$ x printf$format$ x putfstand out $format$ x putfstand error $format$ x c c99 scanfformat &x fscanfstdin format &x printf format x fprintfstdout format x fprintfstderr format x objective-c data = readdatatoendoffile] writedatadata] writedata data] c++ «std»cin >> x «std»getline«std»cin str «std»cout > sysstderr x sysstderrwritex python 3x x = input«prompt» printx« end=» printx« end=» file=sysstderr s-lang fgets &x stdin fputs x stdout fputs x stderr fortran readformat variable names readinputunitformat variable names writeformat expressions writeoutputunitformat expressions writeerrorunitformat expressions forth buffer length accept chars read key char buffer length type char emit n/a php $x = fgetsstdin $x = fscanfstdin format print x echo x printfformat x fprintfstderr format x perl $x = $x = print x printf format x print stderr x printf stderr format x perl $x = $inget xprint xsay xnote $errprintx $errsayx ruby x = gets puts x printfformat x $stderrputsx $stderrprintfformat x windows powershell $x = read-host«« -prompt» text» $x = read $x = readline x write-output x echo x write-error x ocaml let x = readint let str = readline scanfscanf format fun x -> printint x printendline str printfprintf format x prerrint x prerrendline str printfeprintf format x f let x = systemconsolereadline printf format x printfn format x eprintf format x eprintfn format x standard ml val str = textioinputline textiostdin print str textiooutput textiostderr str haskell ghc x b b number type b example retrieved from https//enwikipediaorg/w/indexphptitle=comparisonofprogramminglanguagesbasicinstructions&oldid=751630200 categories programming constructs programming language comparisons hidden categories articles needing additional references from february all articles needing additional references all articles with unsourced statements articles with unsourced statements from december navigation menu personal tools not logged talk contributions create account log namespaces article talk variants views read edit view history more search navigation main page contents featured content current events random article donate wikipedia wikipedia store interaction help about wikipedia community portal recent changes contact page tools what links here related changes upload file special pages permanent link page information wikidata item cite this page print/export create book download pdf printable version languages српски / srpski edit links this page was last modified on november at text available under creative commons attribution-sharealike license additional terms may apply by using this site you agree terms use privacy policy wikipedia® registered trademark wikimedia foundation inc non-profit organization privacy policy about wikipedia disclaimers contact wikipedia developers cookie statement mobile view 