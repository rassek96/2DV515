lisp programming language from wikipedia free encyclopedia jump navigation search lisp redirects here for internet protocol see locator/identifier separation protocol lisp paradigm multi-paradigm functional procedural reflective meta designed by john mccarthy developer steve russell timothy p hart mike levin first appeared years ago typing discipline dynamic strong dialects arc autolisp clojure common lisp emacs lisp eulisp franz lisp hy interlisp islisp lelisp lfe maclisp mdl newlisp nil picolisp portable standard lisp racket rpl scheme skill spice lisp t tcl zetalisp influenced by ipl influenced clips clu cowsel dylan elixir falcon forth haskell io ioke javascript julia logo lua mathematica ml nim nu ops5 perl pop-2/ python r rebol ruby scala smalltalk tcl lisp historically lisp family computer programming languages with long history distinctive fully parenthesized prefix notation originally specified lisp second-oldest high-level programming language widespread use today only fortran older by one year lisp has changed since its early days many dialects have existed over its history today best known general-purpose lisp dialects are common lisp scheme lisp was originally created practical mathematical notation for computer programs influenced by notation alonzo church's lambda calculus quickly became favored programming language for artificial intelligence ai research one earliest programming languages lisp pioneered many ideas computer science including tree data structures automatic storage management dynamic typing conditionals higher-order functions recursion self-hosting compiler name lisp derives from list processor linked lists are one lisp's major data structures lisp source code made lists thus lisp programs can manipulate source code data structure giving rise macro systems that allow programmers create new syntax new domain-specific languages embedded lisp interchangeability code data gives lisp its instantly recognizable syntax all program code written s-expressions parenthesized lists function call syntactic form written list with function operator's name first arguments following for instance function f that takes three arguments would be called f arg1 arg2 arg3 contents history o timeline o connection artificial intelligence o genealogy variants + historically significant dialects o 2000-present major dialects language innovations syntax semantics o symbolic expressions s-expressions o lists o operators o lambda expressions function definition o atoms o conses lists + s-expressions represent lists + list-processing procedures + shared structure o self-evaluating forms quoting o scope closure o list structure program code exploitation by macros compilers o evaluation read–eval–print loop o control structures examples object systems popular usage references further reading external links history john mccarthy top steve russell bottom lisp was invented by john mccarthy while he was at massachusetts institute technology mit mccarthy published its design paper communications acm entitled recursive functions symbolic expressions their computation by machine part i he showed that with few simple operators notation for functions one can build turing-complete language for algorithms information processing language was first ai language from already included many concepts such list-processing recursion which came be used lisp mccarthy's original notation used bracketed m-expressions that would be translated into s-expressions example m-expression car] equivalent s-expression car cons b once lisp was implemented programmers rapidly chose use s-expressions m-expressions were abandoned m-expressions surfaced again with short-lived attempts mlisp by horace enea cgol by vaughan pratt lisp was first implemented by steve russell on ibm computer russell had read mccarthy's paper realized mccarthy's surprise that lisp eval function could be implemented machine code result was working lisp interpreter which could be used run lisp programs more properly 'evaluate lisp expressions' two assembly language macros for ibm became primitive operations for decomposing lists car contents address part register number cdr contents decrement part register number from context clear that term register used here mean memory register nowadays called memory location lisp dialects still use car cdr /ˈkɑːr/ /ˈkʊdər/ for operations that return first item list rest list respectively first complete lisp compiler written lisp was implemented by tim hart mike levin at mit this compiler introduced lisp model incremental compilation which compiled interpreted functions can intermix freely language used hart levin's memo much closer modern lisp style than mccarthy's earlier code lisp was difficult system implement with compiler techniques stock hardware 1970s garbage collection routines developed by then-mit graduate student daniel edwards made practical run lisp on general-purpose computing systems but efficiency was still problem this led creation lisp machines dedicated hardware for running lisp environments programs advances both computer hardware compiler technology soon made lisp machines obsolete during 1980s 1990s great effort was made unify work on new lisp dialects mostly successors maclisp like zetalisp nil new implementation lisp into single language new language common lisp was somewhat compatible with dialects replaced book common lisp language notes compatibility various constructs ansi published common lisp standard ansi x3226-1994 information technology programming language common lisp timeline timeline lisp dialectsedit lisp lisp maclisp maclisp interlisp interlisp zetalisp lisp machine lisp scheme scheme nil nil common lisp common lisp t t emacs lisp emacs lisp autolisp autolisp islisp islisp eulisp eulisp picolisp picolisp racket racket arc arc clojure clojure lfe lfe hy hy connection artificial intelligence since its inception lisp was closely connected with artificial intelligence research community especially on pdp-10 systems lisp was used implementation programming language micro planner which was used famous ai system shrdlu 1970s ai research spawned commercial offshoots performance existing lisp systems became growing issue genealogy variants over its fifty-year history lisp has spawned many variations on core theme s-expression language moreover each given dialect may have several implementations—for instance there are more than dozen implementations common lisp differences between dialects may be quite visible—for instance common lisp uses keyword defun name function but scheme uses define within dialect that standardized however conforming implementations support same core language but with different extensions libraries historically significant dialects lisp machine mit museum bsd from university wisconsin displaying man page for franz lisp lisp – first implementation lisp – first widely distributed version developed by mccarthy others at mit so named because contained several improvements on original lisp interpreter but was not major restructuring planned lisp would be stanford lisp – this was successor lisp developed at stanford ai lab widely distributed pdp-10 systems running tops-10 operating system was rendered obsolete by maclisp interlisp maclisp – developed for mit's project mac no relation apple's macintosh nor mccarthy direct descendant lisp ran on pdp-10 multics systems maclisp would later come be called maclisp often referred maclisp interlisp – developed at bbn technologies for pdp-10 systems running tenex operating system later adopted west coast lisp for xerox lisp machines interlisp-d small version called interlisp was published for 6502-based atari 8-bit family computer line for quite some time maclisp interlisp were strong competitors franz lisp – originally university california berkeley project later developed by franz inc name humorous deformation name franz liszt does not refer allegro common lisp dialect common lisp sold by franz inc more recent years xlisp which autolisp was based on standard lisp portable standard lisp were widely used ported especially with computer algebra system reduce zetalisp also termed lisp machine lisp – used on lisp machines direct descendant maclisp zetalisp had big influence on common lisp lelisp french lisp dialect one first interface builders was written lelisp scheme common lisp described by common lisp language – consolidation several divergent attempts zetalisp spice lisp nil s-1 lisp create successor dialects maclisp with substantive influences from scheme dialect well this version common lisp was available for wide-ranging platforms was accepted by many de facto standard until publication ansi common lisp ansi x3226-1994 dylan was its first version mix scheme with common lisp object system eulisp – attempt develop new efficient cleaned-up lisp islisp – attempt develop new efficient cleaned-up lisp standardized iso/iec later revised iso/iec information technology – programming languages their environments system software interfaces – programming language islisp ieee scheme – ieee standard 1178–1990 r1995 ansi common lisp – american national standards institute ansi standard for common lisp created by subcommittee x3j13 chartered begin with common lisp language base document work through public consensus process find solutions shared issues portability programs compatibility common lisp implementations although formally ansi standard implementation sale use influence ansi common lisp has been continues be seen worldwide acl2 computational logic for applicative common lisp applicative side-effect free variant common lisp acl2 both programming language which can model computer systems tool help proving properties those models clojure recent dialect lisp which compiles java virtual machine handles concurrency very well 2000-present after having declined somewhat 1990s lisp has recently experienced resurgence interest most new activity focused around implementations common lisp clojure racket scheme emacs lisp includes development new portable libraries applications many new lisp programmers were inspired by writers such paul graham eric s raymond pursue language others considered antiquated new lisp programmers often describe language eye-opening experience claim be substantially more productive than other languages this increase awareness may be contrasted ai winter lisp's brief gain mid-1990s dan weinreb lists his survey common lisp implementations eleven actively maintained common lisp implementations scieneer common lisp new commercial implementation forked from cmucl with first release open source community has created new supporting infrastructure cliki wiki that collects common lisp related information common lisp directory lists resources lisp popular irc channel allows sharing commenting code snippets with support by lisppaste irc bot written lisp planet lisp collects contents various lisp-related blogs on lispforum users discuss lisp topics lispjobs service for announcing job offers there weekly news service weekly lisp news common-lispnet hosting site for open source common lisp projects quicklisp library manager for common lisp years lisp 1958–2008 has been celebrated at lisp50@oopsla there are regular local user meetings boston vancouver hamburg other events include european common lisp meeting european lisp symposium international lisp conference scheme community actively maintains over twenty implementations several significant new implementations chicken gambit gauche ikarus larceny ypsilon have been developed last few years revised5 report on algorithmic language scheme standard scheme was widely accepted scheme community scheme requests for implementation process has created lot quasi standard libraries extensions for scheme user communities individual scheme implementations continue grow new language standardization process was started led r6rs scheme standard academic use scheme for teaching computer science seems have declined somewhat some universities such mit are no longer using scheme their computer science introductory courses there are several new dialects lisp arc hy nu clojure liskell lfe lisp flavored erlang racket major dialects common lisp scheme represent two major streams lisp development these languages embody significantly different design choices common lisp successor maclisp primary influences were lisp machine lisp maclisp nil s-1 lisp spice lisp scheme has many features lisp machine lisp large lisp dialect used program lisp machines but was designed be efficiently implementable on any personal computer workstation common lisp has large language standard including many built-in data types functions macros other language elements well object system common lisp object system common lisp also borrowed certain features from scheme such lexical scoping lexical closures scheme designed earlier more minimalist design with much smaller set standard features but with certain implementation features such tail-call optimization full continuations not necessarily found common lisp scheme statically scoped properly tail-recursive dialect lisp programming language invented by guy l steele jr gerald jay sussman was designed have exceptionally clear simple semantics few different ways form expressions wide variety programming paradigms including imperative functional message passing styles find convenient expression scheme scheme continues evolve with series standards revisedn report on algorithmic language scheme series scheme requests for implementation clojure recent dialect lisp that principally targets java virtual machine well common language runtime clr python vm ruby vm yarv compiling javascript designed be pragmatic general-purpose language clojure draws considerable influences from haskell places very strong emphasis on immutability clojure provides access java frameworks libraries with optional type hints type inference so that calls java can avoid reflection enable fast primitive operations further lisp dialects are used scripting languages many applications with best-known being emacs lisp emacs editor autolisp later visual lisp autocad nyquist audacity scheme lilypond potential small size useful scheme interpreter makes particularly popular for embedded scripting examples include siod tinyscheme both which have been successfully embedded gimp image processor under generic name script-fu librep lisp interpreter by john harper originally based on emacs lisp language has been embedded sawfish window manager language innovations lisp was first language where structure program code represented faithfully directly standard data structure—a quality much later dubbed homoiconicity thus lisp functions can be manipulated altered even created within lisp program without lower-level manipulations this generally considered one main advantages language with regard its expressive power makes language suitable for syntactic macros metacircular evaluation conditional using if-then-else syntax was invented by mccarthy fortran context he proposed its inclusion algol but was not made part algol specification for lisp mccarthy used more general cond-structure algol took up if-then-else popularized lisp deeply influenced alan kay leader research on smalltalk then turn lisp was influenced by smalltalk by adopting object-oriented programming features classes instances etc late 1970s flavors object system introduced multiple inheritance lisp introduced concept automatic garbage collection which system walks heap looking for unused memory progress modern sophisticated garbage collection algorithms such generational garbage collection was stimulated by its use lisp edsger w dijkstra his turing award lecture said with few very basic principles at its foundation has shown remarkable stability besides that lisp has been carrier for considerable number sense our most sophisticated computer applications lisp has jokingly been described “the most intelligent way misuse computer” i think that description great compliment because transmits full flavour liberation has assisted number our most gifted fellow humans thinking previously impossible thoughts largely because its resource requirements with respect early computing hardware including early microprocessors lisp did not become popular outside ai community fortran algol-descended c language because its suitability complex dynamic applications lisp currently enjoying some resurgence popular interest syntax semantics note this article's examples are written common lisp though most are also valid scheme symbolic expressions s-expressions lisp expression-oriented language unlike most other languages no distinction made between expressions statements all code data are written expressions when expression evaluated produces value common lisp possibly multiple values which can then be embedded into other expressions each value can be any data type mccarthy's paper introduced two types syntax symbolic expressions s-expressions sexps which mirror internal representation code data meta expressions m-expressions which express functions s-expressions m-expressions never found favor almost all lisps today use s-expressions manipulate both code data use parentheses lisp's most immediately obvious difference from other programming language families result students have long given lisp nicknames such lost stupid parentheses lots irritating superfluous parentheses however s-expression syntax also responsible for much lisp's power syntax extremely regular which facilitates manipulation by computer however syntax lisp not limited traditional parentheses notation can be extended include alternative notations for example xmlisp common lisp extension that employs metaobject protocol integrate s-expressions with extensible markup language xml reliance on expressions gives language great flexibility because lisp functions are written lists they can be processed exactly like data this allows easy writing programs which manipulate other programs metaprogramming many lisp dialects exploit this feature using macro systems which enables extension language almost without limit lists lisp list written with its elements separated by whitespace surrounded by parentheses for example foo list which elements are three atoms foo these values are implicitly typed they are respectively two integers lisp-specific data type called symbol do not have be declared such empty list also represented special atom nil this only entity lisp which both atom list expressions are written lists using prefix notation first element list name function name macro lambda expression name special operator see below remainder list are arguments for example function list returns its arguments list so expression list quote foo evaluates list foo quote before foo preceding example special operator which returns its argument without evaluating any unquoted expressions are recursively evaluated before enclosing expression evaluated for example list list evaluates list note that third argument list lists can be nested operators arithmetic operators are treated similarly expression + evaluates equivalent under infix notation would be + + + lisp has no notion operators implemented algol-derived languages arithmetic operators lisp are variadic functions n-ary able take any number arguments c-style '++' increment operator sometimes implemented under name incf giving syntax incf x equivalent setq x + x returning new value x special operators sometimes called special forms provide lisp's control structure for example special operator if takes three arguments if first argument non-nil evaluates second argument otherwise evaluates third argument thus expression if nil list foo list bar evaluates bar course this would be more useful if non-trivial expression had been substituted place nil lisp also provides logical operators not operator do short circuit evaluation will return their first non-nil argument zero nil never james 'task 'time will evaluate james lambda expressions function definition another special operator lambda used bind variables values which are then evaluated within expression this operator also used create functions arguments lambda are list arguments expression expressions which function evaluates returned value value last expression that evaluated expression lambda arg + arg evaluates function that when applied takes one argument binds arg returns number one greater than that argument lambda expressions are treated no differently from named functions they are invoked same way therefore expression lambda arg + arg evaluates named functions are created by storing lambda expression symbol using defun macro defun foo b c d + b c d defun f b defines new function named f global environment conceptually similar expression setf fdefinition 'f 'lambda block f b atoms original lisp there were two fundamental data types atoms lists list was finite ordered sequence elements where each element either atom list atom was number symbol symbol was essentially unique named item written alphanumeric string source code used either variable name data item symbolic processing for example list foo bar contains three elements symbol foo list bar number essential difference between atoms lists was that atoms were immutable unique two atoms that appeared different places source code but were written exactly same way represented same object whereas each list was separate object that could be altered independently other lists could be distinguished from other lists by comparison operators more data types were introduced later lisp dialects programming styles evolved concept atom lost importance many dialects still retained predicate atom for legacy compatibility defining true for any object which not cons conses lists main article cons box-and-pointer diagram for list lisp list singly linked each cell this list called cons scheme pair composed two pointers called car cdr these are respectively equivalent data next fields discussed article linked list many data structures that can be built out cons cells one most basic called proper list proper list either special nil empty list symbol cons which car points datum which may be another cons structure such list cdr points another proper list if given cons taken be head linked list then its car points first element list its cdr points rest list for this reason car cdr functions are also called first rest when referring conses which are part linked list rather than say tree thus lisp list not atomic object instance container class c++ java would be list nothing more than aggregate linked conses variable which refers given list simply pointer first cons list traversal list can be done by cdring down list that taking successive cdrs visit each cons list by using any several higher-order functions map function over list because conses lists are so universal lisp systems common misconception that they are lisp's only data structures fact all but most simplistic lisps have other data structures such vectors arrays hash tables structures so forth s-expressions represent lists parenthesized s-expressions represent linked list structures there are several ways represent same list s-expression cons can be written dotted-pair notation b where car b cdr longer proper list might be written b c d nil dotted-pair notation this conventionally abbreviated b c d list notation improper list may be written combination two – b c d for list three conses whose last cdr d ie list b c d fully specified form list-processing procedures lisp provides many built-in procedures for accessing controlling lists lists can be created directly with list procedure which takes any number arguments returns list these arguments list 'a output list '2 output because way that lists are constructed from cons pairs cons procedure can be used add element front list note that cons procedure asymmetric how handles list arguments because how lists are constructed cons '2 output cons '1 '3 output append procedure appends two more lists one another because lisp lists are linked lists appending two lists has asymptotic time complexity o n {\displaystyle on} append '1 '3 output append '1 ' 'a '5 output shared structure lisp lists being simple linked lists can share structure with one another that say two lists can have same tail final sequence conses for instance after execution following common lisp code setf foo list 'a 'b 'c setf bar cons 'x cdr foo lists foo bar are b c x b c respectively however tail b c same structure both lists not copy cons cells pointing b c are same memory locations for both lists sharing structure rather than copying can give dramatic performance improvement however this technique can interact undesired ways with functions that alter lists passed them arguments altering one list such by replacing c with goose will affect other setf third foo 'goose this changes foo b goose but thereby also changes bar x b goose – possibly unexpected result this can be source bugs functions which alter their arguments are documented destructive for this very reason aficionados functional programming avoid destructive functions scheme dialect which favors functional style names destructive functions are marked with cautionary exclamation point bang—such set-car read set car bang which replaces car cons common lisp dialect destructive functions are commonplace equivalent set-car named rplaca for replace car this function rarely seen however common lisp includes special facility setf make easier define use destructive functions frequent style common lisp write code functionally without destructive calls when prototyping then add destructive calls optimization where safe do so self-evaluating forms quoting lisp evaluates expressions which are entered by user symbols lists evaluate some other usually simpler expression – for instance symbol evaluates value variable names + evaluates however most other forms evaluate themselves if entering into lisp returns any expression can also be marked prevent from being evaluated necessary for symbols lists this role quote special operator its abbreviation ' one quotation mark for instance usually if entering symbol foo returns value corresponding variable error if there no such variable refer literal symbol enter quote foo usually 'foo both common lisp scheme also support backquote operator termed quasiquote scheme entered with ` character grave accent this almost same plain quote except allows expressions be evaluated their values interpolated into quoted list with comma unquote comma-at @ splice operators if variable snue has value bar baz then `foo snue evaluates foo bar baz while ` foo @snue evaluates foo bar baz backquote most often used defining macro expansions self-evaluating forms quoted forms are lisp's equivalent literals may be possible modify values mutable literals program code for instance if function returns quoted form code that calls function modifies form this may alter behavior function on subsequent iterations defun should-be-constant 'one two three let stuff should-be-constant setf third stuff 'bizarre bad should-be-constant returns one two bizarre modifying quoted form like this generally considered bad style defined by ansi common lisp erroneous resulting undefined behavior compiled files because file-compiler can coalesce similar constants put them write-protected memory etc lisp's formalization quotation has been noted by douglas hofstadter gödel escher bach others example philosophical idea self-reference scope closure lisp family splits over use dynamic static aka lexical scope clojure common lisp scheme make use static scoping by default while newlisp picolisp embedded languages emacs autocad use dynamic scoping actually emacs uses both dynamic lexical scoping since version list structure program code exploitation by macros compilers fundamental distinction between lisp other languages that lisp textual representation program simply human-readable description same internal data structures linked lists symbols number characters etc would be used by underlying lisp system lisp uses this implement very powerful macro system like other macro languages such c macro returns code that can then be compiled however unlike c macros macros are lisp functions so can exploit full power lisp further because lisp code has same structure lists macros can be built with any list-processing functions language short anything that lisp can do data structure lisp macros can do code contrast most other languages parser's output purely internal language implementation cannot be manipulated by programmer this feature makes easy develop efficient languages within languages for example common lisp object system can be implemented cleanly language extension using macros this means that if application needs different inheritance mechanism can use different object system this stark contrast most other languages for example java does not support multiple inheritance there no reasonable way add simplistic lisp implementations this list structure directly interpreted run program function literally piece list structure which traversed by interpreter executing however most substantial lisp systems also include compiler compiler translates list structure into machine code bytecode for execution this code can run fast code compiled conventional languages such c macros expand before compilation step thus offer some interesting options if program needs precomputed table then macro might create table at compile time so compiler need only output table need not call code create table at run time some lisp implementations even have mechanism eval-when that allows code be present during compile time when macro would need but not present emitted module evaluation read–eval–print loop lisp languages are often used with interactive command line which may be combined with integrated development environment ide user types expressions at command line directs ide transmit them lisp system lisp reads entered expressions evaluates them prints result for this reason lisp command line called read–eval–print loop repl basic operation repl follows this simplistic description which omits many elements real lisp such quoting macros read function accepts textual s-expressions input parses them into internal data structure for instance if you type text + at prompt read translates this into linked list with three elements symbol + number number so happens that this list also valid piece lisp code that can be evaluated this because car list names function—the addition operation note that foo will be read single symbol will be read number one hundred twenty-three will be read string eval function evaluates data returning zero more other lisp data result evaluation does not have mean interpretation some lisp systems compile every expression native machine code simple however describe evaluation interpretation evaluate list whose car names function eval first evaluates each arguments given its cdr then applies function arguments this case function addition applying argument list yields answer this result evaluation symbol foo evaluates value symbol foo data like string evaluates same string list quote evaluates list job print function represent output user for simple result such this trivial expression which evaluated piece list structure would require that print traverse list print out s-expression implement lisp repl necessary only implement these three functions infinite-loop function naturally implementation eval will be complex since must also implement all special operators like if lambda this done basic repl one line code loop print eval read lisp repl typically also provides input editing input history error handling interface debugger lisp usually evaluated eagerly common lisp arguments are evaluated applicative order 'leftmost innermost' while scheme order arguments undefined leaving room for optimization by compiler control structures lisp originally had very few control structures but many more were added during language's evolution lisp's original conditional operator cond precursor later if-then-else structures programmers scheme dialect often express loops using tail recursion scheme's commonality academic computer science has led some students believe that tail recursion only most common way write iterations lisp but this incorrect all oft-seen lisp dialects have imperative-style iteration constructs from scheme's do loop common lisp's complex loop expressions moreover key issue that makes this objective rather than subjective matter that scheme makes specific requirements for handling tail calls thus reason that use tail recursion generally encouraged for scheme that practice expressly supported by language definition by contrast ansi common lisp does not require optimization commonly termed tail call elimination thus fact that tail recursive style casual replacement for use more traditional iteration constructs such do dolist loop discouraged common lisp not just matter stylistic preference but potentially one efficiency since apparent tail call common lisp may not compile simple jump program correctness since tail recursion may increase stack use common lisp risking stack overflow some lisp control structures are special operators equivalent other languages' syntactic keywords expressions using these operators have same surface appearance function calls but differ that arguments are not necessarily evaluated—or case iteration expression may be evaluated more than once contrast most other major programming languages lisp allows implementing control structures using language several control structures are implemented lisp macros can even be macro-expanded by programmer who wants know how they work both common lisp scheme have operators for non-local control flow differences these operators are some deepest differences between two dialects scheme supports re-entrant continuations using call/cc procedure which allows program save later restore particular place execution common lisp does not support re-entrant continuations but does support several ways handling escape continuations often same algorithm can be expressed lisp either imperative functional style noted above scheme tends favor functional style using tail recursion continuations express control flow however imperative style still quite possible style preferred by many common lisp programmers may seem more familiar programmers used structured languages such c while that preferred by schemers more closely resembles pure-functional languages such haskell because lisp's early heritage list processing has wide array higher-order functions relating iteration over sequences many cases where explicit loop would be needed other languages like for loop c lisp same task can be accomplished with higher-order function same true many functional programming languages good example function which scheme called map common lisp called mapcar given function one more lists mapcar applies function successively lists' elements order collecting results new list mapcar '+ '1 '10 this applies + function each corresponding pair list elements yielding result examples here are examples common lisp code basic hello world program print hello world lisp syntax lends itself naturally recursion mathematical problems such enumeration recursively defined sets are simple express this notation evaluate number's factorial defun factorial n if = n n factorial - n alternative implementation takes less stack space than previous version if underlying lisp system optimizes tail recursion defun factorial n &optional acc if = n acc factorial - n acc n contrast with iterative version which uses common lisp's loop macro defun factorial n loop for i from n for fac = then fac i finally return fac following function reverses list lisp's built-in reverse function does same thing defun -reverse list let return-value ' dolist e list push e return-value return-value object systems various object systems models have been built on top alongside into lisp including common lisp object system clos integral part ansi common lisp clos descended from new flavors commonloops ansi common lisp was first standardized object-oriented programming language ansi x3j13 objectlisp object lisp used by lisp machines incorporated early versions macintosh common lisp loops lisp object-oriented programming system later commonloops flavors built at mit its descendant new flavors developed by symbolics kr short for knowledge representation constraints-based object system developed aid writing garnet gui library for common lisp kee used object system called units integrated with inference engine truth maintenance system atms popular usage due problems keeping track so many brackets some say that lisp acronym for lots irritating single parentheses references edwin d reilly milestones computer science information technology greenwood publishing group pp 156–157 isbn 978-1-57356-521-9 sicp foreword lisp survivor having been use for about quarter century among active programming languages only fortran has had longer life conclusions paul graham revenge nerds retrieved jones robin maynard clive stewart ian december art lisp programming springer science & business media p isbn john mccarthy recursive functions symbolic expressions their computation by machine part i retrieved david canfield smith mlisp users manual pdf retrieved according what reported by paul graham hackers & painters p mccarthy said steve russell said look why don't i program this eval i said him ho ho you're confusing theory with practice this eval intended for reading not for computing but he went ahead did that he compiled eval my paper into ibm machine code fixing bug then advertised this lisp interpreter which certainly was so at that point lisp had essentially form that has today john mccarthy lisp prehistory - summer through summer retrieved tim hart mike levin ai memo 39-the new compiler pdf retrieved 36-bit word size pdp-6/pdp-10 was influenced by usefulness having two lisp 18-bit pointers single word peter j hurley october history tops life fast acs newsgroup altfolklorecomputers usenet 84950@tutcisohio-stateedu pdp-6 project started early 24-bit machine grew bits for lisp design goal common lisp defun f x x scheme define f lambda x x define f x x mccarthy j brayton r edwards d fox p hodes l luckham d maling k park d russell s march lisp i programmers manual pdf boston massachusetts artificial intelligence group mit computation center research laboratory accessed may mccarthy john abrahams paul w edwards daniel j hart timothy p levin michael i lisp programmer's manual pdf 2nd ed mit press isbn 0-262-13011-4 quam lynn h diffle whitfield stanford lisp manual pdf maclisp reference manual march archived from original on teitelman warren interlisp reference manual pdf steele guy l jr purpose common lisp language 2nd ed isbn 0-13-152414-3 kantrowitz mark margolin barry february history where did lisp come from faq lisp frequently asked questions 2/7 iso/iec isoorg retrieved iso/iec isoorg retrieved x3j13 charter road lisp survey retrieved trends for future faqsorg retrieved weinreb daniel common lisp implementations survey retrieved april lisp50@oopsla lisp50org retrieved documents standards r5rs schemersorg retrieved on why mit now uses python instead scheme for its undergraduate cs program cemerickcom march retrieved november broder evan january end era mitadmissionsorg retrieved november chapter history ansi cl standard in-depth look at clojure collections retrieved script-fu gimp retrieved librep at sawfish wikia retrieved lisp prehistory - summer through summer i invented conditional expressions connection with set chess legal move routines i wrote fortran for ibm at mit during 1957-58a paper defining conditional expressions proposing their use algol was sent communications acm but was arbitrarily demoted letter editor because was very short lieberman henry hewitt carl june real-time garbage collector based on lifetimes objects cacm 419–429 doi101145/358141358147 edsger w dijkstra humble programmer ewd acm turing award lecture jargon file - lisp retrieved nb so-called dotted list only one kind improper list other kind circular list where cons cells form loop typically this represented using n= represent target cons cell that will have multiple references n used refer this cons for instance 1=a b would normally be printed b b without circular structure printing enabled but makes reuse cons cell clear 1=a cannot normally be printed circular cdr cons cell defined by 1= itself cse scheme quote quasiquote metaprogramming cswashingtonedu retrieved quasiquotation lisp alan bawden time evaluation - common lisp extensions gnuorg retrieved on semantic constraints common lisp hyperspec control abstraction recursion vs iteration tutorial on good lisp programming style by kent pitman peter norvig august pg bobrow veitch p https//booksgooglecouk/booksid=5vcyl8utqsic&pg=pa361&lpg=pa361&dq=lisp+%22lots+of+irritating+single+parentheses%22&source=bl&ots=hks0g0pty7&sig=3gk4begsy403bd8cufc8rcwyh6o&hl=en&sa=x&ved=0ahukewiyqppokdoahxel8akhfqybqqq6aeipjahv=onepage&q=lisp%20%22lots%20of%20irritating%20single%20parentheses%22&f=false further reading mccarthy john implementation lisp history lisp stanford university retrieved steele jr guy l richard p gabriel evolution lisp pdf second acm sigplan conference on history programming languages new york ny acm pp 231–270 isbn 0-89791-570-4 retrieved veitch jim history description clos salus peter h handbook programming languages volume iv functional logic programming languages first ed indianapolis macmillan technical publishing pp 107–158 isbn 1-57870-011-6 abelson harold sussman gerald jay sussman julie structure interpretation computer programs 2nd ed mit press isbn 0-262-01153-0 my lisp experiences development gnu emacs transcript richard stallman's speech october at international lisp conference graham paul hackers & painters big ideas from computer age o'reilly isbn 0-596-00662-4 berkeley edmund c bobrow daniel g eds march programming language lisp its operation applications pdf cambridge massachusetts mit press weissman clark lisp primer pdf belmont california dickenson publishing company inc external links find more aboutlisp programming languageat wikipedia's sister projects definitions from wiktionary media from commons quotations from wikiquote texts from wikisource textbooks from wikibooks learning resources from wikiversity history history lisp – john mccarthy's history february lisp history – herbert stoyan's history compiled from documents acknowledged by mccarthy more complete than his own see mccarthy's history links history lisp at computer history museum associations meetings association lisp users european common lisp meeting european lisp symposium international lisp conference books tutorials casting spels lisp comic-book style introductory tutorial on lisp free book by paul graham practical common lisp freeware edition by peter seibel lisp for web land lisp let over lambda interviews oral history interview with john mccarthy at charles babbage institute university minnesota minneapolis mccarthy discusses his role development time-sharing at massachusetts institute technology he also describes his work artificial intelligence ai funded by advanced research projects agency including logic-based ai lisp robotics interview with richard p gabriel podcast resources cliki common lisp wiki common lisp directory lisp faq index lisppaste planet lisp weekly lisp news lisp at dmoz v t e john mccarthy artificial intelligence circumscription dartmouth conferences frame problem garbage collection lisp mccarthy function situation calculus space fountain v t e programming languages comparison timeline history assembly basic c c++ c cobol fortran go haskell java javascript js lisp lua objective-c pascal perl php python ruby shell smalltalk swift visual basic net vbnet more category comparison lists o alphabetical o categorical o generational o non-english-based retrieved from https//enwikipediaorg/w/indexphptitle=lispprogramminglanguage&oldid=750521329 categories computer science academic programming languages american inventions articles with example lisp code dynamically typed programming languages extensible syntax programming languages functional languages lisp programming language lisp programming language family programming languages programming languages created hidden categories all articles with unsourced statements articles with unsourced statements from october articles with unsourced statements from may articles with unsourced statements from march articles with unsourced statements from november vague ambiguous time from january articles with unsourced statements from january all accuracy disputes articles with disputed statements from april articles with unsourced statements from november articles with dmoz links navigation menu personal tools not logged talk contributions create account log namespaces article talk variants views read edit view history more search navigation main page contents featured content current events random article donate wikipedia wikipedia store interaction help about wikipedia community portal recent changes contact page tools what links here related changes upload file special pages permanent link page information wikidata item cite this page print/export create book download pdf printable version other projects wikimedia commons wikibooks wikiquote languages العربية aragonés azərbaycanca বাংলা беларуская български bosanski català čeština cymraeg dansk deutsch eesti ελληνικά español esperanto euskara فارسی français gaeilge galego 한국어 հայերեն hrvatski íslenska italiano עברית кыргызча latina latviešu lietuvių magyar മലയാളം मराठी bahasa melayu монгол nederlands 日本語 norsk bokmål polski português română русский scots shqip simple english slovenčina slovenščina کوردیی ناوەندی српски / srpski srpskohrvatski / српскохрватски suomi svenska தமிழ் ไทย тоҷикӣ türkçe українська tiếng việt žemaitėška 中文 edit links this page was last modified on november at text available under creative commons attribution-sharealike license additional terms may apply by using this site you agree terms use privacy policy wikipedia® registered trademark wikimedia foundation inc non-profit organization privacy policy about wikipedia disclaimers contact wikipedia developers cookie statement mobile view 