string literal from wikipedia free encyclopedia jump navigation search string literal anonymous string type literal programming for representation string value within source code computer program most often modern languages this quoted sequence characters formally bracketed delimiters x = foo where foo string literal with value foo – quotes are not part value one must use method such escape sequences avoid problem delimiter collision allow delimiters themselves be embedded string however there are numerous alternate notations for specifying string literals particularly more complicated cases exact notation depends on individual programming language question nevertheless there are some general guidelines that most modern programming languages follow contents syntax o bracketed delimiters + paired delimiters o whitespace delimiters o declarative notation delimiter collision o doubling up o dual quoting o multiple quoting o constructor functions escape sequences o nested escaping o raw strings multiline string literals string literal concatenation o motivation o problems different kinds strings variable interpolation embedding source code string literals see also notes references external links syntax bracketed delimiters most modern programming languages use bracket delimiters also balanced delimiters specify string literals double quotations are most common quoting delimiters used hi there empty string literally written by pair quotes with no character at all between some languages either allow mandate use single quotations instead double quotations string must begin end with same kind quotation mark type quotation mark may give slightly different semantics 'hi there' note that these quotation marks are unpaired same character used opener closer which hangover from typewriter technology which was precursor earliest computer input output devices terms regular expressions basic quoted string literal given this means that string literal written quote followed by zero one more non-quote characters followed by quote practice this often complicated by escaping other delimiters excluding newlines paired delimiters number languages provide for paired delimiters where opening closing delimiters are different these also often allow nested strings so delimiters can be embedded so long they are paired but still result delimiter collision for embedding unpaired closing delimiter examples include postscript which uses parentheses quick brown fox m4 which uses backtick ` starting delimiter apostrophe ' ending delimiter tcl allows both quotes for interpolated strings braces for raw strings quick brown fox {the quick {brown fox}} this derives from single quotations unix shells use braces c for compound statements since blocks code tcl syntactically same thing string literals – that delimiters are paired essential for making this feasible while unicode character set includes paired separate opening closing versions both single double quotations used text mostly other languages than english these are rarely used programming languages because ascii preferred these are not included ascii “hi there” ‘hi there’ „hi there“ «hi there» paired double quotations can be used visual basic net but many other programming languages will not accept them unpaired marks are preferred for compatibility - many web browsers text editors other tools will not correctly display unicode paired quotes so even languages where they are permitted many projects forbid their use for source code whitespace delimiters string literals might be ended by newlines one example mediawiki template parameters {{navbox |name=nulls |title=] ] }} there might be special syntax for multi-line strings yaml string literals may be specified by relative positioning whitespace indentation - title example multi-line string yaml body | this multi-line string special metacharacters may appear here extent this string indicated by indentation declarative notation original fortran programming language for example string literals were written so-called hollerith notation where decimal count number characters was followed by letter h then characters string 35han example hollerith string literal this declarative notation style contrasted with bracketed delimiter quoting because does not require use balanced bracketed characters on either side string advantages eliminates text searching for delimiter character therefore requires significantly less overhead avoids problem delimiter collision enables inclusion metacharacters that might otherwise be mistaken commands can be used for quite effective data compression plain text strings drawbacks this type notation error-prone if used manual entry by programmers special care needed case multi byte encodings this however not drawback when prefix generated by algorithm most likely case delimiter collision main article delimiter collision when using quoting if one wishes represent delimiter itself string literal one runs into problem delimiter collision for example if delimiter double quote one cannot simply represent double quote itself by literal second quote interpreted end string literal not value string similarly one cannot write this quotes but invalid middle quoted portion instead interpreted outside quotes there are various solutions most general-purpose which using escape sequences such \ this \in quotes\ properly escaped but there are many other solutions note that paired quotes such braces tcl allow nested string such {foo {bar} zork} but do not otherwise solve problem delimiter collision since unbalanced closing delimiter cannot simply be included {}} doubling up number languages including pascal basic dcl smalltalk sql fortran avoid delimiter collision by doubling up on quotation marks that are intended be part string literal itself 'this pascal string''contains two apostrophes''' i said can you hear me dual quoting some languages such fortran modula-2 javascript python php allow more than one quoting delimiter case two possible delimiters this known dual quoting typically this consists allowing programmer use either single quotations double quotations interchangeably – each literal must use one other this john's apple 'i said can you hear me' this does not allow having single literal with both delimiters however this can be worked around by using several literals using string concatenation 'i said this ' + john's + ' apple' note that python has string literal concatenation so consecutive string literals are concatenated even without operator so this can be reduced 'i said this 'john's' apple' d supports few quoting delimiters with such strings starting with q similarly for other delimiter character any {} d also supports here document-style strings via similar syntax some programming languages such sh perl there are different delimiters that are treated differently such doing string interpolation not thus care must be taken when choosing which delimiter use see different kinds strings below multiple quoting further extension use multiple quoting which allows author choose which characters should specify bounds string literal for example perl qq^i said can you hear me^ qq@i said can you hear me@ qq§i said can you hear me§ all produce desired result although this notation more flexible few languages support other than perl ruby influenced by perl c++11 also support these c++11 raw strings can have various delimiters beginning with rdelimiter end with delimiter delimiter can be from zero characters long may contain any member basic source character set except whitespace characters parentheses backslash variant multiple quoting use here document-style strings lua provides limited form multiple quoting particularly allow nesting long comments embedded strings normally one uses ] delimit literal strings initial newline stripped otherwise raw but opening brackets can include any number equal signs only closing brackets with same number signs close string for example local ls = ] ]=] multiple quoting particularly useful with regular expressions that contain usual delimiters such quotes this avoids needing escape them early example sed where substitution command s/regex/ replacement/ default slash / delimiters can be replaced by another character sregexreplacement constructor functions another option which rarely used modern languages use function construct string rather than representing via literal this generally not used modern languages because computation done at run time rather than at parse time for example early forms basic did not include escape sequences any other workarounds listed here thus one instead was required use chr$ function which returns string containing character corresponding its argument ascii quotation mark has value so represent string with quotes on ascii system one would write i said + chr$34 + can you hear me + chr$34 c similar facility available via sprintf %c character format specifier though presence other workarounds this generally not used sprintfthis %cin quotes%c these constructor functions can also be used represent nonprinting characters though escape sequences are generally used instead similar technique can be used c++ with stdstring stringification operator escape sequences main article escape sequence escape sequences are general technique for represent characters that are otherwise difficult represent directly including delimiters nonprinting characters such backspaces newlines whitespace characters which are otherwise impossible distinguish visually have long history they are accordingly widely used string literals adding escape sequence either single character throughout string known escaping one character chosen prefix give encodings for characters that are difficult impossible include directly most commonly this backslash addition other characters key point that backslash itself can be encoded double backslash \\ for delimited strings delimiter itself can be encoded by escaping say by \ for regular expression for such escaped strings can be given follows found ansi c specification \\| meaning quote followed by zero more either escaped character backslash followed by something possibly backslash quote non-escape non-quote character ending quote – only issue distinguishing terminating quote from quote preceded by backslash which may itself be escaped note that multiple characters can follow backslash such \uffff depending on escaping scheme escaped string must then itself be lexically analyzed converting escaped string into unescaped string that represents this done during evaluation phase overall lexing computer language evaluator lexer overall language executes its own lexer for escaped string literals among other things must be possible encode character that normally terminates string constant plus there must be some way specify escape character itself escape sequences are not always pretty easy use so many compilers also offer other means solving common problems escape sequences however solve every delimiter problem most compilers interpret escape sequences when escape character inside string literal means this start escape sequence every escape sequence specifies one character which be placed directly into string actual number characters required escape sequence varies escape character on top/left keyboard but editor will translate therefore not directly tapeable into string backslash used represent escape character string literal many languages support use metacharacters inside string literals metacharacters have varying interpretations depending on context language but are generally kind 'processing command' for representing printing nonprinting characters for instance c string literal if backslash followed by letter such b n t then this represents nonprinting backspace newline tab character respectively if backslash followed by 1-3 octal digits then this sequence interpreted representing arbitrary character with specified ascii code this was later extended allow more modern hexadecimal character code notation i said\t\t\x22can you hear me\x22\n escape sequence unicode literal characters placed into string \0 u+0000 null character typically special case \ooo octal notation \a u+0007 alert \b u+0008 backspace \f u+000c form feed \n u+000a line feed newline posix \r u+000d carriage return newline mac os earlier \t u+0009 horizontal tab \v u+000b vertical tab \e u+001b escape character gcc clang tcc \u u+ 16-bit unicode character where are four hex digits \u u+ 32-bit unicode character where are eight hex digits note that unicode only supports 21-bit characters so first two digits are always zero \u{} u+ 21-bit unicode character where variable number hex digits \x u+00 8-bit character specification where hex digit \ooo u+00 8-bit character specification where o octal digit \ u+0022 double quote \& non-character used delimit numeric escapes haskell \' u+0027 single quote ' \\ u+005c backslash \ \ u+003f question mark note not all sequences above list are supported by all parsers there may be other escape sequences which are not above list nested escaping when code one programming language embedded inside another embedded strings may require multiple levels escaping this particularly common regular expressions sql query within other languages other languages inside shell scripts this double-escaping often difficult read author incorrect quoting nested strings can present security vulnerability use untrusted data data fields sql query should use prepared statements prevent code injection attack php through there was feature called magic quotes which automatically escaped strings for convenience security but due problems was removed from version onward raw strings few languages provide method specifying that literal be processed without any language-specific interpretation this avoids need for escaping yields more legible strings raw strings are particularly useful when common character needs be escaped notably regular expressions nested string literals where backslash \ widely used dos/windows paths where backslash used path separator profusion backslashes known leaning toothpick syndrome can be reduced by using raw strings compare escaped raw pathnames windows path c\\foo\\bar\\baz\\ @the windows path c\foo\bar\baz\ extreme examples occur when these are combined – uniform naming convention paths begin with \\ thus escaped regular expression matching unc name begins with backslashes \\\\\\\\ due needing escape string regular expression using raw strings reduces this escaping regular expression c @\\\\ xml documents cdata sections allows use characters such & multiline string literals many languages string literals can contain literal newlines spanning several lines alternatively newlines can be escaped most often \n for example echo 'foo bar' echo -e foo\nbar are both valid bash producing foo bar languages that allow literal newlines include bash lua perl r tcl some other languages string literals cannot include newlines two problems with multiline string literals are leading trailing newlines indentation if initial final delimiters are on separate lines there are extra newlines while if they are not delimiter makes string harder read particularly for first line which often indented differently from rest further literal must be unindented leading whitespace preserved – this breaks flow code if literal occurs within indented code most common solution for these problems here document-style string literals formally speaking here document not string literal but instead stream literal file literal these originate shell scripts allow literal be fed input external command opening delimiter integers by preprocessor define macro that expands sequence string literals which are then concatenated single string literal with file name line number define stringifyx x define tostringx stringifyx define at file tostringline beyond syntactic requirements c/c++ implicit concatenation form syntactic sugar making simpler split string literals across several lines avoiding need for line continuation via backslashes allowing one add comments parts strings for example python one can comment regular expression this way recompile letter underscore letter digit underscore problems implicit string concatenation not required by modern compilers which implement constant folding causes hard-to-spot errors due unintentional concatenation from omitting comma particularly vertical lists strings l = accordingly not used most languages has been proposed for deprecation from d python however removing feature breaks backwards compatibility replacing with concatenation operator introduces issues precedence – string literal concatenation occurs during lexing prior operator evaluation but concatenation via explicit operator occurs at same time other operators hence precedence issue potentially requiring parentheses ensure desired evaluation order subtler issue that c c++ there are different types string literals concatenation these has implementation-defined behavior which poses potential security risk different kinds strings some languages provide more than one kind literal which have different behavior this particularly used indicate raw strings no escaping disable enable variable interpolation but has other uses such distinguishing character sets most often this done by changing quoting character adding prefix this comparable prefixes suffixes integer literals such indicate hexadecimal numbers long integers one oldest examples shell scripts where single quotes indicate raw string literal string while double quotes have escape sequences variable interpolation for example python raw strings are preceded by r r – compare 'c\\windows' with r'c\windows' though python raw string cannot end odd number backslashes python also distinguishes two types strings 8-bit ascii bytes strings default explicitly indicated with b b prefix unicode strings indicated with u u prefix c's notation for raw strings called @-quoting @c\foo\bar\baz\ while this disables escaping allows double-up quotes which allow one represent quotes within string @i said hello there c++11 allows raw strings unicode strings utf-8 utf-16 utf-32 wide character strings determined by prefixes tcl brace-delimited strings are literal while quote-delimited strings have escaping interpolation perl has wide variety strings which are more formally considered operators are known quote quote-like operators these include both usual syntax fixed delimiters generic syntax which allows choice delimiters these include '' `` // m// qr// s/// y/// q{} qq{} qx{} qw{} m{} qr{} s{}{} tr{}{} y{}{} rexx uses suffix characters specify characters strings using their hexadecimal binary code eg '20'x 0000b 00100000b all yield space character avoiding function call x2c20 variable interpolation main article variable interpolation languages differ on whether how interpret string literals either 'raw' 'variable interpolated' variable interpolation process evaluating expression containing one more variables returning output where variables are replaced with their corresponding values memory sh-compatible unix shells quotation-delimited strings are interpolated while apostrophe-delimited ' strings are not for example following perl code $name = nancy $greeting = hello world print $name said $greeting crowd people produces output nancy said hello world crowd people sigil character $ interpreted indicate variable interpolation similarly printf function produces same output using notation such printf %s said %s crowd people $name $greeting metacharacters %s indicate variable interpolation this contrasted with raw strings print '$name said $greeting crowd people' which produce output like $name said $greeting crowd people here $ characters are not sigils are not interpreted have any meaning other than plain text embedding source code string literals languages that lack flexibility specifying string literals make particularly cumbersome write programming code that generates other programming code this particularly true when generation language same similar output language for example writing code produce quines generating output language from within web template using xslt generate xslt sql generate more sql generating postscript representation document for printing purposes from within document-processing application written c some other language writing shaders nevertheless some languages are particularly well-adapted produce this sort self-similar output especially those that support multiple options for avoiding delimiter collision using string literals code that generates other code may have adverse security implications especially if output based at least partially on untrusted user input this particularly acute case web-based applications where malicious users can take advantage such weaknesses subvert operation application for example by mounting sql injection attack see also character literal sigil computer programming notes note that regex given here not itself quoted escaped reduce confusion references introduction java - mfc g string literals constants are called ‘anonymous strings’ ansi c grammar lex liuse retrieved june b appendix b characters strings escaping rules realworldhaskellorg retrieved june b string mozillaorg retrieved june b c d e f g h i j k l m escape sequences c microsoftcom retrieved june b rationale for international standard - programming languages - c pdf april pp 153–154 archived pdf from original on retrieved character constants gcc manual retrieved c11 draft standard wg14 n1570 committee draft — april translation phases p adjacent string literal tokens are concatenated c syntax string literal concatenation c++11 draft standard working draft standard for programming language c++ pdf phases translation p adjacent string literal tokens are concatenated string literals note p 28–29 translation phase adjacent string literals are concatenated d programming language lexical analysis string literals adjacent strings are concatenated with ~ operator by simple juxtaposition python language reference lexical analysis string literal concatenation multiple adjacent string literals delimited by whitespace possibly using different quoting conventions are allowed their meaning same their concatenation b c python-ideas implicit string literal concatenation considered harmful guido van rossum may python language reference lexical analysis string literal concatenation note that this feature defined at syntactical level but implemented at compile time ‘+’ operator must be used concatenate string expressions at run time strings java™ tutorials > learning java language > numbers strings docsoraclecom retrieved rationale for ansi c programming language silicon press p isbn 0-929306-07-4 string literals long string can be continued across multiple lines by using backslash-newline line continuation but this practice requires that continuation string start first position next line permit more flexible layout solve some preprocessing problems see §383 committee introduced string literal concatenation two string literals row are pasted together with no null character middle make one combined string literal this addition c language allows programmer extend string literal beyond end physical line without having use backslash-newline mechanism thereby destroying indentation scheme program explicit concatenation operator was not introduced because concatenation lexical construct rather than run-time operation rationale for ansi c programming language silicon press p 65–66 isbn 0-929306-07-4 operator operator has been introduced for stringizing may only be used define expansion causes formal parameter name following be replaced by string literal formed by stringizing actual argument token sequence conjunction with string literal concatenation see §314 use this operator permits construction strings effectively by identifier replacement within string example standard illustrates this feature c/c++ users journal volume p python - why allow concatenation string literals stack overflow retrieved line string stringify using preprocessor directives decompilecom retrieved python language reference lexical analysis string literal concatenation this feature can be used reduce number backslashes needed split long strings conveniently across long lines even add comments parts strings for example dlang's issue tracking system – issue - warn against then deprecate implicit concatenation adjacent string literals c++11 draft standard working draft standard for programming language c++ pdf string literals note p 28–29 any other concatenations are conditionally supported with implementation-deﬁned behavior archived copy archived from original on july retrieved july lexical analysis — python 2712rc1 documentation pythonorg retrieved june perlop - perldocperlorg perlorg retrieved june external links literals programming retrieved from https//enwikipediaorg/w/indexphptitle=stringliteral&oldid=751823687 categories source code string computer science hidden categories all articles with unsourced statements articles with unsourced statements from october articles with unsourced statements from march articles with unsourced statements from february articles with unsourced statements from march navigation menu personal tools not logged talk contributions create account log namespaces article talk variants views read edit view history more search navigation main page contents featured content current events random article donate wikipedia wikipedia store interaction help about wikipedia community portal recent changes contact page tools what links here related changes upload file special pages permanent link page information wikidata item cite this page print/export create book download pdf printable version languages қазақша polski edit links this page was last modified on november at text available under creative commons attribution-sharealike license additional terms may apply by using this site you agree terms use privacy policy wikipedia® registered trademark wikimedia foundation inc non-profit organization privacy policy about wikipedia disclaimers contact wikipedia developers cookie statement mobile view 