instruction set from wikipedia free encyclopedia   redirected from instruction set architecture jump navigation search for other uses isa see isa disambiguation instruction set instruction set architecture isa part computer architecture related programming including native data types instructions registers addressing modes memory architecture interrupt exception handling external i/o isa includes specification set opcodes machine language native commands implemented by particular processor instruction set interface between computer's software its hardware thereby enables independent development these two computing realms contents overview classification instruction sets machine language o instruction types + data handling memory operations + arithmetic logic operations + control flow operations + coprocessor instructions o complex instructions o parts instruction o instruction length o representation o design instruction set implementation o code density o number operands o register pressure see also o categories isa references further reading external links overview instruction set architecture distinguished from microarchitecture which set processor design techniques used particular processor implement instruction set processors with different microarchitectures can share common instruction set for example intel pentium amd athlon implement nearly identical versions x86 instruction set but have radically different internal designs concept architecture distinct from design specific machine was developed by fred brooks at ibm during design phase system/360 prior npl company's computer designers had been free honor cost objectives not only by selecting technologies but also by fashioning functional architectural refinements spread compatibility objective contrast postulated single architecture for series five processors spanning wide range cost performance none five engineering design teams could count on being able bring about adjustments architectural specifications way easing difficulties achieving cost performance objectivesp137 some virtual machines that support bytecode their isa such smalltalk java virtual machine microsoft's common language runtime implement this by translating bytecode for commonly used code paths into native machine code addition these virtual machines execute less frequently used code paths by interpretation see just-in-time compilation transmeta implemented x86 instruction set atop vliw processors this fashion classification instruction sets complex instruction set computer cisc has many specialized instructions some which may only be rarely used practical programs reduced instruction set computer risc simplifies processor by efficiently implementing only instructions that are frequently used programs while less common operations are implemented subroutines having their resulting additional processor execution time offset by infrequent use theoretically important types are minimal instruction set computer one instruction set computer but these are not implemented commercial processors another variation very long instruction word vliw where processor receives many instructions encoded retrieved one instruction word machine language machine language built up from discrete statements instructions on processing architecture given instruction may specify particular registers for arithmetic addressing control functions particular memory locations offsets particular addressing modes used interpret operands more complex operations are built up by combining these simple instructions which are executed sequentially otherwise directed by control flow instructions instruction types examples operations common many instruction sets include data handling memory operations set register fixed constant value copy data from memory location register vice versa machine instruction often called move however term misleading used store contents register result computation retrieve stored data perform computation on later often called load store operations read write data from hardware devices arithmetic logic operations add subtract multiply divide values two registers placing result register possibly setting one more condition codes status register perform bitwise operations eg taking conjunction disjunction corresponding bits pair registers taking negation each bit register compare two values registers for example see if one less if they are equal control flow operations branch another location program execute instructions there conditionally branch another location if certain condition holds indirectly branch another location call another block code while saving location next instruction point return coprocessor instructions load/store data from coprocessor exchanging with cpu registers performing coprocessor operations complex instructions processors may include complex instructions their instruction set single complex instruction does something that may take many instructions on other computers such instructions are typified by instructions that take multiple steps control multiple functional units otherwise appear on larger scale than bulk simple instructions implemented by given processor some examples complex instructions include saving many registers on stack at once moving large blocks memory complicated integer floating-point arithmetic sine cosine square root etc simd instructions single instruction performing operation on many values parallel performing atomic test-and-set instruction other read-modify-write atomic instruction instructions that perform alu operations with operand from memory rather than register complex instructions are more common cisc instruction sets than risc instruction sets but risc instruction sets may include them well risc instruction sets generally do not include alu operations with memory operands instructions move large blocks memory but most risc instruction sets include simd vector instructions that perform same arithmetic operation on multiple pieces data at same time simd instructions have ability manipulating large vectors matrices minimal time simd instructions allow easy parallelization algorithms commonly involved sound image video processing various simd implementations have been brought market under trade names such mmx 3dnow altivec specialised processor types like gpus for example also provide complex instruction sets nonetheless many these specialised processor complex instruction sets do not have publicly available native instruction set native assembly language for proprietary hardware related reasons are usually only accessible software developers through standardized higher level languages apis opengl virtual instruction set virtual assembly language arb assembly language cuda are examples such hardware abstraction layers on top specialised processor native instruction set parts instruction one instruction may have several fields which identify logical operation may also include source destination addresses constant values this mips add immediate instruction which allows selection source destination registers inclusion small constant on traditional architectures instruction includes opcode that specifies operation perform such add contents memory register—and zero more operand specifiers which may specify registers memory locations literal data operand specifiers may have addressing modes determining their meaning may be fixed fields very long instruction word vliw architectures which include many microcode architectures multiple simultaneous opcodes operands are specified single instruction some exotic instruction sets do not have opcode field such transport triggered architectures tta only operands forth virtual machine other 0-operand instruction sets lack any operand specifier fields such some stack machines including nosc conditional instructions often have predicate field—a few bits that encode specific condition cause operation be performed rather than not performed for example conditional branch instruction will be executed branch taken if condition true so that execution proceeds different part program not executed branch not taken if condition false so that execution continues sequentially some instruction sets also have conditional moves so that move will be executed data stored target location if condition true not executed target location not modified if condition false similarly ibm z/architecture has conditional store few instruction sets include predicate field every instruction this called branch predication instruction length size length instruction varies widely from little four bits some microcontrollers many hundreds bits some vliw systems processors used personal computers mainframes supercomputers have instruction sizes between bits longest possible instruction on x86 bytes bits within instruction set different instructions may have different lengths some architectures notably most reduced instruction set computers risc instructions are fixed length typically corresponding with that architecture's word size other architectures instructions have variable length typically integral multiples byte halfword some such arm with thumb-extension have mixed variable encoding that two fixed usually 32-bit 16-bit encodings where instructions can not be mixed freely but must be switched between on branch exception boundary armv8 risc instruction set normally has fixed instruction width often bytes = bits whereas typical cisc instruction set may have instructions widely varying length bytes for x86 fixed-width instructions are less complicated handle than variable-width instructions for several reasons not having check whether instruction straddles cache line virtual memory page boundary for instance are therefore somewhat easier optimize for speed representation instructions constituting program are rarely specified using their internal numeric form machine code they may be specified by programmers using assembly language more commonly may be generated from programming languages by compilers design design instruction sets complex issue there were two stages history for microprocessor first was cisc complex instruction set computer which had many different instructions 1970s however places like ibm did research found that many instructions set could be eliminated result was risc reduced instruction set computer architecture that uses smaller set instructions simpler instruction set may offer potential for higher speeds reduced processor size reduced power consumption however more complex set may optimize common operations improve memory/cache efficiency simplify programming some instruction set designers reserve one more opcodes for some kind system call software interrupt for example mos technology uses h zilog z80 uses eight codes c7cfd7dfe7eff7ffh while motorola use codes range a000afffh fast virtual machines are much easier implement if instruction set meets popek goldberg virtualization requirements nop slide used immunity aware programming much easier implement if unprogrammed state memory interpreted nop on systems with multiple processors non-blocking synchronization algorithms are much easier implement if instruction set includes support for something such fetch-and-add load-link/store-conditional ll/sc atomic compare swap instruction set implementation any given instruction set can be implemented variety ways all ways implementing particular instruction set provide same programming model all implementations that instruction set are able run same binary executables various ways implementing instruction set give different tradeoffs between cost performance power consumption size etc when designing microarchitecture processor engineers use blocks hard-wired electronic circuitry often designed separately such adders multiplexers counters registers alus etc some kind register transfer language then often used describe decoding sequencing each instruction isa using this physical microarchitecture there are two basic ways build control unit implement this description although many designs use middle ways compromises some computer designs hardwire complete instruction set decoding sequencing just like rest microarchitecture other designs employ microcode routines tables both do this—typically on-chip roms plas both although separate rams roms have been used historically western digital mcp-1600 older example using dedicated separate rom for microcode some designs use combination hardwired design microcode for control unit some cpu designs use writable control store—they compile instruction set writable ram flash inside cpu such rekursiv processor imsys cjip fpga reconfigurable computing isa can also be emulated software by interpreter naturally due interpretation overhead this slower than directly running programs on emulated hardware unless hardware running emulator order magnitude faster today common practice for vendors new isas microarchitectures make software emulators available software developers before hardware implementation ready often details implementation have strong influence on particular instructions selected for instruction set for example many implementations instruction pipeline only allow single memory load memory store per instruction leading load-store architecture risc for another example some early ways implementing instruction pipeline led delay slot demands high-speed digital signal processing have pushed opposite direction—forcing instructions be implemented particular way for example perform digital filters fast enough mac instruction typical digital signal processor dsp must use kind harvard architecture that can fetch instruction two data words simultaneously requires single-cycle multiply–accumulate multiplier code density early computers memory was expensive so minimizing size program make sure would fit limited memory was often central thus combined size all instructions needed perform particular task code density was important characteristic any instruction set computers with high code density often have complex instructions for procedure entry parameterized returns loops etc therefore retroactively named complex instruction set computers cisc however more typical frequent cisc instructions merely combine basic alu operation such add with access one more operands memory using addressing modes such direct indirect indexed etc certain architectures may allow two three operands including result directly memory may be able perform functions such automatic pointer increment etc software-implemented instruction sets may have even more complex powerful instructions reduced instruction-set computers risc were first widely implemented during period rapidly growing memory subsystems they sacrifice code density simplify implementation circuitry try increase performance via higher clock frequencies more registers single risc instruction typically performs only single operation such add registers load from memory location into register risc instruction set normally has fixed instruction width whereas typical cisc instruction set has instructions widely varying length however risc computers normally require more often longer instructions implement given task they inherently make less optimal use bus bandwidth cache memories certain embedded risc isas like thumb avr32 typically exhibit very high density owing technique called code compression this technique packs two 16-bit instructions into one 32-bit instruction which then unpacked at decode stage executed two instructions minimal instruction set computers misc are form stack machine where there are few separate instructions 16-64 so that multiple instructions can be fit into single machine word these type cores often take little silicon implement so they can be easily realized fpga multi-core form code density misc similar code density risc increased instruction density offset by requiring more primitive instructions do task there has been research into executable compression mechanism for improving code density mathematics kolmogorov complexity describes challenges limits this number operands instruction sets may be categorized by maximum number operands explicitly specified instructions examples that follow b c are direct calculated addresses referring memory cells while reg1 so on refer machine registers c = a+b 0-operand zero-address machines so called stack machines all arithmetic operations take place using top one two positions on stack push push b add pop c o c = a+b needs four instructions for stack machines terms 0-operand zero-address apply arithmetic instructions but not all instructions 1-operand push pop instructions are used access memory 1-operand one-address machines so called accumulator machines include early computers many small microcontrollers most instructions specify single right operand that constant register memory location with implicit accumulator left operand destination if there one load add b store c o c = a+b needs three instructions 2-operand — many cisc risc machines fall under this category o cisc — move c then add b c + c = a+b needs two instructions this effectively 'stores' result without explicit store instruction o cisc — often machines are limited one memory operand per instruction load areg1 add breg1 store reg1c this requires load/store pair for any memory movement regardless whether add result augmentation stored different place c = a+b same memory location = a+b + c = a+b needs three instructions o risc — requiring explicit memory loads instructions would be load areg1 load breg2 add reg1reg2 store reg2c + c = a+b needs four instructions 3-operand allowing better reuse data o cisc — becomes either single instruction add abc + c = a+b needs one instruction o cisc — on machines limited two memory operands per instruction move areg1 add reg1bc + c = a+b needs two instructions o risc — arithmetic instructions use registers only so explicit 2-operand load/store instructions are needed load areg1 load breg2 add reg1+reg2->reg3 store reg3c + c = a+b needs four instructions + unlike 2-operand 1-operand this leaves all three values b c registers available for further reuse more operands—some cisc machines permit variety addressing modes that allow more than operands registers memory accesses such vax poly polynomial evaluation instruction due large number bits needed encode three registers 3-operand instruction risc processors using 16-bit instructions are invariably 2-operand machines such atmel avr ti msp430 some versions arm thumb risc processors using 32-bit instructions are usually 3-operand machines such processors implementing power architecture sparc architecture mips architecture arm architecture avr32 architecture each instruction specifies some number operands registers memory locations immediate values explicitly some instructions give one both operands implicitly such by being stored on top stack implicit register if some operands are given implicitly fewer operands need be specified instruction when destination operand explicitly specifies destination additional operand must be supplied consequently number operands encoded instruction may differ from mathematically necessary number arguments for logical arithmetic operation arity operands are either encoded opcode representation instruction else are given values addresses following instruction register pressure register pressure measures availability free registers at any point time during program execution register pressure high when large number available registers are use thus higher register pressure more often register contents must be spilled into memory increasing number registers architecture decreases register pressure but increases cost while embedded risc isas like thumb suffer from extremely high register pressure due lack available programmable registers general-purpose risc isas like mips alpha enjoy low register pressure cisc isas like x86-64 offer low register pressure despite fact that they have fewer programmable registers this manifestation many addressing modes optimizations such sub-register addressing memory operands alu instructions absolute addressing pc-relative addressing register-to-register spills which these isas offer see also computer science portal comparison instruction set architectures computer architecture cpu design emulator instruction set simulator ovpsim full systems simulator providing ability create/model/emulate any instruction set using c standard apis register transfer language rtl list instruction sets categories isa epic explicitly parallel instruction computing vector processor simd single instruction multiple data flynn's taxonomy orthogonal instruction set references pugh emerson w johnson lyle r palmer john h ibm's early systems mit press isbn 0-262-16123-0 crystal chen greg novick kirk shimano december risc architecture risc vs cisc csstanfordedu retrieved february forth resources nosc mail list archive strangegizmocom retrieved intel® ia-32 architectures software developer's manual intel corporation retrieved july b c evolution risc technology at ibm by john cocke – ibm journal r&d volume numbers 1/2 p48 ganssle jack proactive debugging published february great microprocessors past present v cpushacknet retrieved weaver vincent m mckee sally code density concerns for new architectures ieee international conference on computer design page daniel compilers practical introduction computer architecture springer p isbn 978-1-84882-255-9 venkat ashish tullsen dean m harnessing isa diversity design heterogeneous-isa chip multiprocessor 41st annual international symposium on computer architecture further reading bowen jonathan p july–august standard microprocessor programming cards 274–290 doi101016/0141-93318590116-4 external links wikibook microprocessor design has page on topic code density programming textfiles bowen's instruction summary cards mark smotherman's historical computer designs page v t e cpu technologies architecture von neumann harvard modified dataflow tta instruction set asip cisc risc edge trips vliw epic misc oisc nisc zisc comparison word size 1-bit 4-bit 8-bit 9-bit 10-bit 12-bit 15-bit 16-bit 18-bit 22-bit 24-bit 25-bit 26-bit 27-bit 31-bit 32-bit 33-bit 34-bit 36-bit 39-bit 40-bit 48-bit 50-bit 60-bit 64-bit 128-bit 256-bit 512-bit variable execution instruction pipelining o bubble o operand forwarding out-of-order execution o register renaming speculative execution o branch predictor o memory dependence prediction hazards parallel level bit o bit-serial o word instruction o scalar o superscalar task o thread o process data o vector memory multithreading temporal simultaneous preemptive cooperative flynn's taxonomy sisd simd misd mimd o spmd addressing mode types digital signal processor dsp gpgpu microcontroller physics processing unit system on chip soc cellular components address generation unit agu arithmetic logic unit alu barrel shifter floating-point unit fpu back-side bus o multiplexer o demultiplexer registers memory management unit mmu translation lookaside buffer tlb cache register file microcode control unit clock rate power management apm acpi dynamic frequency scaling dynamic voltage scaling clock gating hardware security non-executable memory nx bit bounds checking intel mpx hardware restriction firmware software guard extensions intel sgx trusted execution technology secure cryptoprocessor hardware security module hengzhi chip authority control gnd 4129931-0 retrieved from https//enwikipediaorg/w/indexphptitle=instructionset&oldid=747634807 categories central processing unit microprocessors instruction processing instruction set architectures hidden categories all articles with unsourced statements articles with unsourced statements from october all articles lacking reliable references articles lacking reliable references from july wikipedia articles needing clarification from october all accuracy disputes articles with disputed statements from october articles with unsourced statements from january wikipedia articles with gnd identifiers navigation menu personal tools not logged talk contributions create account log namespaces article talk variants views read edit view history more search navigation main page contents featured content current events random article donate wikipedia wikipedia store interaction help about wikipedia community portal recent changes contact page tools what links here related changes upload file special pages permanent link page information wikidata item cite this page print/export create book download pdf printable version languages العربية català čeština dansk deutsch eesti ελληνικά español فارسی français gaeilge 한국어 bahasa indonesia italiano עברית latviešu magyar nederlands 日本語 norsk bokmål polski português română русский simple english slovenčina کوردیی ناوەندی српски / srpski svenska ไทย türkçe українська اردو tiếng việt 中文 edit links this page was last modified on november at text available under creative commons attribution-sharealike license additional terms may apply by using this site you agree terms use privacy policy wikipedia® registered trademark wikimedia foundation inc non-profit organization privacy policy about wikipedia disclaimers contact wikipedia developers cookie statement mobile view 